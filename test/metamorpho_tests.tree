.
└── setRiskManager(address newRiskManager) external onlyOwner
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when newRiskManager == riskManager
        │   └── revert with ALREADY_SET
        └── when newRiskManager != riskManager
            ├── it should set riskManager to newRiskManager
            └── it should emit SetRiskManager(newRiskManager)

.
└── setIsAllocator(address newAllocator, bool newIsAllocator) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when _isAllocator[newAllocator] == newIsAllocator
        │   └── revert with ALREADY_SET
        └── when _isAllocator[newAllocator] != newIsAllocator
            ├── it should set _isAllocator[newAllocator] to newIsAllocator
            └── it should emit SetIsAllocator(newAllocator, newIsAllocator)

.
└── submitTimelock(uint256 newTimelock) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when newTimelock > MAX_TIMELOCK
        │   └── revert with MAX_TIMELOCK_EXCEEDED
        └── when newTimelock <= MAX_TIMELOCK
            ├── when newTimelock == timelock
            │   └── revert with ALREADY_SET
            └── when newTimelock != timelock
                ├── when newTimelock > timelock or timelock == 0
                │   ├── it should set timelock to newTimelock
                │   ├── it should emit SetTimelock(newTimelock)
                │   └── it should delete pendingTimelock
                └── when newTimelock < timelock and timelock != 0
                    ├── it should set pendingTimelock to PendingUint192(uint192(newTimelock), uint64(block.timestamp))
                    └── it should emit SubmitTimelock(newTimelock)

.
└── acceptTimelock() external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when pendingTimelock.submittedAt == 0
        │   └── revert with NO_PENDING_VALUE
        └── when pendingTimelock.submittedAt != 0
            ├── when block.timestamp < pendingTimelock.submittedAt + timelock
            │   └── revert with TIMELOCK_NOT_ELAPSED
            └── when block.timestamp >= pendingTimelock.submittedAt + timelock
                ├── when block.timestamp > pendingTimelock.submittedAt + timelock + TIMELOCK_EXPIRATION
                │   └── revert with TIMELOCK_EXPIRATION_EXCEEDED
                └── whenblock.timestamp <= pendingTimelock.submittedAt + timelock + TIMELOCK_EXPIRATION
                    ├── it should set timelock to pendingTimelock.value
                    ├── it should emit SetTimelock(pendingTimelock.value)
                    └── it should delete pendingTimelock

.
└── submitFee(uint256 newFee) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when newFee > MAX_FEE
        │   └── revert with MAX_FEE_EXCEEDED
        └── when newFee <= MAX_FEE
            ├── when newFee == fee
            │   └── revert with ALREADY_SET
            └── when newFee != fee
                ├── when newFee < fee or timelock == 0
                │   ├── it should set fee to newFee
                │   ├── it should emit SetFee(newFee)
                │   └── it should delete pendingFee
                └── when newFee > fee and timelock != 0
                    ├── it should set pendingFee to PendingUint192(uint192(newFee), uint64(block.timestamp))
                    └── it should emit SubmitFee(newFee)

.
└── acceptFee() external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when pendingFee.submittedAt == 0
        │   └── revert with NO_PENDING_VALUE
        └── when pendingFee.submittedAt != 0
            ├── when block.timestamp < pendingFee.submittedAt + timelock
            │   └── revert with TIMELOCK_NOT_ELAPSED
            └── when block.timestamp >= pendingFee.submittedAt + timelock
                ├── when block.timestamp > pendingFee.submittedAt + timelock + TIMELOCK_EXPIRATION
                │   └── revert with TIMELOCK_EXPIRATION_EXCEEDED
                └── whenblock.timestamp <= pendingFee.submittedAt + timelock + TIMELOCK_EXPIRATION
                    ├── it should set fee to pendingFee.value
                    ├── it should emit SetFee(pendingFee.value)
                    └── it should delete pendingFee

.
└── submitGuardian(address newGuardian) external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner
        ├── when timelock == 0
        │   └── revert with NO_TIMELOCK
        └── when timelock != 0
            ├── when newGuardian == guardian
            │   └── revert with ALREADY_SET
            └── when newGuardian != guardian
                ├── when guardian == address(0)
                │   ├── it should set guardian to newGuardian
                │   ├── it should emit SetGuardian(newGuardian)
                │   └── it should delete pendingGuardian
                └── when guardian != address(0)
                    ├── it should it should set pendingGuardian to PendingAddress(newGuardian, uint64(block.timestamp))
                    └── it should emit SubmitGuardian(newGuardian)

.
└── acceptGuardian() external
    ├── when msg.sender not owner
    │   └── revert with NOT_OWNER
    └── when msg.sender is owner/
        ├── when pendingGuardian.submittedAt == 0
        │   └── revert with NO_PENDING_VALUE
        └── when pendingGuardian.submittedAt != 0
            ├── when block.timestamp < pendingGuardian.submittedAt + timelock
            │   └── revert with TIMELOCK_NOT_ELAPSED
            └── when block.timestamp >= pendingGuardian.submittedAt + timelock
                ├── when block.timestamp > pendingGuardian.submittedAt + timelock + TIMELOCK_EXPIRATION
                │   └── revert with TIMELOCK_EXPIRATION_EXCEEDED
                └── whenblock.timestamp <= pendingGuardian.submittedAt + timelock + TIMELOCK_EXPIRATION
                    ├── it should set guardian to pendingGuardian
                    ├── it should emit SetGuardian(pendingGuardian)
                    └── it should delete pendingGuardian

.
└── submitCap(MarketParams memory marketParams, uint256 newMarketCap) external/
    ├── when msg.sender not owner or RiskManager
    │   └── revert with NOT_RISK_MANAGER
    └── when msg.sender is owner or RiskManager
        ├── when marketParams.loanToken != asset()
        │   └── revert with INCONSISTENT_ASSET
        ├── when marketParams.loanToken == asset()
        └── it should compute id = marketParams.id()
            ├── when MORPHO.lastUpdate(id) == 0
            │   └── revert with MARKET_NOT_CREATED
            └── when MORPHO.lastUpdate(id) != 0
                ├── when newMarketCap == marketCap
                │   └── revert with ALREADY_SET
                └── when newMarketCap != marketCap
                    ├── when newMarketCap < marketCap or timelock == 0
                    │   ├── when newMarketCap > 0 and marketConfig.withdrawRank == 0
                    │   │   ├── it should push id to supplyQueue.push
                    │   │   ├── it should push id to withdrawQueue.push
                    │   │   └── if withdrawQueue.length > MAX_QUEUE_SIZE
                    │   │       └── revert with MAX_QUEUE_SIZE_EXCEEDED
                    │   ├── it should set config[id] to newMarketCap
                    │   ├── it should emit SetCap(id, newMarketCap)
                    │   └── it should delete pendingCap[id]
                    └── when newMarketCap > marketCap and timelock != 0
                        ├── it should it should set pendingCap[id] to PendingUint192(newMarketCap.toUint192(), uint64(block.timestamp))
                        └── it should emit EventsLib.SubmitCap(id, newMarketCap)

.
└── acceptCap(Id id) external
    ├── when msg.sender not owner or RiskManager
    │   └── revert with NOT_RISK_MANAGER
    └── when msg.sender is owner or RiskManager
        ├── when pendingCap[id].submittedAt == 0
        │   └── revert with NO_PENDING_VALUE
        └── when pendingCap[id].submittedAt != 0
            ├── when block.timestamp < pendingCap[id].submittedAt + timelock
            │   └── revert with TIMELOCK_NOT_ELAPSED
            └── when block.timestamp >= pendingCap[id].submittedAt + timelock
                ├── when block.timestamp > pendingCap[id].submittedAt + timelock + TIMELOCK_EXPIRATION
                │   └── revert with TIMELOCK_EXPIRATION_EXCEEDED
                └── whenblock.timestamp <= pendingCap[id].submittedAt + timelock + TIMELOCK_EXPIRATION
                    ├── when marketCap > 0 and marketConfig.withdrawRank == 0
                    │   ├── it should push id to supplyQueue.push
                    │   ├── it should push id to withdrawQueue.push
                    │   └── if withdrawQueue.length > MAX_QUEUE_SIZE
                    │       └── revert with MAX_QUEUE_SIZE_EXCEEDED
                    ├── it should set config[id] to pendingCap[id].value
                    ├── it should emit SetCap(id, pendingCap[id].value)
                    └── it should delete pendingCap[id]
